

function pop_up(opts) {
    var _opts = $.extend({}, {title: '提示', message: '', ok: function(){},yesName:"确定",noName:"取消"}, opts || {});
    var overlay = $('.overlay_pop');
    var body = $('body');
    if (overlay.length == 0) {
        overlay = $('<div class="overlay_pop"></div>');
        body.append(overlay);
    } else {
        overlay.show();
    }
    var confirm = $('.wmf-confirm');
    if (confirm.length == 0) {
        confirm = $('<div class="wmf-confirm"></div>');
        renderAlert();
        body.append(confirm);
    } else {
        confirm.empty();
        renderAlert();
        confirm.show();
    }

    function renderAlert() {
        var title = $('<div class="wmf-confirm-title">' + _opts.title + '</div>');
        var x=$('<span class="x">x</span>');
        title.append(x);
        var msg = $('<div class="wmf-confirm-message">' + _opts.message + '</div>');
        var btns = $('<div class="wmf-confirm-btns"></div>');
        var ok = $('<a href="javascript:void(0)" class="m_btn black">' + _opts.yesName + '</a>');
        var cancel = $('<a href="javascript:void(0)" class="m_btn white">' + _opts.noName + '</a>');
        btns.append(ok, cancel);
        confirm.append(title, msg);
        confirm.append(btns);
        ok.bind('click', function(){
            close();
            _opts.ok();
        });
        cancel.bind('click', function(){
            close();
        });
        x.bind('click', function() {
            close();
        })
    }

    function close() {
        confirm.empty().hide();
        overlay.hide();
    }
}

function loadHide(){
    $('#load_overly').hide();
}
function loadShow(){
    $('#load_overly').show();
}

 
/*!
 * Bootstrap v3.3.5 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.5",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.5",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.5",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.5",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.5",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.5",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),
d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.5",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
/*
  Keypress version 2.1.0 (c) 2014 David Mauro.
  Licensed under the Apache License, Version 2.0
  http://www.apache.org/licenses/LICENSE-2.0
*/
(function(){var m,v,y,z,A,r,w,B,F,C,G,H,p,s,q,o,t,D,I,E={}.hasOwnProperty,j=[].indexOf||function(a){for(var c=0,b=this.length;c<b;c++)if(c in this&&this[c]===a)return c;return-1};r={is_unordered:!1,is_counting:!1,is_exclusive:!1,is_solitary:!1,prevent_default:!1,prevent_repeat:!1};D="meta alt option ctrl shift cmd".split(" ");o="ctrl";m={debug:!1};var x=function(a){var c,b;for(c in a)E.call(a,c)&&(b=a[c],!1!==b&&(this[c]=b));this.keys=this.keys||[];this.count=this.count||0};x.prototype.allows_key_repeat=
function(){return!this.prevent_repeat&&"function"===typeof this.on_keydown};x.prototype.reset=function(){this.count=0;return this.keyup_fired=null};var g=function(a,c){var b,d;this.should_force_event_defaults=this.should_suppress_event_defaults=!1;this.sequence_delay=800;this._registered_combos=[];this._keys_down=[];this._active_combos=[];this._sequence=[];this._sequence_timer=null;this._prevent_capture=!1;this._defaults=c||{};for(b in r)E.call(r,b)&&(d=r[b],this._defaults[b]=this._defaults[b]||d);
this.element=a||document.body;b=function(a,b,c){a.addEventListener?a.addEventListener(b,c):a.attachEvent&&a.attachEvent("on"+b,c);return c};var e=this;this.keydown_event=b(this.element,"keydown",function(a){a=a||window.event;e._receive_input(a,!0);return e._bug_catcher(a)});var f=this;this.keyup_event=b(this.element,"keyup",function(a){a=a||window.event;return f._receive_input(a,!1)});var h=this;this.blur_event=b(window,"blur",function(){var a,b,c,d;d=h._keys_down;b=0;for(c=d.length;b<c;b++)a=d[b],
h._key_up(a,{});return h._keys_down=[]})};g.prototype.destroy=function(){var a;a=function(a,b,d){if(null!=a.removeEventListener)return a.removeEventListener(b,d);if(null!=a.removeEvent)return a.removeEvent("on"+b,d)};a(this.element,"keydown",this.keydown_event);a(this.element,"keyup",this.keyup_event);return a(window,"blur",this.blur_event)};g.prototype._bug_catcher=function(a){var c;if("cmd"===o&&0<=j.call(this._keys_down,"cmd")&&"cmd"!==(c=z(a.keyCode))&&"shift"!==c&&"alt"!==c&&"caps"!==c&&"tab"!==
c)return this._receive_input(a,!1)};g.prototype._cmd_bug_check=function(a){return"cmd"===o&&0<=j.call(this._keys_down,"cmd")&&0>j.call(a,"cmd")?!1:!0};g.prototype._prevent_default=function(a,c){if((c||this.should_suppress_event_defaults)&&!this.should_force_event_defaults)if(a.preventDefault?a.preventDefault():a.returnValue=!1,a.stopPropagation)return a.stopPropagation()};g.prototype._get_active_combos=function(a){var c,b;c=[];b=w(this._keys_down,function(b){return b!==a});b.push(a);this._match_combo_arrays(b,
function(a){return function(b){if(a._cmd_bug_check(b.keys))return c.push(b)}}(this));this._fuzzy_match_combo_arrays(b,function(a){return function(b){if(!(0<=j.call(c,b))&&!b.is_solitary&&a._cmd_bug_check(b.keys))return c.push(b)}}(this));return c};g.prototype._get_potential_combos=function(a){var c,b,d,e,f;b=[];f=this._registered_combos;d=0;for(e=f.length;d<e;d++)c=f[d],c.is_sequence||0<=j.call(c.keys,a)&&this._cmd_bug_check(c.keys)&&b.push(c);return b};g.prototype._add_to_active_combos=function(a){var c,
b,d,e,f,h,i,g,n,k,l;h=!1;f=!0;d=!1;if(0<=j.call(this._active_combos,a))return!0;if(this._active_combos.length){e=i=0;for(k=this._active_combos.length;0<=k?i<k:i>k;e=0<=k?++i:--i)if((c=this._active_combos[e])&&c.is_exclusive&&a.is_exclusive){c=c.keys;if(!h){g=0;for(n=c.length;g<n;g++)if(b=c[g],h=!0,0>j.call(a.keys,b)){h=!1;break}}if(f&&!h){l=a.keys;g=0;for(n=l.length;g<n;g++)if(b=l[g],f=!1,0>j.call(c,b)){f=!0;break}}h&&(d?(c=this._active_combos.splice(e,1)[0],null!=c&&c.reset()):(c=this._active_combos.splice(e,
1,a)[0],null!=c&&c.reset(),d=!0),f=!1)}}f&&this._active_combos.unshift(a);return h||f};g.prototype._remove_from_active_combos=function(a){var c,b,d,e;b=d=0;for(e=this._active_combos.length;0<=e?d<e:d>e;b=0<=e?++d:--d)if(c=this._active_combos[b],c===a){a=this._active_combos.splice(b,1)[0];a.reset();break}};g.prototype._get_possible_sequences=function(){var a,c,b,d,e,f,h,i,g,n,k,l;d=[];n=this._registered_combos;f=0;for(g=n.length;f<g;f++){a=n[f];c=h=1;for(k=this._sequence.length;1<=k?h<=k:h>=k;c=1<=
k?++h:--h)if(e=this._sequence.slice(-c),a.is_sequence){if(0>j.call(a.keys,"shift")&&(e=w(e,function(a){return"shift"!==a}),!e.length))continue;c=i=0;for(l=e.length;0<=l?i<l:i>l;c=0<=l?++i:--i)if(a.keys[c]===e[c])b=!0;else{b=!1;break}b&&d.push(a)}}return d};g.prototype._add_key_to_sequence=function(a,c){var b,d,e,f;this._sequence.push(a);d=this._get_possible_sequences();if(d.length){e=0;for(f=d.length;e<f;e++)b=d[e],this._prevent_default(c,b.prevent_default);this._sequence_timer&&clearTimeout(this._sequence_timer);
-1<this.sequence_delay&&(this._sequence_timer=setTimeout(function(){return this._sequence=[]},this.sequence_delay))}else this._sequence=[]};g.prototype._get_sequence=function(a){var c,b,d,e,f,h,i,g,n,k,l,u;k=this._registered_combos;h=0;for(n=k.length;h<n;h++)if(c=k[h],c.is_sequence){b=i=1;for(l=this._sequence.length;1<=l?i<=l:i>=l;b=1<=l?++i:--i)if(f=w(this._sequence,function(a){return 0<=j.call(c.keys,"shift")?!0:"shift"!==a}).slice(-b),c.keys.length===f.length){b=g=0;for(u=f.length;0<=u?g<u:g>u;b=
0<=u?++g:--g)if(e=f[b],!(0>j.call(c.keys,"shift")&&"shift"===e)&&!("shift"===a&&0>j.call(c.keys,"shift")))if(c.keys[b]===e)d=!0;else{d=!1;break}}if(d)return c}return!1};g.prototype._receive_input=function(a,c){var b;if(this._prevent_capture)this._keys_down.length&&(this._keys_down=[]);else if(b=z(a.keyCode),(c||this._keys_down.length||!("alt"===b||b===o))&&b)return c?this._key_down(b,a):this._key_up(b,a)};g.prototype._fire=function(a,c,b,d){"function"===typeof c["on_"+a]&&this._prevent_default(b,
!0!==c["on_"+a].call(c["this"],b,c.count,d));"release"===a&&(c.count=0);if("keyup"===a)return c.keyup_fired=!0};g.prototype._match_combo_arrays=function(a,c){var b,d,e,f;f=this._registered_combos;d=0;for(e=f.length;d<e;d++)b=f[d],(!b.is_unordered&&y(a,b.keys)||b.is_unordered&&v(a,b.keys))&&c(b)};g.prototype._fuzzy_match_combo_arrays=function(a,c){var b,d,e,f;f=this._registered_combos;d=0;for(e=f.length;d<e;d++)b=f[d],(!b.is_unordered&&C(b.keys,a)||b.is_unordered&&F(b.keys,a))&&c(b)};g.prototype._keys_remain=
function(a){var c,b,d,e;e=a.keys;b=0;for(d=e.length;b<d;b++)if(a=e[b],0<=j.call(this._keys_down,a)){c=!0;break}return c};g.prototype._key_down=function(a,c){var b,d,e,f,h;(b=A(a,c))&&(a=b);this._add_key_to_sequence(a,c);(b=this._get_sequence(a))&&this._fire("keydown",b,c);for(e in t)b=t[e],c[b]&&(e===a||0<=j.call(this._keys_down,e)||this._keys_down.push(e));for(e in t)if(b=t[e],e!==a&&0<=j.call(this._keys_down,e)&&!c[b]&&!("cmd"===e&&"cmd"!==o)){b=d=0;for(f=this._keys_down.length;0<=f?d<f:d>f;b=0<=
f?++d:--d)this._keys_down[b]===e&&this._keys_down.splice(b,1)}d=this._get_active_combos(a);e=this._get_potential_combos(a);f=0;for(h=d.length;f<h;f++)b=d[f],this._handle_combo_down(b,e,a,c);if(e.length){d=0;for(f=e.length;d<f;d++)b=e[d],this._prevent_default(c,b.prevent_default)}0>j.call(this._keys_down,a)&&this._keys_down.push(a)};g.prototype._handle_combo_down=function(a,c,b,d){var e,f,h,g,m;if(0>j.call(a.keys,b))return!1;this._prevent_default(d,a&&a.prevent_default);e=!1;if(0<=j.call(this._keys_down,
b)&&(e=!0,!a.allows_key_repeat()))return!1;h=this._add_to_active_combos(a,b);b=a.keyup_fired=!1;if(a.is_exclusive){g=0;for(m=c.length;g<m;g++)if(f=c[g],f.is_exclusive&&f.keys.length>a.keys.length){b=!0;break}}if(!b&&(a.is_counting&&"function"===typeof a.on_keydown&&(a.count+=1),h))return this._fire("keydown",a,d,e)};g.prototype._key_up=function(a,c){var b,d,e,f,h,g;b=a;(e=A(a,c))&&(a=e);e=s[b];c.shiftKey?e&&0<=j.call(this._keys_down,e)||(a=b):b&&0<=j.call(this._keys_down,b)||(a=e);(f=this._get_sequence(a))&&
this._fire("keyup",f,c);if(0>j.call(this._keys_down,a))return!1;f=h=0;for(g=this._keys_down.length;0<=g?h<g:h>g;f=0<=g?++h:--h)if((d=this._keys_down[f])===a||d===e||d===b){this._keys_down.splice(f,1);break}d=this._active_combos.length;e=[];g=this._active_combos;f=0;for(h=g.length;f<h;f++)b=g[f],0<=j.call(b.keys,a)&&e.push(b);f=0;for(h=e.length;f<h;f++)b=e[f],this._handle_combo_up(b,c,a);if(1<d){h=this._active_combos;d=0;for(f=h.length;d<f;d++)b=h[d],void 0===b||0<=j.call(e,b)||this._keys_remain(b)||
this._remove_from_active_combos(b)}};g.prototype._handle_combo_up=function(a,c,b){var d,e;this._prevent_default(c,a&&a.prevent_default);e=this._keys_remain(a);if(!a.keyup_fired&&(d=this._keys_down.slice(),d.push(b),!a.is_solitary||v(d,a.keys)))this._fire("keyup",a,c),a.is_counting&&("function"===typeof a.on_keyup&&"function"!==typeof a.on_keydown)&&(a.count+=1);e||(this._fire("release",a,c),this._remove_from_active_combos(a))};g.prototype.simple_combo=function(a,c){return this.register_combo({keys:a,
on_keydown:c})};g.prototype.counting_combo=function(a,c){return this.register_combo({keys:a,is_counting:!0,is_unordered:!1,on_keydown:c})};g.prototype.sequence_combo=function(a,c){return this.register_combo({keys:a,on_keydown:c,is_sequence:!0})};g.prototype.register_combo=function(a){var c,b,d;"string"===typeof a.keys&&(a.keys=a.keys.split(" "));d=this._defaults;for(c in d)E.call(d,c)&&(b=d[c],void 0===a[c]&&(a[c]=b));a=new x(a);if(I(a))return this._registered_combos.push(a),a};g.prototype.register_many=
function(a){var c,b,d,e;e=[];b=0;for(d=a.length;b<d;b++)c=a[b],e.push(this.register_combo(c));return e};g.prototype.unregister_combo=function(a){var c,b,d,e,f,g;if(!a)return!1;var i=this;b=function(a){var b,c,d,e;e=[];b=c=0;for(d=i._registered_combos.length;0<=d?c<d:c>d;b=0<=d?++c:--c)if(a===i._registered_combos[b]){i._registered_combos.splice(b,1);break}else e.push(void 0);return e};if(a instanceof x)return b(a);"string"===typeof a&&(a=a.split(" "));f=this._registered_combos;g=[];d=0;for(e=f.length;d<
e;d++)c=f[d],null!=c&&(c.is_unordered&&v(a,c.keys)||!c.is_unordered&&y(a,c.keys)?g.push(b(c)):g.push(void 0));return g};g.prototype.unregister_many=function(a){var c,b,d,e;e=[];b=0;for(d=a.length;b<d;b++)c=a[b],e.push(this.unregister_combo(c));return e};g.prototype.get_registered_combos=function(){return this._registered_combos};g.prototype.reset=function(){return this._registered_combos=[]};g.prototype.listen=function(){return this._prevent_capture=!1};g.prototype.stop_listening=function(){return this._prevent_capture=
!0};g.prototype.get_meta_key=function(){return o};m.Listener=g;z=function(a){return p[a]};w=function(a,c){var b;if(a.filter)return a.filter(c);var d,e,f;f=[];d=0;for(e=a.length;d<e;d++)b=a[d],c(b)&&f.push(b);return f};v=function(a,c){var b,d,e;if(a.length!==c.length)return!1;d=0;for(e=a.length;d<e;d++)if(b=a[d],!(0<=j.call(c,b)))return!1;return!0};y=function(a,c){var b,d,e;if(a.length!==c.length)return!1;b=d=0;for(e=a.length;0<=e?d<e:d>e;b=0<=e?++d:--d)if(a[b]!==c[b])return!1;return!0};F=function(a,
c){var b,d,e;d=0;for(e=a.length;d<e;d++)if(b=a[d],0>j.call(c,b))return!1;return!0};B=Array.prototype.indexOf||function(a,c){var b,d,e;b=d=0;for(e=a.length;0<=e?d<=e:d>=e;b=0<=e?++d:--d)if(a[b]===c)return b;return-1};C=function(a,c){var b,d,e,f;e=d=0;for(f=a.length;e<f;e++)if(b=a[e],b=B.call(c,b),b>=d)d=b;else return!1;return!0};q=function(){if(m.debug)return console.log.apply(console,arguments)};G=function(a){var c,b,d;c=!1;for(d in p)if(b=p[d],a===b){c=!0;break}if(!c)for(d in s)if(b=s[d],a===b){c=
!0;break}return c};I=function(a){var c,b,d,e,f,g,i;f=!0;a.keys.length||q("You're trying to bind a combo with no keys:",a);b=g=0;for(i=a.keys.length;0<=i?g<i:g>i;b=0<=i?++g:--g)d=a.keys[b],(c=H[d])&&(d=a.keys[b]=c),"meta"===d&&a.keys.splice(b,1,o),"cmd"===d&&q('Warning: use the "meta" key rather than "cmd" for Windows compatibility');i=a.keys;c=0;for(g=i.length;c<g;c++)d=i[c],G(d)||(q('Do not recognize the key "'+d+'"'),f=!1);if(0<=j.call(a.keys,"meta")||0<=j.call(a.keys,"cmd")){c=a.keys.slice();g=
0;for(i=D.length;g<i;g++)d=D[g],-1<(b=B.call(c,d))&&c.splice(b,1);1<c.length&&(q("META and CMD key combos cannot have more than 1 non-modifier keys",a,c),f=!1)}for(e in a)"undefined"===r[e]&&q("The property "+e+" is not a valid combo property. Your combo has still been registered.");return f};A=function(a,c){var b;if(!c.shiftKey)return!1;b=s[a];return null!=b?b:!1};t={cmd:"metaKey",ctrl:"ctrlKey",shift:"shiftKey",alt:"altKey"};H={escape:"esc",control:"ctrl",command:"cmd","break":"pause",windows:"cmd",
option:"alt",caps_lock:"caps",apostrophe:"'",semicolon:";",tilde:"~",accent:"`",scroll_lock:"scroll",num_lock:"num"};s={"/":"?",".":">",",":"<","'":'"',";":":","[":"{","]":"}","\\":"|","`":"~","=":"+","-":"_",1:"!",2:"@",3:"#",4:"$",5:"%",6:"^",7:"&",8:"*",9:"(","0":")"};p={"0":"\\",8:"backspace",9:"tab",12:"num",13:"enter",16:"shift",17:"ctrl",18:"alt",19:"pause",20:"caps",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",44:"print",45:"insert",
46:"delete",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",65:"a",66:"b",67:"c",68:"d",69:"e",70:"f",71:"g",72:"h",73:"i",74:"j",75:"k",76:"l",77:"m",78:"n",79:"o",80:"p",81:"q",82:"r",83:"s",84:"t",85:"u",86:"v",87:"w",88:"x",89:"y",90:"z",91:"cmd",92:"cmd",93:"cmd",96:"num_0",97:"num_1",98:"num_2",99:"num_3",100:"num_4",101:"num_5",102:"num_6",103:"num_7",104:"num_8",105:"num_9",106:"num_multiply",107:"num_add",108:"num_enter",109:"num_subtract",110:"num_decimal",111:"num_divide",
112:"f1",113:"f2",114:"f3",115:"f4",116:"f5",117:"f6",118:"f7",119:"f8",120:"f9",121:"f10",122:"f11",123:"f12",124:"print",144:"num",145:"scroll",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",223:"`",224:"cmd",225:"alt",57392:"ctrl",63289:"num",59:";",61:"-",173:"="};m._keycode_dictionary=p;m._is_array_in_array_sorted=C;-1!==navigator.userAgent.indexOf("Mac OS X")&&(o="cmd");-1!==navigator.userAgent.indexOf("Opera")&&(p["17"]="cmd");"function"===typeof define&&
define.amd?define([],function(){return m}):"undefined"!==typeof exports&&null!==exports?exports.keypress=m:window.keypress=m}).call(this);

/**
 * Created by admin on 2016/5/25.
 */
if (typeof cornerstoneTools === 'undefined') {
    cornerstoneTools = {
        referenceLines: {},
        orientation: {}
    };
}
cornerstoneTools.recognizeR = 4;
// cornerstoneTools.handleR=3;
//sj change
cornerstoneTools.handleR=1;
cornerstoneTools.distanceSqR=4;
"undefined"==typeof cornerstone&&(cornerstone={internal:{},rendering:{}}),function(a){"use strict";function b(b){if(void 0===b)throw"disable: element element must not be undefined";for(var c=a.getEnabledElements(),d=0;d<c.length;d++)if(c[d].element===b){var e={element:b};return $(b).trigger("CornerstoneElementDisabled",e),c[d].element.removeChild(c[d].canvas),void c.splice(d,1)}}a.disable=b}(cornerstone),function(a,b){"use strict";function c(c,d,e){if(void 0===c)throw"displayImage: parameter element cannot be undefined";if(void 0===d)throw"displayImage: parameter image cannot be undefined";var f=b.getEnabledElement(c);if(f.image=d,void 0===f.viewport&&(f.viewport=b.internal.getDefaultViewport(f.canvas,d)),e)for(var g in e)null!==e[g]&&(f.viewport[g]=e[g]);var h,i=new Date;if(void 0!==f.lastImageTimeStamp){var j=i.getTime()-f.lastImageTimeStamp;h=(1e3/j).toFixed()}f.lastImageTimeStamp=i.getTime();var k={viewport:f.viewport,element:f.element,image:f.image,enabledElement:f,frameRate:h};a(f.element).trigger("CornerstoneNewImage",k),b.updateImage(c)}b.displayImage=c}($,cornerstone),function(a,b){"use strict";function c(c,d,e){if(void 0===c)throw"displayImage: parameter element cannot be undefined";if(void 0===d)throw"displayImage: parameter image cannot be undefined";var f=b.getEnabledElement(c);if(f.image=d,f.viewport=b.internal.getDefaultViewport(f.canvas,d),e)for(var g in e)null!==e[g]&&(f.viewport[g]=e[g]);var h,i=new Date;if(void 0!==f.lastImageTimeStamp){var j=i.getTime()-f.lastImageTimeStamp;h=(1e3/j).toFixed()}f.lastImageTimeStamp=i.getTime();var k={viewport:f.viewport,element:f.element,image:f.image,enabledElement:f,frameRate:h};a(f.element).trigger("CornerstoneNewImage",k),b.updateImage(c)}b.displayImageForJpg=c}($,cornerstone),function(a,b){"use strict";function c(a){var c=b.getEnabledElement(a);if(void 0===c.image)throw"draw: image has not been loaded yet";b.drawImage(c)}b.draw=c}($,cornerstone),function(a,b){"use strict";function c(){for(var a=b.getEnabledElements(),c=0;c<a.length;c++){var d=a[c];d.invalid===!0&&b.drawImage(d)}}b.drawInvalidated=c}($,cornerstone),function(a){"use strict";function b(b){if(void 0===b)throw"enable: parameter element cannot be undefined";var c=document.createElement("canvas");b.appendChild(c);var d={element:b,canvas:c,image:void 0,invalid:!1,data:{}};return a.addEnabledElement(d),a.resize(b,!0),b}a.enable=b}(cornerstone),function(a){"use strict";function b(b,c){var d=a.getEnabledElement(b);return d.data.hasOwnProperty(c)===!1&&(d.data[c]={}),d.data[c]}function c(b,c){var d=a.getEnabledElement(b);delete d.data[c]}a.getElementData=b,a.removeElementData=c}(cornerstone),function(a){"use strict";function b(a){if(void 0===a)throw"getEnabledElement: parameter element must not be undefined";for(var b=0;b<f.length;b++)if(f[b].element==a)return f[b];throw"element not enabled"}function c(a){if(void 0===a)throw"getEnabledElement: enabledElement element must not be undefined";f.push(a)}function d(a){var b=[];return f.forEach(function(c){c.image&&c.image.imageId===a&&b.push(c)}),b}function e(){return f}var f=[];a.getEnabledElement=b,a.addEnabledElement=c,a.getEnabledElementsByImageId=d,a.getEnabledElements=e}(cornerstone),function(a){"use strict";function b(a){return 0===a.viewport.rotation||180===a.viewport.rotation?{width:a.image.width,height:a.image.height}:{width:a.image.height,height:a.image.width}}function c(c){var d=a.getEnabledElement(c),e=b(d),f=d.canvas.height/e.height,g=d.canvas.width/e.width;g<f?d.viewport.scale=g:d.viewport.scale=f,d.viewport.translation.x=0,d.viewport.translation.y=0,a.updateImage(c)}a.fitToWindow=c}(cornerstone),function(a,b){"use strict";function c(a,c){var d=b.getEnabledElement(a),e=b.internal.getDefaultViewport(d.canvas,c);return e}b.getDefaultViewportForImage=c}($,cornerstone),function(a,b){"use strict";function c(a){var c=b.getEnabledElement(a);return c.image}b.getImage=c}($,cornerstone),function(a){"use strict";function b(b,c,d,e,f){var g=a.getStoredPixels(b,c,d,e,f),h=a.getEnabledElement(b),i=a.internal.getModalityLUT(h.image.slope,h.image.intercept,h.viewport.modalityLUT),j=g.map(i);return j}a.getPixels=b}(cornerstone),function(a){"use strict";function b(b,c,d,e,f){if(void 0===b)throw"getStoredPixels: parameter element must not be undefined";c=Math.round(c),d=Math.round(d);for(var g=a.getEnabledElement(b),h=[],i=0,j=g.image.getPixelData(),k=0;k<f;k++)for(var l=0;l<e;l++){var m=(k+d)*g.image.columns+(l+c);h[i++]=j[m]}return h}a.getStoredPixels=b}(cornerstone),function(a){"use strict";function b(b){var c=a.getEnabledElement(b),d=c.viewport;if(void 0!==d)return{scale:d.scale,translation:{x:d.translation.x,y:d.translation.y},voi:{windowWidth:d.voi.windowWidth,windowCenter:d.voi.windowCenter},invert:d.invert,fakeColor:d.fakeColor,pixelReplication:d.pixelReplication,rotation:d.rotation,hflip:d.hflip,vflip:d.vflip,modalityLUT:d.modalityLUT,voiLUT:d.voiLUT}}a.getViewport=b}(cornerstone),function(a){"use strict";function b(a){if(void 0===a)throw"setMaximumSizeBytes: parameter numBytes must not be undefined";if(void 0===a.toFixed)throw"setMaximumSizeBytes: parameter numBytes must be a number";n=a,c()}function c(){function b(a,b){return a.timeStamp>b.timeStamp?-1:a.timeStamp<b.timeStamp?1:0}if(!(o<=n)){for(m.sort(b);o>n;){var c=m[m.length-1];o-=c.sizeInBytes,delete k[c.imageId],c.imagePromise.reject(),m.pop(),$(a).trigger("CornerstoneImageCachePromiseRemoved",{imageId:c.imageId})}var d=a.imageCache.getCacheInfo();$(a).trigger("CornerstoneImageCacheFull",d)}}function d(a,b){if(void 0===a)throw"getImagePromise: imageId must not be undefined";if(void 0===b)throw"getImagePromise: imagePromise must not be undefined";if(k.hasOwnProperty(a)===!0)throw"putImagePromise: imageId already in cache";var d={loaded:!1,imageId:a,sharedCacheKey:void 0,imagePromise:b,timeStamp:new Date,sizeInBytes:0};k[a]=d,m.push(d),b.then(function(a){if(d.loaded=!0,void 0===a.sizeInBytes)throw"putImagePromise: image does not have sizeInBytes property or";if(void 0===a.sizeInBytes.toFixed)throw"putImagePromise: image.sizeInBytes is not a number";a.sharedCacheKey?(d.sizeInBytes=a.sizeInBytes,d.sharedCacheKey=a.sharedCacheKey,l[a.sharedCacheKey]?l[a.sharedCacheKey]++:(l[a.sharedCacheKey]=1,o+=d.sizeInBytes)):(d.sizeInBytes=a.sizeInBytes,o+=d.sizeInBytes),c()})}function e(a){if(void 0===a)throw"getImagePromise: imageId must not be undefined";var b=k[a];if(void 0!==b)return b.timeStamp=new Date,b.imagePromise}function f(a){if(void 0===a)throw"removeImagePromise: imageId must not be undefined";var b=k[a];if(void 0===b)throw"removeImagePromise: imageId must not be undefined";return m.splice(m.indexOf(b),1),m.sharedCacheKey?1===l[m.sharedCacheKey]?(o-=b.sizeInBytes,delete l[m.sharedCacheKey]):l[m.sharedCacheKey]--:o-=b.sizeInBytes,delete k[a],h(b.imagePromise,b.imageId),b.imagePromise}function g(){return{maximumSizeInBytes:n,cacheSizeInBytes:o,numberOfImagesCached:m.length}}function h(a,b){a.then(function(c){c.decache&&c.decache(),a.reject(),delete k[b]}).always(function(){delete k[b]})}function i(){for(;m.length>0;){var a=m.pop();h(a.imagePromise,a.imageId)}o=0}function j(a,b){var c=k[a];c&&c.imagePromise.then(function(a){var c=b-a.sizeInBytes;a.sizeInBytes=b,o+=c})}var k={},l={},m=[],n=1073741824,o=0;a.imageCache={putImagePromise:d,getImagePromise:e,removeImagePromise:f,setMaximumSizeBytes:b,getCacheInfo:g,purgeCache:i,cachedImages:m,changeImageIdCacheSize:j}}(cornerstone),function(a,b){"use strict";function c(c){var d,e=c.indexOf(":"),f=c.substring(0,e),g=i[f];return void 0===g||null===g?void 0!==h?d=h(c):void 0:(d=g(c),d.then(function(c){a(b).trigger("CornerstoneImageLoaded",{image:c})}),d)}function d(a){if(void 0===a)throw"loadImage: parameter imageId must not be undefined";var d=b.imageCache.getImagePromise(a);if(void 0!==d)return d;if(d=c(a),void 0===d)throw"loadImage: no image loader for imageId";return d}function e(a){if(void 0===a)throw"loadAndCacheImage: parameter imageId must not be undefined";var d=b.imageCache.getImagePromise(a);if(void 0!==d)return d;if(d=c(a),void 0===d)throw"loadAndCacheImage: no image loader for imageId";return b.imageCache.putImagePromise(a,d),d}function f(a,b){i[a]=b}function g(a){var b=h;return h=a,b}var h,i={};b.loadImage=d,b.loadAndCacheImage=e,b.registerImageLoader=f,b.registerUnknownImageLoader=g}($,cornerstone),function(a){"use strict";function b(a){var b=$(a.element).find("canvas").get(0),c=(a.image,b.height/a.image.rows),d=b.width/a.image.columns;return d<c?d:c}function c(c,d){var e=new a.internal.Transform;e.translate(c.canvas.width/2,c.canvas.height/2);var f=c.viewport.rotation;0!==f&&e.rotate(f*Math.PI/180);var g=b(c),h=c.viewport.scale*g,i=c.viewport.scale*g;return c.image.rowPixelSpacing<c.image.columnPixelSpacing?h*=c.image.columnPixelSpacing/c.image.rowPixelSpacing:c.image.columnPixelSpacing<c.image.rowPixelSpacing&&(i*=c.image.rowPixelSpacing/c.image.columnPixelSpacing),e.scale(h,i),0!==f&&e.rotate(-f*Math.PI/180),e.translate(c.viewport.translation.x,c.viewport.translation.y),0!==f&&e.rotate(f*Math.PI/180),void 0!==d&&e.scale(d,d),c.viewport.hflip&&e.scale(-1,1),c.viewport.vflip&&e.scale(1,-1),e.translate(-c.image.width/2,-c.image.height/2),e}a.diy||(a.diy={}),a.diy.iniScaleCal=b,a.internal.calculateTransform=c}(cornerstone),function(a,b){"use strict";function c(b,c){var d=new Date;b.image.render(b,c);var e=b.canvas.getContext("2d"),f=new Date,g=f-d,h={viewport:b.viewport,element:b.element,image:b.image,enabledElement:b,canvasContext:e,renderTimeInMs:g};a(b.element).trigger("CornerstoneImageRendered",h),b.invalid=!1}b.internal.drawImage=c,b.drawImage=c}($,cornerstone),function(a){"use strict";function b(b,c,d,e,f,g){void 0===b.lut&&(b.lut=new Int16Array(b.maxPixelValue-Math.min(b.minPixelValue,0)+1));var h=b.lut,i=b.maxPixelValue,j=b.minPixelValue,k=a.internal.getModalityLUT(b.slope,b.intercept,f),l=a.internal.getVOILUT(c,d,g),m=0;j<0&&(m=j);var n,o,p,q;for(n=b.minPixelValue;n<=i;n++)o=k(n),p=l(o),q=Math.min(Math.max(p,0),255),e?h[n+-m]=Math.round(255-q):h[n+-m]=Math.round(q);return h}function c(a,c,d,e,f,g){if(f||g)return b(a,c,d,e,f,g);void 0===a.lut&&(a.lut=new Int16Array(a.maxPixelValue-Math.min(a.minPixelValue,0)+1));var h,i,j,k,l=a.lut,m=a.maxPixelValue,n=a.minPixelValue,o=a.slope,p=a.intercept,q=c,r=d,s=0;if(n<0&&(s=n),e===!0)for(k=a.minPixelValue;k<=m;k++)h=k*o+p,i=255*((h-r)/q+.5),j=Math.min(Math.max(i,0),255),l[k+-s]=Math.round(255-j);else for(k=a.minPixelValue;k<=m;k++)h=k*o+p,i=255*((h-r)/q+.5),j=Math.min(Math.max(i,0),255),l[k+-s]=Math.round(j)}a.internal.generateLutNew=b,a.internal.generateLut=c,a.generateLutNew=b,a.generateLut=c}(cornerstone),function(a){"use strict";function b(a,b){if(void 0===a)throw"getDefaultViewport: parameter canvas must not be undefined";if(void 0===b)throw"getDefaultViewport: parameter image must not be undefined";var c={scale:1,translation:{x:0,y:0},voi:{windowWidth:b.windowWidth,windowCenter:b.windowCenter},invert:b.invert,fakeColor:b.fakeColor,pixelReplication:!1,rotation:0,hflip:!1,vflip:!1,modalityLUT:b.modalityLUT,voiLUT:void 0};return c}a.internal.getDefaultViewport=b,a.getDefaultViewport=b}(cornerstone),function(a){"use strict";function b(b){var c=a.internal.calculateTransform(b);return c}a.internal.getTransform=b}(cornerstone),function(a,b){"use strict";b.drawImage=b.internal.drawImage,b.generateLut=b.internal.generateLut,b.storedPixelDataToCanvasImageData=b.internal.storedPixelDataToCanvasImageData,b.storedColorPixelDataToCanvasImageData=b.internal.storedColorPixelDataToCanvasImageData}($,cornerstone),function(a){"use strict";function b(a,b){var c=a,d=b;return function(a){return a*c+d}}function c(a){var b=a.lut[0],c=a.lut[a.lut.length-1],d=a.firstValueMapped+a.lut.length;return function(e){return e<a.firstValueMapped?b:e>=d?c:a.lut[e]}}function d(a,d,e){return e?c(e):b(a,d)}a.internal.getModalityLUT=d}(cornerstone),function(a){"use strict";function b(a,b,c){var d=a.minPixelValue,e=0,f=0,g=a.width*a.height*4,h=a.getPixelData(),i=b,j=c;if(d<0)for(;f<g;)j[e++]=i[h[f++]+-d],j[e++]=i[h[f++]+-d],j[e]=i[h[f]+-d],f+=2,e+=2;else for(;f<g;)j[e++]=i[h[f++]],j[e++]=i[h[f++]],j[e]=i[h[f]],f+=2,e+=2}a.internal.storedColorPixelDataToCanvasImageData=b,a.storedColorPixelDataToCanvasImageData=b}(cornerstone),function(a){"use strict";function b(a,b,d,e){var f=a.getPixelData(),g=a.minPixelValue,h=0,i=f.length,j=f,k=b,l=d,m=e;if(m)if("printBack"==m){var n=3;if(g<0)for(;h<i;)l[n-1]=255,l[n-2]=255,l[n-3]=255,l[n]=k[j[h++]+-g],n+=4;else for(;h<i;)l[n-1]=255,l[n-2]=255,l[n-3]=255,l[n]=k[j[h++]],n+=4}else{var n=0;if(g<0)for(;h<i;){var o=c[255-parseInt(k[j[h++]+-g])];l[n++]=o[0],l[n++]=o[1],l[n++]=o[2],l[n++]=255}else for(;h<i;){var o=c[255-parseInt(k[j[h++]])];l[n++]=o[0],l[n++]=o[1],l[n++]=o[2],l[n++]=255}}else{var n=3;if(g<0)for(;h<i;)l[n]=k[j[h++]+-g],n+=4;else for(;h<i;)l[n]=k[j[h++]],n+=4}}var c=[[0,0,0],[4,4,4],[8,0,8],[16,0,16],[20,0,20],[24,0,24],[33,0,33],[37,0,37],[41,0,41],[44,0,44],[49,0,49],[53,0,53],[57,0,57],[60,0,60],[66,0,66],[70,0,70],[74,0,74],[82,0,82],[90,0,90],[99,0,99],[107,0,107],[115,0,115],[123,0,123],[132,0,132],[140,0,140],[148,0,148],[156,0,156],[165,0,165],[173,0,173],[181,0,181],[189,0,189],[198,0,198],[206,0,206],[214,0,214],[222,0,222],[231,0,231],[239,0,239],[247,0,247],[255,0,255],[255,0,255],[247,0,255],[239,0,255],[231,0,255],[222,0,255],[214,0,255],[206,0,255],[198,0,255],[189,0,255],[181,0,255],[173,0,255],[165,0,255],[156,0,255],[148,0,255],[140,0,255],[132,0,255],[123,0,255],[115,0,255],[107,0,255],[99,0,255],[90,0,255],[82,0,255],[74,0,255],[66,0,255],[57,0,255],[49,0,255],[41,0,255],[33,0,255],[24,0,255],[16,0,255],[8,0,255],[0,0,255],[0,0,255],[0,8,255],[0,16,255],[0,24,255],[0,33,255],[0,41,255],[0,49,255],[0,57,255],[0,66,255],[0,74,255],[0,82,255],[0,90,255],[0,99,255],[0,107,255],[0,115,255],[0,123,255],[0,132,255],[0,140,255],[0,148,255],[0,156,255],[0,165,255],[0,169,255],[0,173,255],[0,181,255],[0,189,255],[0,198,255],[0,206,255],[0,214,255],[0,222,255],[0,231,255],[0,239,255],[0,247,255],[0,255,255],[0,255,247],[0,255,255],[0,247,231],[0,247,239],[0,239,214],[0,239,222],[0,231,198],[0,231,206],[0,222,181],[0,222,189],[0,214,165],[0,214,173],[0,206,148],[0,206,156],[0,198,123],[0,198,132],[0,198,140],[0,189,115],[0,189,123],[0,181,99],[0,181,107],[0,177,94],[0,173,82],[0,173,90],[0,165,66],[0,165,74],[0,156,41],[0,156,49],[0,156,57],[0,148,24],[0,148,33],[0,148,41],[0,140,16],[0,140,24],[0,136,10],[0,132,0],[0,132,8],[0,132,0],[8,132,0],[8,136,0],[8,140,0],[16,140,0],[24,140,0],[24,148,0],[33,148,0],[37,148,0],[41,148,0],[41,156,0],[45,156,0],[49,156,0],[57,156,0],[57,165,0],[66,165,0],[74,165,0],[74,173,0],[82,173,0],[90,173,0],[94,177,0],[99,181,0],[107,181,0],[115,189,0],[123,189,0],[132,198,0],[140,198,0],[144,202,0],[148,206,0],[156,206,0],[165,214,0],[169,214,0],[173,214,0],[181,222,0],[189,222,0],[198,231,0],[202,231,0],[206,231,0],[214,239,0],[222,239,0],[231,247,0],[239,247,0],[247,255,0],[255,255,0],[255,255,0],[255,247,0],[255,239,0],[255,231,0],[255,222,0],[255,214,0],[255,206,0],[255,198,0],[255,189,0],[255,181,0],[255,177,0],[255,173,0],[255,165,0],[255,156,0],[255,148,0],[255,144,0],[255,140,0],[255,132,0],[255,123,0],[255,115,0],[255,107,0],[255,99,0],[255,94,0],[255,90,0],[255,82,0],[255,74,0],[255,66,0],[255,57,0],[255,49,0],[255,41,0],[255,33,0],[255,24,0],[255,16,0],[255,8,0],[255,0,0],[255,0,0],[255,8,8],[255,16,16],[255,24,24],[255,33,33],[255,41,41],[255,49,49],[255,57,57],[255,66,66],[255,74,74],[255,82,82],[255,90,90],[255,99,99],[255,107,107],[255,115,115],[255,123,123],[255,132,132],[255,140,140],[255,144,144],[255,148,148],[255,152,152],[255,156,156],[255,165,165],[255,173,173],[255,181,181],[255,185,185],[255,189,189],[255,198,198],[255,206,206],[255,214,214],[255,222,222],[255,231,231],[255,239,239],[255,247,247],[255,255,255],[255,255,255]];a.internal.storedPixelDataToCanvasImageData=b,a.storedPixelDataToCanvasImageData=b}(cornerstone),function(a){"use strict";function b(){this.reset()}b.prototype.reset=function(){this.m=[1,0,0,1,0,0]},b.prototype.clone=function(){var a=new b;return a.m[0]=this.m[0],a.m[1]=this.m[1],a.m[2]=this.m[2],a.m[3]=this.m[3],a.m[4]=this.m[4],a.m[5]=this.m[5],a},b.prototype.multiply=function(a){var b=this.m[0]*a.m[0]+this.m[2]*a.m[1],c=this.m[1]*a.m[0]+this.m[3]*a.m[1],d=this.m[0]*a.m[2]+this.m[2]*a.m[3],e=this.m[1]*a.m[2]+this.m[3]*a.m[3],f=this.m[0]*a.m[4]+this.m[2]*a.m[5]+this.m[4],g=this.m[1]*a.m[4]+this.m[3]*a.m[5]+this.m[5];this.m[0]=b,this.m[1]=c,this.m[2]=d,this.m[3]=e,this.m[4]=f,this.m[5]=g},b.prototype.invert=function(){var a=1/(this.m[0]*this.m[3]-this.m[1]*this.m[2]),b=this.m[3]*a,c=-this.m[1]*a,d=-this.m[2]*a,e=this.m[0]*a,f=a*(this.m[2]*this.m[5]-this.m[3]*this.m[4]),g=a*(this.m[1]*this.m[4]-this.m[0]*this.m[5]);this.m[0]=b,this.m[1]=c,this.m[2]=d,this.m[3]=e,this.m[4]=f,this.m[5]=g},b.prototype.rotate=function(a){var b=Math.cos(a),c=Math.sin(a),d=this.m[0]*b+this.m[2]*c,e=this.m[1]*b+this.m[3]*c,f=this.m[0]*-c+this.m[2]*b,g=this.m[1]*-c+this.m[3]*b;this.m[0]=d,this.m[1]=e,this.m[2]=f,this.m[3]=g},b.prototype.translate=function(a,b){this.m[4]+=this.m[0]*a+this.m[2]*b,this.m[5]+=this.m[1]*a+this.m[3]*b},b.prototype.scale=function(a,b){this.m[0]*=a,this.m[1]*=a,this.m[2]*=b,this.m[3]*=b},b.prototype.transformPoint=function(a,b){var c=a,d=b;return a=c*this.m[0]+d*this.m[2]+this.m[4],b=c*this.m[1]+d*this.m[3]+this.m[5],{x:a,y:b}},a.internal.Transform=b}(cornerstone),function(a){"use strict";function b(a,b){return function(c){return 255*((c-b)/a+.5)}}function c(a){var b=a.numBitsPerEntry-8,c=a.lut[0]>>b,d=a.lut[a.lut.length-1]>>b,e=a.firstValueMapped+a.lut.length-1;return function(f){return f<a.firstValueMapped?c:f>=e?d:a.lut[f-a.firstValueMapped]>>b}}function d(a,d,e){return e?c(e):b(a,d)}a.internal.getVOILUT=d}(cornerstone),function(a){"use strict";function b(b){var c=a.getEnabledElement(b);c.invalid=!0;var d={element:b};$(c.element).trigger("CornerstoneInvalidated",d)}a.invalidate=b}(cornerstone),function(a){"use strict";function b(b){var c=a.getEnabledElementsByImageId(b);c.forEach(function(b){a.drawImage(b,!0)})}a.invalidateImageId=b}(cornerstone),function(a){"use strict";function b(b,c,d){var e=a.getEnabledElement(b);if(void 0===e.image)throw"image has not been loaded yet";var f=(e.image,b.getBoundingClientRect()),g=c-f.left-window.pageXOffset,h=d-f.top-window.pageYOffset,i={x:g,y:h},j=a.internal.getTransform(e);return j.invert(),j.transformPoint(i.x,i.y)}a.pageToPixel=b}(cornerstone),function(a){"use strict";function b(b,c){var d=a.getEnabledElement(b),e=a.internal.getTransform(d);return e.transformPoint(c.x,c.y)}a.pixelToCanvas=b}(cornerstone),function(a){"use strict";function b(a){j.width=a.width,j.height=a.height,g=j.getContext("2d"),g.fillStyle="white",g.fillRect(0,0,j.width,j.height),h=g.getImageData(0,0,a.width,a.height)}function c(b,c){return void 0!==b.lut&&b.lut.windowCenter===c.voi.windowCenter&&b.lut.windowWidth===c.voi.windowWidth&&b.lut.invert===c.invert?b.lut:(a.generateLut(b,c.voi.windowWidth,c.voi.windowCenter,c.invert),b.lut.windowWidth=c.voi.windowWidth,b.lut.windowCenter=c.voi.windowCenter,b.lut.invert=c.invert,b.lut)}function d(a,b){return b.imageId!==i||k.windowCenter!==a.viewport.voi.windowCenter||k.windowWidth!==a.viewport.voi.windowWidth||k.invert!==a.viewport.invert||k.rotation!==a.viewport.rotation||k.hflip!==a.viewport.hflip||k.vflip!==a.viewport.vflip}function e(e,f,i){if(255===e.viewport.voi.windowWidth&&128===e.viewport.voi.windowCenter&&e.viewport.invert===!1&&f.getCanvas&&f.getCanvas())return f.getCanvas();if(d(e,f)===!1&&i!==!0)return j;j.width===f.width&&j.height==f.height||b(f);var k=c(f,e.viewport);return a.storedColorPixelDataToCanvasImageData(f,k,h.data),g.putImageData(h,0,0),j}function f(b,c){if(void 0===b)throw"drawImage: enabledElement parameter must not be undefined";var d=b.image;if(void 0===d)throw"drawImage: image must be loaded before it can be drawn";var f=b.canvas.getContext("2d");f.setTransform(1,0,0,1,0,0),f.fillStyle="black",f.fillRect(0,0,b.canvas.width,b.canvas.height),b.viewport.pixelReplication===!0?(f.imageSmoothingEnabled=!1,f.mozImageSmoothingEnabled=!1):(f.imageSmoothingEnabled=!0,f.mozImageSmoothingEnabled=!0),f.save(),a.setToPixelCoordinateSystem(b,f);var g=e(b,d,c);f.drawImage(g,0,0,d.width,d.height,0,0,d.width,d.height),f.restore(),i=d.imageId,k.windowCenter=b.viewport.voi.windowCenter,k.windowWidth=b.viewport.voi.windowWidth,k.invert=b.viewport.invert,k.rotation=b.viewport.rotation,k.hflip=b.viewport.hflip,k.vflip=b.viewport.vflip}var g,h,i,j=document.createElement("canvas"),k={};a.rendering.colorImage=f,a.renderColorImage=f}(cornerstone),function(a){"use strict";function b(a){k.width=a.width,k.height=a.height,h=k.getContext("2d"),h.fillStyle="white",h.fillRect(0,0,k.width,k.height),i=h.getImageData(0,0,a.width,a.height)}function c(a,b){return!a&&!b||!(!a||!b)&&a.id!==b.id}function d(b,d,e){return void 0!==b.lut&&b.lut.windowCenter===d.voi.windowCenter&&b.lut.windowWidth===d.voi.windowWidth&&c(b.lut.modalityLUT,d.modalityLUT)&&c(b.lut.voiLUT,d.voiLUT)&&b.lut.invert===d.invert&&e!==!0?b.lut:(a.generateLut(b,d.voi.windowWidth,d.voi.windowCenter,d.invert,d.modalityLUT,d.voiLUT),b.lut.windowWidth=d.voi.windowWidth,b.lut.windowCenter=d.voi.windowCenter,b.lut.invert=d.invert,b.lut.voiLUT=d.voiLUT,b.lut.modalityLUT=d.modalityLUT,b.lut)}function e(a,b){return b.imageId!==j||l.windowCenter!==a.viewport.voi.windowCenter||l.windowWidth!==a.viewport.voi.windowWidth||l.invert!==a.viewport.invert||l.rotation!==a.viewport.rotation||l.hflip!==a.viewport.hflip||l.vflip!==a.viewport.vflip||l.modalityLUT!==a.viewport.modalityLUT||l.voiLUT!==a.viewport.voiLUT||l.fakeColor!==a.viewport.fakeColor}function f(c,f,g){if(e(c,f)===!1&&g!==!0)return k;k.width===f.width&&k.height==f.height&&l.fakeColor==f.fakeColor||(b(f),k.fakeColor=f.fakeColor);var j=d(f,c.viewport,g);return"printBack"==c.viewport.fakeColor?(a.storedPixelDataToCanvasImageData(f,j,i.data,c.viewport.fakeColor),"false"==c.viewport.fakeColor):a.storedPixelDataToCanvasImageData(f,j,i.data,c.viewport.fakeColor),h.putImageData(i,0,0),k}function g(b,c){if(void 0===b)throw"drawImage: enabledElement parameter must not be undefined";var d=b.image;if(void 0===d)throw"drawImage: image must be loaded before it can be drawn";var e=b.canvas.getContext("2d");e.setTransform(1,0,0,1,0,0),e.fillStyle="black",e.fillRect(0,0,b.canvas.width,b.canvas.height),b.viewport.pixelReplication===!0?(e.imageSmoothingEnabled=!1,e.mozImageSmoothingEnabled=!1):(e.imageSmoothingEnabled=!0,e.mozImageSmoothingEnabled=!0),a.setToPixelCoordinateSystem(b,e);var g=f(b,d,c);e.drawImage(g,0,0,d.width,d.height,0,0,d.width,d.height),j=d.imageId,l.windowCenter=b.viewport.voi.windowCenter,l.windowWidth=b.viewport.voi.windowWidth,l.invert=b.viewport.invert,l.fakeColor=b.viewport.fakeColor,l.rotation=b.viewport.rotation,l.hflip=b.viewport.hflip,l.vflip=b.viewport.vflip,l.modalityLUT=b.viewport.modalityLUT,l.voiLUT=b.viewport.voiLUT}var h,i,j,k=document.createElement("canvas"),l={};a.rendering.grayscaleImage=g,a.renderGrayscaleImage=g,a.initializeGrayscaleRenderCanvas=b}(cornerstone),function(a){"use strict";function b(b,c){if(void 0===b)throw"drawImage: enabledElement parameter must not be undefined";var d=b.image;if(void 0===d)throw"drawImage: image must be loaded before it can be drawn";var e=b.canvas.getContext("2d");e.setTransform(1,0,0,1,0,0),e.fillStyle="black",e.fillRect(0,0,b.canvas.width,b.canvas.height),b.viewport.pixelReplication===!0?(e.imageSmoothingEnabled=!1,e.mozImageSmoothingEnabled=!1):(e.imageSmoothingEnabled=!0,e.mozImageSmoothingEnabled=!0),a.setToPixelCoordinateSystem(b,e),b.viewport.voi.windowWidth===b.image.windowWidth&&b.viewport.voi.windowCenter===b.image.windowCenter&&b.viewport.invert===!1?e.drawImage(d.getImage(),0,0,d.width,d.height,0,0,d.width,d.height):a.renderColorImage(b,c)}a.rendering.webImage=b,a.renderWebImage=b}(cornerstone),function(a){"use strict";function b(b){var c=a.getEnabledElement(b),d=a.internal.getDefaultViewport(c.canvas,c.image);c.viewport=d,a.updateImage(b)}a.reset=b}(cornerstone),function(a){"use strict";function b(a,b){b.width=a.clientWidth,b.height=a.clientHeight,b.style.width=a.clientWidth+"px",b.style.height=a.clientHeight+"px"}function c(c,d){var e=a.getEnabledElement(c);b(c,e.canvas),void 0!==e.image&&a.updateImage(c)}a.resize=c}(cornerstone),function(a){"use strict";function b(b,c,d){if(void 0===b)throw"setToPixelCoordinateSystem: parameter enabledElement must not be undefined";if(void 0===c)throw"setToPixelCoordinateSystem: parameter context must not be undefined";var e=a.internal.calculateTransform(b,d);c.setTransform(e.m[0],e.m[1],e.m[2],e.m[3],e.m[4],e.m[5],e.m[6])}a.setToPixelCoordinateSystem=b}(cornerstone),function(a){"use strict";function b(b,c){var d=a.getEnabledElement(b);d.viewport.scale=c.scale,d.viewport.translation.x=c.translation.x,d.viewport.translation.y=c.translation.y,d.viewport.voi.windowWidth=c.voi.windowWidth,d.viewport.voi.windowCenter=c.voi.windowCenter,d.viewport.invert=c.invert,d.viewport.fakeColor=c.fakeColor,d.viewport.pixelReplication=c.pixelReplication,d.viewport.rotation=c.rotation,d.viewport.hflip=c.hflip,d.viewport.vflip=c.vflip,d.viewport.modalityLUT=c.modalityLUT,d.viewport.voiLUT=c.voiLUT,d.viewport.voi.windowWidth<1e-6&&(d.viewport.voi.windowWidth=1e-6),d.viewport.scale<1e-4&&(d.viewport.scale=.25),360!==d.viewport.rotation&&d.viewport.rotation!==-360||(d.viewport.rotation=0),a.updateImage(b)}a.setViewport=b}(cornerstone),function(a){"use strict";function b(b,c){var d=a.getEnabledElement(b);if(void 0===d.image)throw"updateImage: image has not been loaded yet";a.drawImage(d,c)}a.updateImage=b}(cornerstone);
/*! cornerstoneMath - v0.1.3 - 2016-02-04 | (c) 2014 Chris Hafey | https://github.com/chafey/cornerstoneMath */
var cornerstoneMath=function(a){"use strict";return void 0===a&&(a={}),a.Vector3=function(a,b,c){this.x=a||0,this.y=b||0,this.z=c||0},a.Vector3.prototype={constructor:a.Vector3,set:function(a,b,c){return this.x=a,this.y=b,this.z=c,this},setX:function(a){return this.x=a,this},setY:function(a){return this.y=a,this},setZ:function(a){return this.z=a,this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw new Error("index is out of range: "+a)}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+a)}},copy:function(a){return this.x=a.x,this.y=a.y,this.z=a.z,this},add:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b)):(this.x+=a.x,this.y+=a.y,this.z+=a.z,this)},addScalar:function(a){return this.x+=a,this.y+=a,this.z+=a,this},addVectors:function(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this},sub:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b)):(this.x-=a.x,this.y-=a.y,this.z-=a.z,this)},subVectors:function(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this},multiply:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b)):(this.x*=a.x,this.y*=a.y,this.z*=a.z,this)},multiplyScalar:function(a){return this.x*=a,this.y*=a,this.z*=a,this},multiplyVectors:function(a,b){return this.x=a.x*b.x,this.y=a.y*b.y,this.z=a.z*b.z,this},applyAxisAngle:function(){var b;return function(c,d){return void 0===b&&(b=new a.Quaternion),this.applyQuaternion(b.setFromAxisAngle(c,d)),this}}(),applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[3]*c+e[6]*d,this.y=e[1]*b+e[4]*c+e[7]*d,this.z=e[2]*b+e[5]*c+e[8]*d,this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[4]*c+e[8]*d+e[12],this.y=e[1]*b+e[5]*c+e[9]*d+e[13],this.z=e[2]*b+e[6]*c+e[10]*d+e[14],this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements,f=1/(e[3]*b+e[7]*c+e[11]*d+e[15]);return this.x=(e[0]*b+e[4]*c+e[8]*d+e[12])*f,this.y=(e[1]*b+e[5]*c+e[9]*d+e[13])*f,this.z=(e[2]*b+e[6]*c+e[10]*d+e[14])*f,this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z,h=a.w,i=h*b+f*d-g*c,j=h*c+g*b-e*d,k=h*d+e*c-f*b,l=-e*b-f*c-g*d;return this.x=i*h+l*-e+j*-g-k*-f,this.y=j*h+l*-f+k*-e-i*-g,this.z=k*h+l*-g+i*-f-j*-e,this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[4]*c+e[8]*d,this.y=e[1]*b+e[5]*c+e[9]*d,this.z=e[2]*b+e[6]*c+e[10]*d,this.normalize(),this},divide:function(a){return this.x/=a.x,this.y/=a.y,this.z/=a.z,this},divideScalar:function(a){if(0!==a){var b=1/a;this.x*=b,this.y*=b,this.z*=b}else this.x=0,this.y=0,this.z=0;return this},min:function(a){return this.x>a.x&&(this.x=a.x),this.y>a.y&&(this.y=a.y),this.z>a.z&&(this.z=a.z),this},max:function(a){return this.x<a.x&&(this.x=a.x),this.y<a.y&&(this.y=a.y),this.z<a.z&&(this.z=a.z),this},clamp:function(a,b){return this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x),this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y),this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z),this},clampScalar:function(){var b,c;return function(d,e){return void 0===b&&(b=new a.Vector3,c=new a.Vector3),b.set(d,d,d),c.set(e,e,e),this.clamp(b,c)}}(),floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();return 0!==b&&a!==b&&this.multiplyScalar(a/b),this},lerp:function(a,b){return this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this.z+=(a.z-this.z)*b,this},cross:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;return this.x=d*a.z-e*a.y,this.y=e*a.x-c*a.z,this.z=c*a.y-d*a.x,this},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;return this.x=d*h-e*g,this.y=e*f-c*h,this.z=c*g-d*f,this},projectOnVector:function(){var b,c;return function(d){return void 0===b&&(b=new a.Vector3),b.copy(d).normalize(),c=this.dot(b),this.copy(b).multiplyScalar(c)}}(),projectOnPlane:function(){var b;return function(c){return void 0===b&&(b=new a.Vector3),b.copy(this).projectOnVector(c),this.sub(b)}}(),reflect:function(){var b;return function(c){return void 0===b&&(b=new a.Vector3),this.sub(b.copy(c).multiplyScalar(2*this.dot(c)))}}(),angleTo:function(b){var c=this.dot(b)/(this.length()*b.length());return Math.acos(a.clamp(c,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,d=this.z-a.z;return b*b+c*c+d*d},setEulerFromRotationMatrix:function(a,b){console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")},setEulerFromQuaternion:function(a,b){console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")},getPositionFromMatrix:function(a){return console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code."),this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){return console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code."),this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){return console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code."),this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){return this.x=a.elements[12],this.y=a.elements[13],this.z=a.elements[14],this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),d=this.set(a.elements[8],a.elements[9],a.elements[10]).length();return this.x=b,this.y=c,this.z=d,this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;return this.x=d[c],this.y=d[c+1],this.z=d[c+2],this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){return this.x=a[0],this.y=a[1],this.z=a[2],this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new a.Vector3(this.x,this.y,this.z)}},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";return void 0===a&&(a={}),a.Line3=function(b,c){this.start=void 0!==b?b:new a.Vector3,this.end=void 0!==c?c:new a.Vector3},a.Line3.prototype={constructor:a.Line3,set:function(a,b){return this.start.copy(a),this.end.copy(b),this},copy:function(a){return this.start.copy(a.start),this.end.copy(a.end),this},center:function(b){var c=b||new a.Vector3;return c.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(b){var c=b||new a.Vector3;return c.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(b,c){var d=c||new a.Vector3;return this.delta(d).multiplyScalar(b).add(this.start)},closestPointToPointParameter:function(){var b=new a.Vector3,c=new a.Vector3;return function(d,e){b.subVectors(d,this.start),c.subVectors(this.end,this.start);var f=c.dot(c),g=c.dot(b),h=g/f;return e&&(h=a.Math.clamp(h,0,1)),h}}(),closestPointToPoint:function(b,c,d){var e=this.closestPointToPointParameter(b,c),f=d||new a.Vector3;return this.delta(f).multiplyScalar(e).add(this.start)},applyMatrix4:function(a){return this.start.applyMatrix4(a),this.end.applyMatrix4(a),this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new a.Line3).copy(this)},intersectLine:function(a){var b=this.end.clone().sub(this.start),c=a.end.clone().sub(a.start),d=a.start.clone().sub(this.start),e=b.clone().cross(c),f=d.clone().cross(c);if(0!==d.dot(b)){var g=f.dot(e)/e.lengthSq();if(!(g>1||isNaN(g))){var h=this.start.clone().add(b.clone().multiplyScalar(g)),i=h.clone().sub(a.start).lengthSq()+h.clone().sub(a.end).lengthSq();return i<=a.distanceSq()?h:void 0}}}},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";function b(a){return a*a}function c(a,c){return b(a.x-c.x)+b(a.y-c.y)}function d(a,b){var d=c(a.start,a.end);if(0===d)return c(b,a.start);var e=((b.x-a.start.x)*(a.end.x-a.start.x)+(b.y-a.start.y)*(a.end.y-a.start.y))/d;if(0>e)return c(b,a.start);if(e>1)return c(b,a.end);var f={x:a.start.x+e*(a.end.x-a.start.x),y:a.start.y+e*(a.end.y-a.start.y)};return c(b,f)}function e(a,b){return Math.sqrt(d(a,b))}function f(b,c){var d,e,f,g,h,i,j,k,l,m,n,o,p={},q=b.start.x,r=b.start.y,s=b.end.x,t=b.end.y,u=c.start.x,v=c.start.y,w=c.end.x,x=c.end.y;if(d=t-r,f=q-s,h=s*r-q*t,l=d*u+f*v+h,m=d*w+f*x+h,(0===l||0===m||a.sign(l)!==a.sign(m))&&(e=x-v,g=u-w,i=w*v-u*x,j=e*q+g*r+i,k=e*s+g*t+i,0===j||0===k||a.sign(j)!==a.sign(k))){n=d*g-e*f,o=f*i-g*h;var y=parseFloat(o/n);o=e*h-d*i;var z=parseFloat(o/n);return p.x=y,p.y=z,p}}return void 0===a&&(a={}),a.lineSegment={distanceToPoint:e,intersectLine:f},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";function b(a,b,c){return b>a?b:a>c?c:a}function c(a){var b=Math.PI/180;return a*b}function d(a){var b=180/Math.PI;return a*b}function e(a){return"number"==typeof a?a?0>a?-1:1:a===a?0:NaN:NaN}return void 0===a&&(a={}),a.clamp=b,a.degToRad=c,a.radToDeg=d,a.sign=e,a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";return void 0===a&&(a={}),a.Matrix4=function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){this.elements=new Float32Array(16);var q=this.elements;q[0]=void 0!==a?a:1,q[4]=b||0,q[8]=c||0,q[12]=d||0,q[1]=e||0,q[5]=void 0!==f?f:1,q[9]=g||0,q[13]=h||0,q[2]=i||0,q[6]=j||0,q[10]=void 0!==k?k:1,q[14]=l||0,q[3]=m||0,q[7]=n||0,q[11]=o||0,q[15]=void 0!==p?p:1},a.Matrix4.prototype.makeRotationFromQuaternion=function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,i=e+e,j=c*g,k=c*h,l=c*i,m=d*h,n=d*i,o=e*i,p=f*g,q=f*h,r=f*i;return b[0]=1-(m+o),b[4]=k-r,b[8]=l+q,b[1]=k+r,b[5]=1-(j+o),b[9]=n-p,b[2]=l-q,b[6]=n+p,b[10]=1-(j+m),b[3]=0,b[7]=0,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,this},a.Matrix4.prototype.multiplyMatrices=function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],j=c[1],k=c[5],l=c[9],m=c[13],n=c[2],o=c[6],p=c[10],q=c[14],r=c[3],s=c[7],t=c[11],u=c[15],v=d[0],w=d[4],x=d[8],y=d[12],z=d[1],A=d[5],B=d[9],C=d[13],D=d[2],E=d[6],F=d[10],G=d[14],H=d[3],I=d[7],J=d[11],K=d[15];return e[0]=f*v+g*z+h*D+i*H,e[4]=f*w+g*A+h*E+i*I,e[8]=f*x+g*B+h*F+i*J,e[12]=f*y+g*C+h*G+i*K,e[1]=j*v+k*z+l*D+m*H,e[5]=j*w+k*A+l*E+m*I,e[9]=j*x+k*B+l*F+m*J,e[13]=j*y+k*C+l*G+m*K,e[2]=n*v+o*z+p*D+q*H,e[6]=n*w+o*A+p*E+q*I,e[10]=n*x+o*B+p*F+q*J,e[14]=n*y+o*C+p*G+q*K,e[3]=r*v+s*z+t*D+u*H,e[7]=r*w+s*A+t*E+u*I,e[11]=r*x+s*B+t*F+u*J,e[15]=r*y+s*C+t*G+u*K,this},a.Matrix4.prototype.multiply=function(a,b){return void 0!==b?(console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},a.Matrix4.prototype.getInverse=function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],i=d[1],j=d[5],k=d[9],l=d[13],m=d[2],n=d[6],o=d[10],p=d[14],q=d[3],r=d[7],s=d[11],t=d[15];c[0]=k*p*r-l*o*r+l*n*s-j*p*s-k*n*t+j*o*t,c[4]=h*o*r-g*p*r-h*n*s+f*p*s+g*n*t-f*o*t,c[8]=g*l*r-h*k*r+h*j*s-f*l*s-g*j*t+f*k*t,c[12]=h*k*n-g*l*n-h*j*o+f*l*o+g*j*p-f*k*p,c[1]=l*o*q-k*p*q-l*m*s+i*p*s+k*m*t-i*o*t,c[5]=g*p*q-h*o*q+h*m*s-e*p*s-g*m*t+e*o*t,c[9]=h*k*q-g*l*q-h*i*s+e*l*s+g*i*t-e*k*t,c[13]=g*l*m-h*k*m+h*i*o-e*l*o-g*i*p+e*k*p,c[2]=j*p*q-l*n*q+l*m*r-i*p*r-j*m*t+i*n*t,c[6]=h*n*q-f*p*q-h*m*r+e*p*r+f*m*t-e*n*t,c[10]=f*l*q-h*j*q+h*i*r-e*l*r-f*i*t+e*j*t,c[14]=h*j*m-f*l*m-h*i*n+e*l*n+f*i*p-e*j*p,c[3]=k*n*q-j*o*q-k*m*r+i*o*r+j*m*s-i*n*s,c[7]=f*o*q-g*n*q+g*m*r-e*o*r-f*m*s+e*n*s,c[11]=g*j*q-f*k*q-g*i*r+e*k*r+f*i*s-e*j*s,c[15]=f*k*m-g*j*m+g*i*n-e*k*n-f*i*o+e*j*o;var u=e*c[0]+i*c[4]+m*c[8]+q*c[12];if(0===u){var v="Matrix4.getInverse(): can't invert matrix, determinant is 0";if(b)throw new Error(v);return console.warn(v),this.identity(),this}return this.multiplyScalar(1/u),this},a.Matrix4.prototype.applyToVector3Array=function(){var b=new a.Vector3;return function(a,c,d){void 0===c&&(c=0),void 0===d&&(d=a.length);for(var e=0,f=c;d>e;e+=3,f+=3)b.x=a[f],b.y=a[f+1],b.z=a[f+2],b.applyMatrix4(this),a[f]=b.x,a[f+1]=b.y,a[f+2]=b.z;return a}},a.Matrix4.prototype.makeTranslation=function(a,b,c){return this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1),this},a.Matrix4.prototype.multiplyScalar=function(a){var b=this.elements;return b[0]*=a,b[4]*=a,b[8]*=a,b[12]*=a,b[1]*=a,b[5]*=a,b[9]*=a,b[13]*=a,b[2]*=a,b[6]*=a,b[10]*=a,b[14]*=a,b[3]*=a,b[7]*=a,b[11]*=a,b[15]*=a,this},a.Matrix4.prototype.set=function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){var q=this.elements;return q[0]=a,q[4]=b,q[8]=c,q[12]=d,q[1]=e,q[5]=f,q[9]=g,q[13]=h,q[2]=i,q[6]=j,q[10]=k,q[14]=l,q[3]=m,q[7]=n,q[11]=o,q[15]=p,this},a.Matrix4.prototype.makeScale=function(a,b,c){return this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1),this},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";return void 0===a&&(a={}),a.Plane=function(b,c){this.normal=void 0!==b?b:new a.Vector3(1,0,0),this.constant=void 0!==c?c:0},a.Plane.prototype={constructor:a.Plane,set:function(a,b){return this.normal.copy(a),this.constant=b,this},setComponents:function(a,b,c,d){return this.normal.set(a,b,c),this.constant=d,this},setFromNormalAndCoplanarPoint:function(a,b){return this.normal.copy(a),this.constant=-b.dot(this.normal),this},setFromCoplanarPoints:function(){var b=new a.Vector3,c=new a.Vector3;return function(a,d,e){var f=b.subVectors(e,d).cross(c.subVectors(a,d)).normalize();return this.setFromNormalAndCoplanarPoint(f,a),this}}(),copy:function(a){return this.normal.copy(a.normal),this.constant=a.constant,this},normalize:function(){var a=1/this.normal.length();return this.normal.multiplyScalar(a),this.constant*=a,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(b,c){var d=this.distanceToPoint(b),e=c||new a.Vector3;return e.copy(this.normal).multiplyScalar(d)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start),c=this.distanceToPoint(a.end);return 0>b&&c>0||0>c&&b>0},intersectLine:function(){var b=new a.Vector3;return function(c,d){var e=d||new a.Vector3,f=c.delta(b),g=this.normal.dot(f);if(0===g)return 0===this.distanceToPoint(c.start)?e.copy(c.start):void 0;var h=-(c.start.dot(this.normal)+this.constant)/g;return 0>h||h>1?void 0:e.copy(f).multiplyScalar(h).add(c.start)}}(),intersectPlane:function(b){var c=this.normal.clone().cross(b.normal),d=new a.Vector3,e={origin:d,direction:c};if(this.normal.clone().cross(b.normal).length<1e-10)return e.direction=new a.Vector3,e;var f=this.constant,g=b.constant,h=this.normal.clone().dot(b.normal),i=-(f-g*h)/(1-h*h),j=-(g-f*h)/(1-h*h);return e.origin=this.normal.clone().multiplyScalar(i).add(b.normal.clone().multiplyScalar(j)),e},coplanarPoint:function(b){var c=b||new a.Vector3;return c.copy(this.normal).multiplyScalar(-this.constant)},translate:function(a){return this.constant=this.constant-a.dot(this.normal),this},equals:function(a){return a.normal.equals(this.normal)&&a.constant==this.constant},clone:function(){return(new a.Plane).copy(this)}},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";function b(a){return{x:a.pageX,y:a.pageY}}function c(a,b){return{x:a.x-b.x,y:a.y-b.y}}function d(a){return{x:a.x,y:a.y}}function e(a,b){return Math.sqrt(f(a,b))}function f(a,b){var d=c(a,b);return d.x*d.x+d.y*d.y}function g(a,b){return a.x<b.left||a.x>b.left+b.width||a.y<b.top||a.y>b.top+b.height?!1:!0}function h(b,c){var d,e=[];b.forEach(function(b,f){var g=a.point.distance(b,c);e.push(g),d=0===f?g:Math.min(g,d)});var f=e.indexOf(d);return b[f]}return void 0===a&&(a={}),a.point={subtract:c,copy:d,pageToPoint:b,distance:e,distanceSquared:f,insideRect:g,findClosestPoint:h},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";return void 0===a&&(a={}),a.Quaternion=function(a,b,c,d){this.x=a||0,this.y=b||0,this.z=c||0,this.w=void 0!==d?d:1},a.Quaternion.prototype.setFromAxisAngle=function(a,b){var c=b/2,d=Math.sin(c);return this.x=a.x*d,this.y=a.y*d,this.z=a.z*d,this.w=Math.cos(c),this},a.Quaternion.prototype.multiplyQuaternions=function(a,b){var c=a.x,d=a.y,e=a.z,f=a.w,g=b.x,h=b.y,i=b.z,j=b.w;return this.x=c*j+f*g+d*i-e*h,this.y=d*j+f*h+e*g-c*i,this.z=e*j+f*i+c*h-d*g,this.w=f*j-c*g-d*h-e*i,this},a.Quaternion.prototype.setFromRotationMatrix=function(a){var b,c=a.elements,d=c[0],e=c[4],f=c[8],g=c[1],h=c[5],i=c[9],j=c[2],k=c[6],l=c[10],m=d+h+l;return m>0?(b=.5/Math.sqrt(m+1),this.w=.25/b,this.x=(k-i)*b,this.y=(f-j)*b,this.z=(g-e)*b):d>h&&d>l?(b=2*Math.sqrt(1+d-h-l),this.w=(k-i)/b,this.x=.25*b,this.y=(e+g)/b,this.z=(f+j)/b):h>l?(b=2*Math.sqrt(1+h-d-l),this.w=(f-j)/b,this.x=(e+g)/b,this.y=.25*b,this.z=(i+k)/b):(b=2*Math.sqrt(1+l-d-h),this.w=(g-e)/b,this.x=(f+j)/b,this.y=(i+k)/b,this.z=.25*b),this},a}(cornerstoneMath),cornerstoneMath=function(a){"use strict";function b(a){var b={start:{x:a.left,y:a.top},end:{x:a.left+a.width,y:a.top}},c={start:{x:a.left+a.width,y:a.top},end:{x:a.left+a.width,y:a.top+a.height}},d={start:{x:a.left+a.width,y:a.top+a.height},end:{x:a.left,y:a.top+a.height}},e={start:{x:a.left,y:a.top+a.height},end:{x:a.left,y:a.top}},f=[b,c,d,e];return f}function c(c,d){var e=655535,f=b(c);return f.forEach(function(b){var c=a.lineSegment.distanceToPoint(b,d);e>c&&(e=c)}),e}function d(a){var b={topLeft:{x:a.left,y:a.top},bottomRight:{x:a.left+a.width,y:a.top+a.height}};return b}function e(a,b){var c,e,f=d(a),g=d(b);return c=a.width>=0?b.width>=0?!(f.bottomRight.x<=g.topLeft.x||g.bottomRight.x<=f.topLeft.x):!(f.bottomRight.x<=g.bottomRight.x||g.topLeft.x<=f.topLeft.x):b.width>=0?!(f.topLeft.x<=g.topLeft.x||g.bottomRight.x<=f.bottomRight.x):!(f.topLeft.x<=g.bottomRight.x||g.topLeft.x<=f.bottomRight.x),e=a.height>=0?b.height>=0?!(f.bottomRight.y<=g.topLeft.y||g.bottomRight.y<=f.topLeft.y):!(f.bottomRight.y<=g.bottomRight.y||g.topLeft.y<=f.topLeft.y):b.height>=0?!(f.topLeft.y<=g.topLeft.y||g.bottomRight.y<=f.bottomRight.y):!(f.topLeft.y<=g.bottomRight.y||g.top<=f.bottomRight.y),c&&e}function f(a,b){var c={topLeft:{},bottomRight:{}};if(e(a,b)){var f=d(a),g=d(b);return a.width>=0?b.width>=0?(c.topLeft.x=Math.max(f.topLeft.x,g.topLeft.x),c.bottomRight.x=Math.min(f.bottomRight.x,g.bottomRight.x)):(c.topLeft.x=Math.max(f.topLeft.x,g.bottomRight.x),c.bottomRight.x=Math.min(f.bottomRight.x,g.topLeft.x)):b.width>=0?(c.topLeft.x=Math.min(f.topLeft.x,g.bottomRight.x),c.bottomRight.x=Math.max(f.bottomRight.x,g.topLeft.x)):(c.topLeft.x=Math.min(f.topLeft.x,g.topLeft.x),c.bottomRight.x=Math.max(f.bottomRight.x,g.bottomRight.x)),a.height>=0?b.height>=0?(c.topLeft.y=Math.max(f.topLeft.y,g.topLeft.y),c.bottomRight.y=Math.min(f.bottomRight.y,g.bottomRight.y)):(c.topLeft.y=Math.max(f.topLeft.y,g.bottomRight.y),c.bottomRight.y=Math.min(f.bottomRight.y,g.topLeft.y)):b.height>=0?(c.topLeft.y=Math.min(f.topLeft.y,g.bottomRight.y),c.bottomRight.y=Math.max(f.bottomRight.y,g.topLeft.y)):(c.topLeft.y=Math.min(f.topLeft.y,g.topLeft.y),c.bottomRight.y=Math.max(f.bottomRight.y,g.bottomRight.y)),c}}return void 0===a&&(a={}),a.rect={distanceToPoint:c,getIntersectionRect:f},a}(cornerstoneMath);
/*! cornerstoneTools - v0.7.8 - 2016-07-08 | (c) 2014 Chris Hafey | https://github.com/chafey/cornerstoneTools */
// Begin Source: src/header.js
if (typeof cornerstone === 'undefined') {
    cornerstone = {};
}

if (typeof cornerstoneTools === 'undefined') {
    cornerstoneTools = {
        referenceLines: {},
        orientation: {}
    };
}
 
// End Source; src/header.js

// Begin Source: src/inputSources/mouseWheelInput.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseWheel(e) {
        // !!!HACK/NOTE/WARNING!!!
        // for some reason I am getting mousewheel and DOMMouseScroll events on my
        // mac os x mavericks system when middle mouse button dragging.
        // I couldn't find any info about this so this might break other systems
        // webkit hack
        if (e.originalEvent.type === 'mousewheel' && e.originalEvent.wheelDeltaY === 0) {
            return;
        }
        // firefox hack
        if (e.originalEvent.type === 'DOMMouseScroll' && e.originalEvent.axis === 1) {
            return;
        }

        var element = e.currentTarget;
        var startingCoords = cornerstone.pageToPixel(element, e.pageX || e.originalEvent.pageX, e.pageY || e.originalEvent.pageY);

        e = window.event || e; // old IE support
        var wheelDelta = e.wheelDelta || -e.detail || -e.originalEvent.detail;
        var direction = Math.max(-1, Math.min(1, (wheelDelta)));

        var mouseWheelData = {
            element: element,
            viewport: cornerstone.getViewport(element),
            image: cornerstone.getEnabledElement(element).image,
            direction: direction,
            pageX: e.pageX || e.originalEvent.pageX,
            pageY: e.pageY || e.originalEvent.pageY,
            imageX: startingCoords.x,
            imageY: startingCoords.y
        };

        $(element).trigger('CornerstoneToolsMouseWheel', mouseWheelData);
    }

    var mouseWheelEvents = 'mousewheel DOMMouseScroll';

    function enable(element) {
        // Prevent handlers from being attached multiple times
        disable(element);
        
        $(element).on(mouseWheelEvents, mouseWheel);
    }

    function disable(element) {
        $(element).unbind(mouseWheelEvents, mouseWheel);
    }

    // module exports
    cornerstoneTools.mouseWheelInput = {
        enable: enable,
        disable: disable
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/inputSources/mouseWheelInput.js

// Begin Source: src/inputSources/mouseInput.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var isClickEvent;
    var preventClickTimeout;
    var clickDelay = 200;

    function preventClickHandler() {
        isClickEvent = false;
    }

    function activateMouseDown(mouseEventDetail) {
        $(mouseEventDetail.element).trigger('CornerstoneToolsMouseDownActivate', mouseEventDetail);
    }

    function mouseDoubleClick(e) {
        var element = e.currentTarget;
        var eventType = 'CornerstoneToolsMouseDoubleClick';

        var startPoints = {
            page: cornerstoneMath.point.pageToPoint(e),
            image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
            client: {
                x: e.clientX,
                y: e.clientY
            }
        };
        startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

        var lastPoints = cornerstoneTools.copyPoints(startPoints);
        var eventData = {
            event: e,
            which: e.which,
            viewport: cornerstone.getViewport(element),
            image: cornerstone.getEnabledElement(element).image,
            element: element,
            startPoints: startPoints,
            lastPoints: lastPoints,
            currentPoints: startPoints,
            deltaPoints: {
                x: 0,
                y: 0
            },
            type: eventType
        };

        var event = $.Event(eventType, eventData);
        $(eventData.element).trigger(event, eventData);
    }

    function mouseDown(e) {

        preventClickTimeout = setTimeout(preventClickHandler, clickDelay);

        var element = e.currentTarget;
        var eventType = 'CornerstoneToolsMouseDown';

        // Prevent CornerstoneToolsMouseMove while mouse is down
        $(element).off('mousemove', mouseMove);

        var startPoints = {
            page: cornerstoneMath.point.pageToPoint(e),
            image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
            client: {
                x: e.clientX,
                y: e.clientY
            }
        };
        startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

        var lastPoints = cornerstoneTools.copyPoints(startPoints);
        var eventData = {
            event: e,
            which: e.which,
            viewport: cornerstone.getViewport(element),
            image: cornerstone.getEnabledElement(element).image,
            element: element,
            startPoints: startPoints,
            lastPoints: lastPoints,
            currentPoints: startPoints,
            deltaPoints: {
                x: 0,
                y: 0
            },
            type: eventType
        };

        var event = $.Event(eventType, eventData);
        $(eventData.element).trigger(event, eventData);

        if (event.isImmediatePropagationStopped() === false) {
            // no tools responded to this event, give the active tool a chance
            if (activateMouseDown(eventData) === true) {
                return cornerstoneTools.pauseEvent(e);
            }
        }

        var whichMouseButton = e.which;

        function onMouseMove(e) {
            // calculate our current points in page and image coordinates
            var eventType = 'CornerstoneToolsMouseDrag';
            var currentPoints = {
                page: cornerstoneMath.point.pageToPoint(e),
                image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
                client: {
                    x: e.clientX,
                    y: e.clientY
                }
            };
            currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

            // Calculate delta values in page and image coordinates
            var deltaPoints = {
                page: cornerstoneMath.point.subtract(currentPoints.page, lastPoints.page),
                image: cornerstoneMath.point.subtract(currentPoints.image, lastPoints.image),
                client: cornerstoneMath.point.subtract(currentPoints.client, lastPoints.client),
                canvas: cornerstoneMath.point.subtract(currentPoints.canvas, lastPoints.canvas)
            };

            var eventData = {
                which: whichMouseButton,
                viewport: cornerstone.getViewport(element),
                image: cornerstone.getEnabledElement(element).image,
                element: element,
                startPoints: startPoints,
                lastPoints: lastPoints,
                currentPoints: currentPoints,
                deltaPoints: deltaPoints,
                type: eventType
            };

            $(eventData.element).trigger(eventType, eventData);

            // update the last points
            lastPoints = cornerstoneTools.copyPoints(currentPoints);

            // prevent left click selection of DOM elements
            return cornerstoneTools.pauseEvent(e);
        }

        // hook mouseup so we can unbind our event listeners
        // when they stop dragging
        function onMouseUp(e) {
            // Cancel the timeout preventing the click event from triggering
            clearTimeout(preventClickTimeout);

            var eventType = 'CornerstoneToolsMouseUp';
            if (isClickEvent) {
                eventType = 'CornerstoneToolsMouseClick';
            }

            // calculate our current points in page and image coordinates
            var currentPoints = {
                page: cornerstoneMath.point.pageToPoint(e),
                image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
                client: {
                    x: e.clientX,
                    y: e.clientY
                }
            };
            currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

            // Calculate delta values in page and image coordinates
            var deltaPoints = {
                page: cornerstoneMath.point.subtract(currentPoints.page, lastPoints.page),
                image: cornerstoneMath.point.subtract(currentPoints.image, lastPoints.image),
                client: cornerstoneMath.point.subtract(currentPoints.client, lastPoints.client),
                canvas: cornerstoneMath.point.subtract(currentPoints.canvas, lastPoints.canvas)
            };

            var eventData = {
                event: e,
                which: whichMouseButton,
                viewport: cornerstone.getViewport(element),
                image: cornerstone.getEnabledElement(element).image,
                element: element,
                startPoints: startPoints,
                lastPoints: lastPoints,
                currentPoints: currentPoints,
                deltaPoints: deltaPoints,
                type: eventType
            };

            var event = $.Event(eventType, eventData);
            $(eventData.element).trigger(event, eventData);

            $(document).off('mousemove', onMouseMove);
            $(document).off('mouseup', onMouseUp);

            $(eventData.element).on('mousemove', mouseMove);

            isClickEvent = true;
        }

        $(document).on('mousemove', onMouseMove);
        $(document).on('mouseup', onMouseUp);

        return cornerstoneTools.pauseEvent(e);
    }

    function mouseMove(e) {
        var element = e.currentTarget;
        var eventType = 'CornerstoneToolsMouseMove';

        var startPoints = {
            page: cornerstoneMath.point.pageToPoint(e),
            image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
            client: {
                x: e.clientX,
                y: e.clientY
            }
        };
        startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

        var lastPoints = cornerstoneTools.copyPoints(startPoints);

        var whichMouseButton = e.which;

        // calculate our current points in page and image coordinates
        var currentPoints = {
            page: cornerstoneMath.point.pageToPoint(e),
            image: cornerstone.pageToPixel(element, e.pageX, e.pageY),
            client: {
                x: e.clientX,
                y: e.clientY
            }
        };
        currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

        // Calculate delta values in page and image coordinates
        var deltaPoints = {
            page: cornerstoneMath.point.subtract(currentPoints.page, lastPoints.page),
            image: cornerstoneMath.point.subtract(currentPoints.image, lastPoints.image),
            client: cornerstoneMath.point.subtract(currentPoints.client, lastPoints.client),
            canvas: cornerstoneMath.point.subtract(currentPoints.canvas, lastPoints.canvas)
        };

        var eventData = {
            which: whichMouseButton,
            viewport: cornerstone.getViewport(element),
            image: cornerstone.getEnabledElement(element).image,
            element: element,
            startPoints: startPoints,
            lastPoints: lastPoints,
            currentPoints: currentPoints,
            deltaPoints: deltaPoints,
            type: eventType
        };
        $(element).trigger(eventType, eventData);

        // update the last points
        lastPoints = cornerstoneTools.copyPoints(currentPoints);
    }

    function disable(element) {
        $(element).off('mousedown', mouseDown);
        $(element).off('mousemove', mouseMove);
        $(element).off('dblclick', mouseDoubleClick);
    }

    function enable(element) {
        // Prevent handlers from being attached multiple times
        disable(element);
        
        $(element).on('mousedown', mouseDown);
        $(element).on('mousemove', mouseMove);
        $(element).on('dblclick', mouseDoubleClick);
    }

    // module exports
    cornerstoneTools.mouseInput = {
        enable: enable,
        disable: disable
    };

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/inputSources/mouseInput.js

// Begin Source: src/inputSources/touchInput.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    /*jshint newcap: false */

    var lastScale = 1.0,
        lastRotation = 0.0,
        startPoints,
        currentPoints,
        lastPoints,
        deltaPoints,
        eventData,
        touchStartDelay,
        pressDelay = 700,
        pressTimeout,
        isPress = false,
        pressMaxDistance = 5,
        pageDistanceMoved,
        preventNextPinch = false;
    
    function onTouch(e) {
        ///console.log(e.type);
        var element = e.target.parentNode,
            event,
            eventType;

        // Prevent mouse events from occurring alongside touch events
        e.preventDefault();

        // If more than one finger is placed on the element, stop the press timeout
        if ((e.pointers && e.pointers.length > 1) ||
            (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 1)) {
            isPress = false;
            clearTimeout(pressTimeout);
        }

        switch (e.type) {
            case 'tap':
                isPress = false;
                clearTimeout(pressTimeout);

                // calculate our current points in page and image coordinates
                currentPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.pointers[0]),
                    image: cornerstone.pageToPixel(element, e.pointers[0].pageX, e.pointers[0].pageY),
                    client: {
                        x: e.pointers[0].clientX,
                        y: e.pointers[0].clientY
                    }
                };
                currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

                eventType = 'CornerstoneToolsTap';
                eventData = {
                    event: e,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    currentPoints: currentPoints,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);
                break;

            case 'doubletap':
                isPress = false;
                clearTimeout(pressTimeout);

                // calculate our current points in page and image coordinates
                currentPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.pointers[0]),
                    image: cornerstone.pageToPixel(element, e.pointers[0].pageX, e.pointers[0].pageY),
                    client: {
                        x: e.pointers[0].clientX,
                        y: e.pointers[0].clientY
                    }
                };
                currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

                eventType = 'CornerstoneToolsDoubleTap';
                eventData = {
                    event: e,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    currentPoints: currentPoints,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);
                break;

            case 'pinchstart':
                isPress = false;
                clearTimeout(pressTimeout);
                
                lastScale = 1.0;
                break;

            case 'pinchmove':
                isPress = false;
                clearTimeout(pressTimeout);

                if (preventNextPinch === true) {
                    lastScale = e.scale;
                    preventNextPinch = false;
                    break;
                }

                var scaleChange = (e.scale - lastScale) / lastScale;

                startPoints = {
                    page: e.center,
                    image: cornerstone.pageToPixel(element, e.center.x, e.center.y),
                };
                startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

                eventType = 'CornerstoneToolsTouchPinch';
                eventData = {
                    event: e,
                    startPoints: startPoints,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    direction: e.scale < 1 ? 1 : -1,
                    scaleChange: scaleChange,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);

                lastScale = e.scale;
                break;

            case 'touchstart':
                lastScale = 1.0;

                clearTimeout(pressTimeout);

                clearTimeout(touchStartDelay);
                touchStartDelay = setTimeout(function() {
                    startPoints = {
                        page: cornerstoneMath.point.pageToPoint(e.originalEvent.touches[0]),
                        image: cornerstone.pageToPixel(element, e.originalEvent.touches[0].pageX, e.originalEvent.touches[0].pageY),
                        client: {
                            x: e.originalEvent.touches[0].clientX,
                            y: e.originalEvent.touches[0].clientY
                        }
                    };
                    startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

                    eventType = 'CornerstoneToolsTouchStart';
                    if (e.originalEvent.touches.length > 1) {
                        eventType = 'CornerstoneToolsMultiTouchStart';
                    }

                    eventData = {
                        event: e,
                        viewport: cornerstone.getViewport(element),
                        image: cornerstone.getEnabledElement(element).image,
                        element: element,
                        startPoints: startPoints,
                        currentPoints: startPoints,
                        type: eventType,
                        isTouchEvent: true
                    };

                    event = $.Event(eventType, eventData);
                    $(element).trigger(event, eventData);

                    if (event.isImmediatePropagationStopped() === false) {
                        //isPress = false;
                        //clearTimeout(pressTimeout);

                        // No current tools responded to the drag action.
                        // Create new tool measurement
                        eventType = 'CornerstoneToolsTouchStartActive';
                        if (e.originalEvent.touches.length > 1) {
                            eventType = 'CornerstoneToolsMultiTouchStartActive';
                        }

                        eventData.type = eventType;
                        $(element).trigger(eventType, eventData);
                    }

                    //console.log(eventType);
                    lastPoints = cornerstoneTools.copyPoints(startPoints);
                }, 50);

                isPress = true;
                pageDistanceMoved = 0;
                pressTimeout = setTimeout(function() {
                    if (!isPress) {
                        return;
                    }

                    currentPoints = {
                        page: cornerstoneMath.point.pageToPoint(e.originalEvent.touches[0]),
                        image: cornerstone.pageToPixel(element, e.originalEvent.touches[0].pageX, e.originalEvent.touches[0].pageY),
                        client: {
                            x: e.originalEvent.touches[0].clientX,
                            y: e.originalEvent.touches[0].clientY
                        }
                    };
                    currentPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

                    eventType = 'CornerstoneToolsTouchPress';
                    eventData = {
                        event: e,
                        viewport: cornerstone.getViewport(element),
                        image: cornerstone.getEnabledElement(element).image,
                        element: element,
                        currentPoints: currentPoints,
                        type: eventType,
                        isTouchEvent: true
                    };

                    event = $.Event(eventType, eventData);
                    $(element).trigger(event, eventData);

                    //console.log(eventType);
                }, pressDelay);
                break;

            case 'touchend':
                lastScale = 1.0;

                isPress = false;
                clearTimeout(pressTimeout);

                startPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.originalEvent.changedTouches[0]),
                    image: cornerstone.pageToPixel(element, e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY),
                    client: {
                        x: e.originalEvent.changedTouches[0].clientX,
                        y: e.originalEvent.changedTouches[0].clientY
                    }
                };
                startPoints.canvas = cornerstone.pixelToCanvas(element, startPoints.image);

                eventType = 'CornerstoneToolsTouchEnd';

                eventData = {
                    event: e,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    startPoints: startPoints,
                    currentPoints: startPoints,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);
                break;

            case 'panmove':
                // calculate our current points in page and image coordinates
                currentPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.pointers[0]),
                    image: cornerstone.pageToPixel(element, e.pointers[0].pageX, e.pointers[0].pageY),
                    client: {
                        x: e.pointers[0].clientX,
                        y: e.pointers[0].clientY
                    }
                };
                currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

                // Calculate delta values in page and image coordinates
                deltaPoints = {
                    page: cornerstoneMath.point.subtract(currentPoints.page, lastPoints.page),
                    image: cornerstoneMath.point.subtract(currentPoints.image, lastPoints.image),
                    client: cornerstoneMath.point.subtract(currentPoints.client, lastPoints.client),
                    canvas: cornerstoneMath.point.subtract(currentPoints.canvas, lastPoints.canvas)
                };

                pageDistanceMoved += Math.sqrt(deltaPoints.page.x * deltaPoints.page.x + deltaPoints.page.y * deltaPoints.page.y);
                //console.log("pageDistanceMoved: " + pageDistanceMoved);
                if (pageDistanceMoved > pressMaxDistance) {
                    //console.log('Press event aborted due to movement');
                    isPress = false;
                    clearTimeout(pressTimeout);
                }
              
                eventType = 'CornerstoneToolsTouchDrag';
                if (e.pointers.length > 1) {
                    eventType = 'CornerstoneToolsMultiTouchDrag';
                }

                eventData = {
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    startPoints: startPoints,
                    lastPoints: lastPoints,
                    currentPoints: currentPoints,
                    deltaPoints: deltaPoints,
                    numPointers: e.pointers.length,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);

                lastPoints = cornerstoneTools.copyPoints(currentPoints);
                break;

            case 'panstart':
                currentPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.pointers[0]),
                    image: cornerstone.pageToPixel(element, e.pointers[0].pageX, e.pointers[0].pageY),
                    client: {
                        x: e.pointers[0].clientX,
                        y: e.pointers[0].clientY
                    }
                };
                currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);
                lastPoints = cornerstoneTools.copyPoints(currentPoints);
                break;

            case 'panend':
                isPress = false;
                clearTimeout(pressTimeout);

                // If lastPoints is not yet set, it means panend fired without panstart or pan,
                // so we can ignore this event
                if (!lastPoints) {
                    return false;
                }

                currentPoints = {
                    page: cornerstoneMath.point.pageToPoint(e.pointers[0]),
                    image: cornerstone.pageToPixel(element, e.pointers[0].pageX, e.pointers[0].pageY),
                    client: {
                        x: e.pointers[0].clientX,
                        y: e.pointers[0].clientY
                    }
                };
                currentPoints.canvas = cornerstone.pixelToCanvas(element, currentPoints.image);

                // Calculate delta values in page and image coordinates
                deltaPoints = {
                    page: cornerstoneMath.point.subtract(currentPoints.page, lastPoints.page),
                    image: cornerstoneMath.point.subtract(currentPoints.image, lastPoints.image),
                    client: cornerstoneMath.point.subtract(currentPoints.client, lastPoints.client),
                    canvas: cornerstoneMath.point.subtract(currentPoints.canvas, lastPoints.canvas)
                };

                eventType = 'CornerstoneToolsDragEnd';

                eventData = {
                    event: e.srcEvent,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    startPoints: startPoints,
                    lastPoints: lastPoints,
                    currentPoints: currentPoints,
                    deltaPoints: deltaPoints,
                    type: eventType,
                    isTouchEvent: true
                };

                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);

                var remainingPointers = e.pointers.length - e.changedPointers.length;
                if (remainingPointers === 2) {
                    preventNextPinch = true;
                }

                return cornerstoneTools.pauseEvent(e);

            case 'rotatemove':
                isPress = false;
                clearTimeout(pressTimeout);

                var rotation = e.rotation - lastRotation;
                lastRotation = e.rotation;

                eventType = 'CornerstoneToolsTouchRotate';
                eventData = {
                    event: e.srcEvent,
                    viewport: cornerstone.getViewport(element),
                    image: cornerstone.getEnabledElement(element).image,
                    element: element,
                    rotation: rotation,
                    type: eventType
                };
                event = $.Event(eventType, eventData);
                $(element).trigger(event, eventData);
                break;
        }

        //console.log(eventType);
        return false;
    }

    function enable(element) {
        disable(element);

        var hammerOptions = {
            inputClass: Hammer.SUPPORT_POINTER_EVENTS ? Hammer.PointerEventInput : Hammer.TouchInput
        };

        var mc = new Hammer.Manager(element, hammerOptions);

        var panOptions = {
            pointers: 0,
            direction: Hammer.DIRECTION_ALL,
            threshold: 0
        };

        var pan = new Hammer.Pan(panOptions);
        var pinch = new Hammer.Pinch({
            threshold: 0
        });
        var rotate = new Hammer.Rotate({
            threshold: 0
        });
        
        // we want to detect both the same time
        pinch.recognizeWith(pan);
        pinch.recognizeWith(rotate);

        // add to the Manager
        mc.add([ pan, rotate, pinch ]);
        mc.on('tap doubletap panstart panmove panend pinchstart pinchmove rotatemove', onTouch);

        cornerstoneTools.preventGhostClick.enable(element);
        $(element).on('touchstart touchend', onTouch);
        $(element).data('hammer', mc);
        //console.log('touchInput enabled');
    }

    function disable(element) {
        cornerstoneTools.preventGhostClick.disable(element);
        $(element).off('touchstart touchend', onTouch);
        var mc = $(element).data('hammer');
        if (mc) {
            mc.off('tap doubletap panstart panmove panend pinchmove rotatemove', onTouch);
        }

        //console.log('touchInput disabled');
    }

    // module exports
    cornerstoneTools.touchInput = {
        enable: enable,
        disable: disable
    };

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/inputSources/touchInput.js

// Begin Source: src/imageTools/simpleMouseButtonTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function simpleMouseButtonTool(mouseDownCallback) {
        var configuration = {};

        var toolInterface = {
            activate: function(element, mouseButtonMask, options) {
                $(element).off('CornerstoneToolsMouseDownActivate', mouseDownCallback);
                var eventData = {
                    mouseButtonMask: mouseButtonMask,
                    options: options
                };
                $(element).on('CornerstoneToolsMouseDownActivate', eventData, mouseDownCallback);
            },
            disable: function(element) {$(element).off('CornerstoneToolsMouseDownActivate', mouseDownCallback);},
            enable: function(element) {$(element).off('CornerstoneToolsMouseDownActivate', mouseDownCallback);},
            deactivate: function(element) {$(element).off('CornerstoneToolsMouseDownActivate', mouseDownCallback);},
            getConfiguration: function() { return configuration;},
            setConfiguration: function(config) {configuration = config;}
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.simpleMouseButtonTool = simpleMouseButtonTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/simpleMouseButtonTool.js

// Begin Source: src/imageTools/mouseButtonTool.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function mouseButtonTool(mouseToolInterface) {
        var configuration = {};

        ///////// BEGIN ACTIVE TOOL ///////
        function addNewMeasurement(mouseEventData) {
            var element = mouseEventData.element;

            var measurementData = mouseToolInterface.createNewMeasurement(mouseEventData);
            if (!measurementData) {
                return;
            }

            var eventData = {
                mouseButtonMask: mouseEventData.which
            };

            // associate this data with this imageId so we can render it and manipulate it
            cornerstoneTools.addToolState(mouseEventData.element, mouseToolInterface.toolType, measurementData);

            // since we are dragging to another place to drop the end point, we can just activate
            // the end point and let the moveHandle move it for us.
            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);

            if (mouseToolInterface.mouseDoubleClickCallback) {
                $(element).off('CornerstoneToolsMouseDoubleClick', mouseToolInterface.mouseDoubleClickCallback);
            }

            cornerstone.updateImage(element);

            var handleMover;
            if (Object.keys(measurementData.handles).length === 1) {
                handleMover = cornerstoneTools.moveHandle;
            } else {
                handleMover = cornerstoneTools.moveNewHandle;
            }

            var preventHandleOutsideImage;
            if (mouseToolInterface.options && mouseToolInterface.options.preventHandleOutsideImage !== undefined) {
                preventHandleOutsideImage = mouseToolInterface.options.preventHandleOutsideImage;
            } else {
                preventHandleOutsideImage = false;
            }

            handleMover(mouseEventData, mouseToolInterface.toolType, measurementData, measurementData.handles.end, function() {
                measurementData.active = false;
                measurementData.invalidated = true;
                if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, mouseToolInterface.toolType, measurementData);
                }

                $(element).on('CornerstoneToolsMouseMove', eventData, mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
                $(element).on('CornerstoneToolsMouseDown', eventData, mouseToolInterface.mouseDownCallback || mouseDownCallback);
                $(element).on('CornerstoneToolsMouseDownActivate', eventData, mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);

                if (mouseToolInterface.mouseDoubleClickCallback) {
                    $(element).on('CornerstoneToolsMouseDoubleClick', eventData, mouseToolInterface.mouseDoubleClickCallback);
                }

                cornerstone.updateImage(element);
            }, preventHandleOutsideImage);
        }

        function mouseDownActivateCallback(e, eventData) {
            if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
                if (mouseToolInterface.addNewMeasurement) {
                    mouseToolInterface.addNewMeasurement(eventData);
                } else {
                    addNewMeasurement(eventData);
                }

                return false; // false = causes jquery to preventDefault() and stopPropagation() this event
            }
        }

        ///////// END ACTIVE TOOL ///////

        ///////// BEGIN DEACTIVE TOOL ///////

        function mouseMoveCallback(e, eventData) {
            cornerstoneTools.toolCoordinates.setCoords(eventData);
            // if a mouse button is down, do nothing
            if (eventData.which !== 0) {
                return;
            }
          
            // if we have no tool data for this element, do nothing
            var toolData = cornerstoneTools.getToolState(eventData.element, mouseToolInterface.toolType);
            if (!toolData) {
                return;
            }
            
            // We have tool data, search through all data
            // and see if we can activate a handle
            var imageNeedsUpdate = false;
            for (var i = 0; i < toolData.data.length; i++) {
                // get the cursor position in canvas coordinates
                var coords = eventData.currentPoints.canvas;

                var data = toolData.data[i];
                if (cornerstoneTools.handleActivator(eventData.element, data.handles, coords) === true) {
                    imageNeedsUpdate = true;
                }

                if ((mouseToolInterface.pointNearTool(eventData.element, data, coords) && !data.active) || (!mouseToolInterface.pointNearTool(eventData.element, data, coords) && data.active)) {
                    data.active = !data.active;
                    imageNeedsUpdate = true;
                }
            }

            // Handle activation status changed, redraw the image
            if (imageNeedsUpdate === true) {
                cornerstone.updateImage(eventData.element);
            }
        }

        function mouseDownCallback(e, eventData) {
            var data;
            var element = eventData.element;

            function handleDoneMove() {
                data.active = false;
                data.invalidated = true;
                if (cornerstoneTools.anyHandlesOutsideImage(eventData, data.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, mouseToolInterface.toolType, data);
                }

                cornerstone.updateImage(element);
                $(element).on('CornerstoneToolsMouseMove', eventData, mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            }

            if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
                var coords = eventData.startPoints.canvas;
                var toolData = cornerstoneTools.getToolState(e.currentTarget, mouseToolInterface.toolType);

                var i;

                // now check to see if there is a handle we can move
                if (toolData) {

                    var preventHandleOutsideImage;
                    if (mouseToolInterface.options && mouseToolInterface.options.preventHandleOutsideImage !== undefined) {
                        preventHandleOutsideImage = mouseToolInterface.options.preventHandleOutsideImage;
                    } else {
                        preventHandleOutsideImage = false;
                    }

                    for (i = 0; i < toolData.data.length; i++) {
                        data = toolData.data[i];
                        var distanceSq = cornerstoneTools.distanceSqR||25;//zyy add cornerstoneTools.distanceSqR
                        var handle = cornerstoneTools.getHandleNearImagePoint(element, data.handles, coords, distanceSq);
                        if (handle) {
                            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
                            data.active = true;
                            cornerstoneTools.moveHandle(eventData, mouseToolInterface.toolType, data, handle, handleDoneMove, preventHandleOutsideImage);
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }

                // Now check to see if there is a line we can move
                // now check to see if we have a tool that we can move
                if (toolData && mouseToolInterface.pointNearTool) {
                    var options = mouseToolInterface.options || {
                        deleteIfHandleOutsideImage: true,
                        preventHandleOutsideImage: false
                    };

                    for (i = 0; i < toolData.data.length; i++) {
                        data = toolData.data[i];
                        if (mouseToolInterface.pointNearTool(element, data, coords)) {
                            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
                            cornerstoneTools.moveAllHandles(e, data, toolData, mouseToolInterface.toolType, options, handleDoneMove);
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }
            }
        }
        ///////// END DEACTIVE TOOL ///////

        // not visible, not interactive
        function disable(element) {
            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);
            //zyy add
            if(mouseToolInterface.mouseUpCallback ){
                $(element).off('CornerstoneToolsMouseUp', mouseToolInterface.mouseUpCallback );
            }
            if(mouseToolInterface.mouseClickCallback ){
                $(element).off('CornerstoneToolsMouseClick', mouseToolInterface.mouseClickCallback );
            }
            //zyy add end
            if (mouseToolInterface.mouseDoubleClickCallback) {
                $(element).off('CornerstoneToolsMouseDoubleClick', mouseToolInterface.mouseDoubleClickCallback);
            }

            cornerstone.updateImage(element);
        }

        // visible but not interactive
        function enable(element) {
            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);
            //zyy add
            if(mouseToolInterface.mouseUpCallback ){
                $(element).off('CornerstoneToolsMouseUp', mouseToolInterface.mouseUpCallback );
            }
            if(mouseToolInterface.mouseClickCallback ){
                $(element).off('CornerstoneToolsMouseClick', mouseToolInterface.mouseClickCallback );
            }
            //zyy add end

            if (mouseToolInterface.mouseDoubleClickCallback) {
                $(element).off('CornerstoneToolsMouseDoubleClick', mouseToolInterface.mouseDoubleClickCallback);
            }

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);

            cornerstone.updateImage(element);
        }

        // visible, interactive and can create
        function activate(element, mouseButtonMask) {
            var eventData = {
                mouseButtonMask: mouseButtonMask
            };

            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).on('CornerstoneToolsMouseMove', eventData, mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData, mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).on('CornerstoneToolsMouseDownActivate', eventData, mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);
//zyy add
            if(mouseToolInterface.mouseUpCallback ){
                $(element).off('CornerstoneToolsMouseUp', mouseToolInterface.mouseUpCallback );
                $(element).on('CornerstoneToolsMouseUp',eventData, mouseToolInterface.mouseUpCallback );
            }
            if(mouseToolInterface.mouseClickCallback ){
                $(element).off('CornerstoneToolsMouseClick', mouseToolInterface.mouseClickCallback );
                $(element).on('CornerstoneToolsMouseClick',eventData, mouseToolInterface.mouseClickCallback );
            }
//zyy add end
            if (mouseToolInterface.mouseDoubleClickCallback) {
                $(element).off('CornerstoneToolsMouseDoubleClick', mouseToolInterface.mouseDoubleClickCallback);
                $(element).on('CornerstoneToolsMouseDoubleClick', eventData, mouseToolInterface.mouseDoubleClickCallback);
            }

            cornerstone.updateImage(element);
        }

        // visible, interactive
        function deactivate(element, mouseButtonMask) {
            var eventData = {
                mouseButtonMask: mouseButtonMask
            };

            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseToolInterface.mouseDownCallback || mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseToolInterface.mouseDownActivateCallback || mouseDownActivateCallback);

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).on('CornerstoneToolsMouseMove', eventData, mouseToolInterface.mouseMoveCallback || mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData, mouseToolInterface.mouseDownCallback || mouseDownCallback);
            //zyy add
            if(mouseToolInterface.mouseUpCallback ){
                $(element).off('CornerstoneToolsMouseUp', mouseToolInterface.mouseUpCallback );
                $(element).on('CornerstoneToolsMouseUp',eventData, mouseToolInterface.mouseUpCallback );
            }
            if(mouseToolInterface.mouseClickCallback ){
                $(element).off('CornerstoneToolsMouseClick', mouseToolInterface.mouseClickCallback );
                $(element).on('CornerstoneToolsMouseClick',eventData, mouseToolInterface.mouseClickCallback );
            }
            //zyy add end
            if (mouseToolInterface.mouseDoubleClickCallback) {
                $(element).off('CornerstoneToolsMouseDoubleClick', mouseToolInterface.mouseDoubleClickCallback);
                $(element).on('CornerstoneToolsMouseDoubleClick', eventData, mouseToolInterface.mouseDoubleClickCallback);
            }

            cornerstone.updateImage(element);
        }

        function getConfiguration() {
            return configuration;
        }

        function setConfiguration(config) {
            configuration = config;
        }

        var toolInterface = {
            enable: enable,
            disable: disable,
            activate: activate,
            deactivate: deactivate,
            getConfiguration: getConfiguration,
            setConfiguration: setConfiguration,
            mouseDownCallback: mouseDownCallback,
            mouseMoveCallback: mouseMoveCallback,
            mouseDownActivateCallback: mouseDownActivateCallback
        };

        // Expose pointNearTool if available
        if (mouseToolInterface.pointNearTool) {
            toolInterface.pointNearTool = mouseToolInterface.pointNearTool;
        }

        if (mouseToolInterface.mouseDoubleClickCallback) {
            toolInterface.mouseDoubleClickCallback = mouseToolInterface.mouseDoubleClickCallback;
        }

        if (mouseToolInterface.addNewMeasurement) {
            toolInterface.addNewMeasurement = mouseToolInterface.addNewMeasurement;
        }

        return toolInterface;
    }

    // module exports
    cornerstoneTools.mouseButtonTool = mouseButtonTool;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/mouseButtonTool.js

// Begin Source: src/imageTools/mouseButtonRectangleTool.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';
    
    function mouseButtonRectangleTool(mouseToolInterface, preventHandleOutsideImage) {
        ///////// BEGIN ACTIVE TOOL ///////
        function addNewMeasurement(mouseEventData) {
            var measurementData = mouseToolInterface.createNewMeasurement(mouseEventData);
            
            //prevent adding new measurement if tool returns nill
            if (!measurementData) {
                return;
            }

            // associate this data with this imageId so we can render it and manipulate it
            cornerstoneTools.addToolState(mouseEventData.element, mouseToolInterface.toolType, measurementData);
           
            // since we are dragging to another place to drop the end point, we can just activate
            // the end point and let the moveHandle move it for us.
            $(mouseEventData.element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
            cornerstoneTools.moveHandle(mouseEventData, mouseToolInterface.toolType, measurementData, measurementData.handles.end, function() {
                measurementData.active = false;
                if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(mouseEventData.element, mouseToolInterface.toolType, measurementData);
                }

                $(mouseEventData.element).on('CornerstoneToolsMouseMove', mouseMoveCallback);
            }, preventHandleOutsideImage);
        }

        function mouseDownActivateCallback(e, eventData) {
            if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
                addNewMeasurement(eventData);
                return false; // false = cases jquery to preventDefault() and stopPropagation() this event
            }
        }
        ///////// END ACTIVE TOOL ///////

        ///////// BEGIN DEACTIVE TOOL ///////

        function mouseMoveCallback(e, eventData) {
            cornerstoneTools.toolCoordinates.setCoords(eventData);
            // if a mouse button is down, do nothing
            if (eventData.which !== 0) {
                return;
            }
          
            // if we have no tool data for this element, do nothing
            var toolData = cornerstoneTools.getToolState(eventData.element, mouseToolInterface.toolType);
            if (toolData === undefined) {
                return;
            }
            
            // We have tool data, search through all data
            // and see if we can activate a handle
            var imageNeedsUpdate = false;
            var coords = eventData.currentPoints.canvas;

            for (var i = 0; i < toolData.data.length; i++) {
                // get the cursor position in image coordinates
                var data = toolData.data[i];
                if (cornerstoneTools.handleActivator(eventData.element, data.handles, coords) === true) {
                    imageNeedsUpdate = true;
                }

                if ((mouseToolInterface.pointInsideRect(eventData.element, data, coords) && !data.active) || (!mouseToolInterface.pointInsideRect(eventData.element, data, coords) && data.active)) {
                    data.active = !data.active;
                    imageNeedsUpdate = true;
                }
            }

            // Handle activation status changed, redraw the image
            if (imageNeedsUpdate === true) {
                cornerstone.updateImage(eventData.element);
            }
        }

        function mouseDownCallback(e, eventData) {
            var data;

            function handleDoneMove() {
                data.active = false;
                if (cornerstoneTools.anyHandlesOutsideImage(eventData, data.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(eventData.element, mouseToolInterface.toolType, data);
                }

                cornerstone.updateImage(eventData.element);
                $(eventData.element).on('CornerstoneToolsMouseMove', mouseMoveCallback);
            }

            if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
                var coords = eventData.startPoints.canvas;
                var toolData = cornerstoneTools.getToolState(e.currentTarget, mouseToolInterface.toolType);

                var i;

                // now check to see if there is a handle we can move
                var distanceSq = 25;

                if (toolData !== undefined) {
                    for (i = 0; i < toolData.data.length; i++) {
                        data = toolData.data[i];
                        var handle = cornerstoneTools.getHandleNearImagePoint(eventData.element, data.handles, coords, distanceSq);
                        if (handle !== undefined) {
                            $(eventData.element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
                            data.active = true;
                            cornerstoneTools.moveHandle(eventData, mouseToolInterface.toolType, data, handle, handleDoneMove, preventHandleOutsideImage);
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }

                // Now check to see if there is a line we can move
                // now check to see if we have a tool that we can move
                var options = {
                    deleteIfHandleOutsideImage: true,
                    preventHandleOutsideImage: preventHandleOutsideImage
                };
                
                if (toolData !== undefined && mouseToolInterface.pointInsideRect !== undefined) {
                    for (i = 0; i < toolData.data.length; i++) {
                        data = toolData.data[i];
                        if (mouseToolInterface.pointInsideRect(eventData.element, data, coords)) {
                            $(eventData.element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
                            cornerstoneTools.moveAllHandles(e, data, toolData, mouseToolInterface.toolType, options, handleDoneMove);
                            $(eventData.element).on('CornerstoneToolsMouseMove', mouseMoveCallback);
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }
            }
        }
        ///////// END DEACTIVE TOOL ///////

        // not visible, not interactive
        function disable(element) {
            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseDownActivateCallback);

            cornerstone.updateImage(element);
        }

        // visible but not interactive
        function enable(element) {
            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseDownActivateCallback);

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);

            cornerstone.updateImage(element);
        }

        // visible, interactive and can create
        function activate(element, mouseButtonMask) {
            var eventData = {
                mouseButtonMask: mouseButtonMask
            };

            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseDownActivateCallback);

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).on('CornerstoneToolsMouseMove', eventData, mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);
            $(element).on('CornerstoneToolsMouseDownActivate', eventData, mouseDownActivateCallback);

            cornerstone.updateImage(element);
        }

        // visible, interactive
        function deactivate(element, mouseButtonMask) {
            var eventData = {
                mouseButtonMask: mouseButtonMask
            };

            $(element).off('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
            $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
            $(element).off('CornerstoneToolsMouseDownActivate', mouseDownActivateCallback);

            $(element).on('CornerstoneImageRendered', mouseToolInterface.onImageRendered);
            $(element).on('CornerstoneToolsMouseMove', eventData, mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);

            cornerstone.updateImage(element);
        }

        var toolInterface = {
            enable: enable,
            disable: disable,
            activate: activate,
            deactivate: deactivate
        };

        return toolInterface;
    }

    // module exports
    cornerstoneTools.mouseButtonRectangleTool = mouseButtonRectangleTool;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/mouseButtonRectangleTool.js

// Begin Source: src/imageTools/mouseWheelTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseWheelTool(mouseWheelCallback) {
        var toolInterface = {
            activate: function(element) {
                $(element).off('CornerstoneToolsMouseWheel', mouseWheelCallback);
                var eventData = {
                };
                $(element).on('CornerstoneToolsMouseWheel', eventData, mouseWheelCallback);
            },
            disable: function(element) {$(element).off('CornerstoneToolsMouseWheel', mouseWheelCallback);},
            enable: function(element) {$(element).off('CornerstoneToolsMouseWheel', mouseWheelCallback);},
            deactivate: function(element) {$(element).off('CornerstoneToolsMouseWheel', mouseWheelCallback);}
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.mouseWheelTool = mouseWheelTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/mouseWheelTool.js

// Begin Source: src/imageTools/touchDragTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function touchDragTool(touchDragCallback, options) {
        var events = 'CornerstoneToolsTouchDrag';
        if (options && options.fireOnTouchStart === true) {
            events += ' CornerstoneToolsTouchStart';
        }

        var toolInterface = {
            activate: function(element) {
                $(element).off(events, touchDragCallback);

                if (options && options.eventData) {
                    $(element).on(events, options.eventData, touchDragCallback);
                } else {
                    $(element).on(events, touchDragCallback);
                }

                if (options && options.activateCallback) {
                    options.activateCallback(element);
                }
            },
            disable: function(element) {
                $(element).off(events, touchDragCallback);
                if (options && options.disableCallback) {
                    options.disableCallback(element);
                }
            },
            enable: function(element) {
                $(element).off(events, touchDragCallback);
                if (options && options.enableCallback) {
                    options.enableCallback(element);
                }
            },
            deactivate: function(element) {
                $(element).off(events, touchDragCallback);
                if (options && options.deactivateCallback) {
                    options.deactivateCallback(element);
                }
            }
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.touchDragTool = touchDragTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/touchDragTool.js

// Begin Source: src/imageTools/touchPinchTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    /*jshint newcap: false */

    function touchPinchTool(touchPinchCallback) {
        var toolInterface = {
            activate: function(element) {
                $(element).off('CornerstoneToolsTouchPinch', touchPinchCallback);
                var eventData = {
                };
                $(element).on('CornerstoneToolsTouchPinch', eventData, touchPinchCallback);
            },
            disable: function(element) {$(element).off('CornerstoneToolsTouchPinch', touchPinchCallback);},
            enable: function(element) {$(element).off('CornerstoneToolsTouchPinch', touchPinchCallback);},
            deactivate: function(element) {$(element).off('CornerstoneToolsTouchPinch', touchPinchCallback);}
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.touchPinchTool = touchPinchTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/touchPinchTool.js

// Begin Source: src/imageTools/touchTool.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function deactivateAllHandles(handles) {
        Object.keys(handles).forEach(function(name) {
            var handle = handles[name];
            handle.active = false;
        });
    }

    function deactivateAllToolInstances(toolData) {
        if (!toolData) {
            return;
        }

        for (var i = 0; i < toolData.data.length; i++) {
            var data = toolData.data[i];
            data.active = false;
            if (!data.handles) {
                continue;
            }

            deactivateAllHandles(data.handles);
        }
    }

    function touchTool(touchToolInterface) {
        ///////// BEGIN ACTIVE TOOL ///////

        function addNewMeasurement(touchEventData) {
            //console.log('touchTool addNewMeasurement');
            var element = touchEventData.element;

            var measurementData = touchToolInterface.createNewMeasurement(touchEventData);
            if (!measurementData) {
                return;
            }

            cornerstoneTools.addToolState(element, touchToolInterface.toolType, measurementData);

            if (Object.keys(measurementData.handles).length === 1 && touchEventData.type === 'CornerstoneToolsTap') {
                measurementData.active = false;
                measurementData.handles.end.active = false;
                measurementData.handles.end.highlight = false;
                measurementData.invalidated = true;
                if (cornerstoneTools.anyHandlesOutsideImage(touchEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, touchToolInterface.toolType, measurementData);
                }

                cornerstone.updateImage(element);
                return;
            }

            $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            cornerstone.updateImage(element);
            cornerstoneTools.moveNewHandleTouch(touchEventData, touchToolInterface.toolType, measurementData, measurementData.handles.end, function() {
                measurementData.active = false;
                measurementData.invalidated = true;
                if (cornerstoneTools.anyHandlesOutsideImage(touchEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, touchToolInterface.toolType, measurementData);
                }

                $(element).on('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                $(element).on('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
                cornerstone.updateImage(element);
            });
        }

        function touchDownActivateCallback(e, eventData) {
            //console.log('touchTool touchDownActivateCallback');
            if (touchToolInterface.addNewMeasurement) {
                touchToolInterface.addNewMeasurement(eventData);
            } else {
                addNewMeasurement(eventData);
            }

            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
        ///////// END ACTIVE TOOL ///////

        ///////// BEGIN INACTIVE TOOL ///////
        function tapCallback(e, eventData) {
            //console.log('touchTool tapCallback');
            var element = eventData.element;
            var coords = eventData.currentPoints.canvas;
            var toolData = cornerstoneTools.getToolState(e.currentTarget, touchToolInterface.toolType);
            var data;
            var i;

            // Deactivate everything
            deactivateAllToolInstances(toolData);

            function doneMovingCallback() {
                // console.log('touchTool tapCallback doneMovingCallback');
                deactivateAllToolInstances(toolData);
                if (cornerstoneTools.anyHandlesOutsideImage(eventData, data.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, touchToolInterface.toolType, data);
                }

                cornerstone.updateImage(element);
                $(element).on('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                $(element).on('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
            }

            // now check to see if there is a handle we can move
            if (toolData) {
                for (i = 0; i < toolData.data.length; i++) {
                    data = toolData.data[i];
                    var distanceSq = 25; // Should probably make this a settable property later
                    var handle = cornerstoneTools.getHandleNearImagePoint(element, data.handles, coords, distanceSq);
                    if (handle) {
                        $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                        $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
                        data.active = true;
                        handle.active = true;
                        cornerstone.updateImage(element);
                        cornerstoneTools.touchMoveHandle(e, touchToolInterface.toolType, data, handle, doneMovingCallback);
                        e.stopImmediatePropagation();
                        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
                    }
                }
            }

            // Now check to see if we have a tool that we can move
            if (toolData && touchToolInterface.pointNearTool) {
                for (i = 0; i < toolData.data.length; i++) {
                    data = toolData.data[i];
                    if (touchToolInterface.pointNearTool(element, data, coords)) {
                        $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                        $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
                        data.active = true;
                        cornerstone.updateImage(element);
                        cornerstoneTools.touchMoveAllHandles(e, data, toolData, touchToolInterface.toolType, true, doneMovingCallback);
                        e.stopImmediatePropagation();
                        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
                    }
                }
            }

            // If there is nothing to move, add a new instance of the tool
            // Need to check here to see if activation is allowed!
            if (touchToolInterface.touchDownActivateCallback) {
                touchToolInterface.touchDownActivateCallback(e, eventData);
            } else {
                touchDownActivateCallback(e, eventData);
            }

            return false;
        }

        function touchStartCallback(e, eventData) {
            //console.log('touchTool touchStartCallback');
            var element = eventData.element;
            var coords = eventData.startPoints.canvas;
            var data;
            var toolData = cornerstoneTools.getToolState(e.currentTarget, touchToolInterface.toolType);
            var i;

            function doneMovingCallback() {
                //console.log('touchTool touchStartCallback doneMovingCallback');
                data.active = false;
                data.invalidated = true;
                if (cornerstoneTools.anyHandlesOutsideImage(eventData, data.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(eventData.element, touchToolInterface.toolType, data);
                }

                cornerstone.updateImage(eventData.element);
                $(element).on('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                $(element).on('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
            }

            // now check to see if there is a handle we can move
            var distanceFromTouch = cornerstoneTools.touchSettings.getToolDistanceFromTouch();
            var distanceSq = Math.max(Math.abs(distanceFromTouch.x), Math.abs(distanceFromTouch.y));
            if (toolData) {
                for (i = 0; i < toolData.data.length; i++) {
                    data = toolData.data[i];

                    var handle = cornerstoneTools.getHandleNearImagePoint(eventData.element, data.handles, coords, distanceSq);
                    if (handle) {
                        $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                        $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
                        data.active = true;
                        cornerstoneTools.touchMoveHandle(e, touchToolInterface.toolType, data, handle, doneMovingCallback);
                        e.stopImmediatePropagation();
                        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
                    }
                }
            }

            // Now check to see if we have a tool that we can move
            if (toolData && touchToolInterface.pointNearTool) {
                for (i = 0; i < toolData.data.length; i++) {
                    data = toolData.data[i];
                    if (touchToolInterface.pointNearTool(eventData.element, data, coords)) {
                        $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
                        $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);
                        cornerstoneTools.touchMoveAllHandles(e, data, toolData, touchToolInterface.toolType, true, doneMovingCallback);
                        e.stopImmediatePropagation();
                        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
                    }
                }
            }
        }
        ///////// END INACTIVE TOOL ///////

        // not visible, not interactive
        function disable(element) {
            $(element).off('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsTouchStart', touchToolInterface.touchStartCallback || touchStartCallback);
            $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            if (touchToolInterface.doubleTapCallback) {
                $(element).off('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
            }
            
            if (touchToolInterface.pressCallback) {
                $(element).off('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
            }

            cornerstone.updateImage(element);
        }

        // visible but not interactive
        function enable(element) {
            $(element).off('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsTouchStart', touchToolInterface.touchStartCallback || touchStartCallback);
            $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            $(element).on('CornerstoneImageRendered', touchToolInterface.onImageRendered);

            if (touchToolInterface.doubleTapCallback) {
                $(element).off('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
            }

            if (touchToolInterface.pressCallback) {
                $(element).off('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
            }

            cornerstone.updateImage(element);
        }

        // visible, interactive and can create
        function activate(element) {
            //console.log('activate touchTool');

            $(element).off('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsTouchStart', touchToolInterface.touchStartCallback || touchStartCallback);
            $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            $(element).on('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            $(element).on('CornerstoneToolsTouchStart', touchToolInterface.touchStartCallback || touchStartCallback);
            $(element).on('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).on('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            if (touchToolInterface.doubleTapCallback) {
                $(element).off('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
                $(element).on('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
            }

            if (touchToolInterface.pressCallback) {
                $(element).off('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
                $(element).on('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
            }

            cornerstone.updateImage(element);
        }

        // visible, interactive
        function deactivate(element) {
            //console.log('deactivate touchTool');
            
            $(element).off('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            $(element).off('CornerstoneToolsTouchStart', touchToolInterface.touchStartCallback || touchStartCallback);
            $(element).off('CornerstoneToolsTouchStartActive', touchToolInterface.touchDownActivateCallback || touchDownActivateCallback);
            $(element).off('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            $(element).on('CornerstoneImageRendered', touchToolInterface.onImageRendered);
            //$(element).on('CornerstoneToolsTap', touchToolInterface.tapCallback || tapCallback);

            if (touchToolInterface.doubleTapCallback) {
                $(element).off('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
                $(element).on('CornerstoneToolsDoubleTap', touchToolInterface.doubleTapCallback);
            }

            if (touchToolInterface.pressCallback) {
                $(element).off('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
                $(element).on('CornerstoneToolsTouchPress', touchToolInterface.pressCallback);
            }

            cornerstone.updateImage(element);
        }

        var toolInterface = {
            enable: enable,
            disable: disable,
            activate: activate,
            deactivate: deactivate,
            touchStartCallback: touchToolInterface.touchStartCallback || touchStartCallback,
            touchDownActivateCallback: touchToolInterface.touchDownActivateCallback || touchDownActivateCallback,
            tapCallback: touchToolInterface.tapCallback || tapCallback
        };

        // Expose pointNearTool if available
        if (touchToolInterface.pointNearTool) {
            toolInterface.pointNearTool = touchToolInterface.pointNearTool;
        }

        if (touchToolInterface.doubleTapCallback) {
            toolInterface.doubleTapCallback = touchToolInterface.doubleTapCallback;
        }

        if (touchToolInterface.pressCallback) {
            toolInterface.pressCallback = touchToolInterface.pressCallback;
        }

        if (touchToolInterface.addNewMeasurement) {
            toolInterface.addNewMeasurement = touchToolInterface.addNewMeasurement;
        }

        return toolInterface;
    }

    // module exports
    cornerstoneTools.touchTool = touchTool;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/touchTool.js

// Begin Source: src/imageTools/AngleTool.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'angle';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var angleData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x - 20,
                    y: mouseEventData.currentPoints.image.y + 10,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                },
                start2: {
                    x: mouseEventData.currentPoints.image.x - 20,
                    y: mouseEventData.currentPoints.image.y + 10,
                    highlight: true,
                    active: false
                },
                end2: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y + 20,
                    highlight: true,
                    active: false
                }
            }
        };

        return angleData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointNearTool(element, data, coords) {
        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.end)
        };
        
        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        if (distanceToPoint < 5) {
            return true;
        }

        lineSegment.start = cornerstone.pixelToCanvas(element, data.handles.start2);
        lineSegment.end = cornerstone.pixelToCanvas(element, data.handles.end2);

        distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        return (distanceToPoint < 5);
    }

    ///////// BEGIN IMAGE RENDERING ///////
    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);
        
        //activation color 
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.angle.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            // configurable shadow
            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the line
            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;

            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);

            handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start2);
            handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end2);

            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);
            context.stroke();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles);

            // Draw the text
            context.fillStyle = color;

            // Need to work on correct angle to measure.  This is a cobb angle and we need to determine
            // where lines cross to measure angle. For now it will show smallest angle. 
            var dx1 = (Math.ceil(data.handles.start.x) - Math.ceil(data.handles.end.x)) * eventData.image.columnPixelSpacing;
            var dy1 = (Math.ceil(data.handles.start.y) - Math.ceil(data.handles.end.y)) * eventData.image.rowPixelSpacing;
            var dx2 = (Math.ceil(data.handles.start2.x) - Math.ceil(data.handles.end2.x)) * eventData.image.columnPixelSpacing;
            var dy2 = (Math.ceil(data.handles.start2.y) - Math.ceil(data.handles.end2.y)) * eventData.image.rowPixelSpacing;

            var angle = Math.acos(Math.abs(((dx1 * dx2) + (dy1 * dy2)) / (Math.sqrt((dx1 * dx1) + (dy1 * dy1)) * Math.sqrt((dx2 * dx2) + (dy2 * dy2)))));
            angle = angle * (180 / Math.PI);

            //var rAngle = cornerstoneTools.roundToDecimal(angle, 2);
            var rAngle = cornerstoneTools.roundToDecimal(angle, 1);//zyy add 说是角度只要1度
            var str = '00B0'; // degrees symbol
            var text = rAngle.toString() + String.fromCharCode(parseInt(str, 16));

            var textX = (handleStartCanvas.x + handleEndCanvas.x) / 2;
            var textY = (handleStartCanvas.y + handleEndCanvas.y) / 2;

            context.font = font;
            // cornerstoneTools.drawTextBox(context, text, textX, textY, color);//angle
            cornerstoneTools.drawTextBox(context, text, textX+15, textY+15, color);
            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.angle = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });
    
    cornerstoneTools.angleTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/AngleTool.js

// Begin Source: src/imageTools/annotation.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'arrowAnnotate';

    // Define a callback to get your text annotation
    // This could be used, e.g. to open a modal
    function getTextCallback(doneChangingTextCallback) {
        doneChangingTextCallback(prompt('Enter your annotation:'));
    }

    function changeTextCallback(data, doneChangingTextCallback) {
        doneChangingTextCallback(prompt('Change your annotation:'));
    }

    var configuration = {
        getTextCallback: getTextCallback,
        changeTextCallback: changeTextCallback,
        drawHandles: false,
        drawHandlesOnHover: true,
        arrowFirst: true
    };

    /// --- Mouse Tool --- ///

    ///////// BEGIN ACTIVE TOOL ///////
    function addNewMeasurement(mouseEventData) {

        var measurementData = createNewMeasurement(mouseEventData);

        function doneChangingTextCallback(text) {
            if (text !== null) {
                measurementData.text = text;
            } else {
                cornerstoneTools.removeToolState(mouseEventData.element, toolType, measurementData);
            }

            measurementData.active = false;
            cornerstone.updateImage(mouseEventData.element);
        }

        var eventData = {
            mouseButtonMask: mouseEventData.which,
        };
        
        // associate this data with this imageId so we can render it and manipulate it
        cornerstoneTools.addToolState(mouseEventData.element, toolType, measurementData);
       
        // since we are dragging to another place to drop the end point, we can just activate
        // the end point and let the moveHandle move it for us.
        $(mouseEventData.element).off('CornerstoneToolsMouseMove', cornerstoneTools.arrowAnnotate.mouseMoveCallback);
        $(mouseEventData.element).off('CornerstoneToolsMouseDown', cornerstoneTools.arrowAnnotate.mouseDownCallback);
        $(mouseEventData.element).off('CornerstoneToolsMouseDownActivate', cornerstoneTools.arrowAnnotate.mouseDownActivateCallback);

        cornerstone.updateImage(mouseEventData.element);
        cornerstoneTools.moveNewHandle(mouseEventData, toolType, measurementData, measurementData.handles.end, function() {
            if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                // delete the measurement
                cornerstoneTools.removeToolState(mouseEventData.element, toolType, measurementData);
            }

            var config = cornerstoneTools.arrowAnnotate.getConfiguration();
            if (measurementData.text === undefined) {
                config.getTextCallback(doneChangingTextCallback);
            }

            $(mouseEventData.element).on('CornerstoneToolsMouseMove', eventData, cornerstoneTools.arrowAnnotate.mouseMoveCallback);
            $(mouseEventData.element).on('CornerstoneToolsMouseDown', eventData, cornerstoneTools.arrowAnnotate.mouseDownCallback);
            $(mouseEventData.element).on('CornerstoneToolsMouseDownActivate', eventData, cornerstoneTools.arrowAnnotate.mouseDownActivateCallback);
            cornerstone.updateImage(mouseEventData.element);
        });
    }

    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                }
            }
        };

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointNearTool(element, data, coords) {
        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.end)
        };

        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        if (distanceToPoint < 25) {
            return true;
        }

        if (data.textCoords) {
            var padding = 5;
            var fontSize = cornerstoneTools.textStyle.getFontSize();
            
            var rect = {
                left: data.textCoords.x,
                top: data.textCoords.y,
                width: data.textWidth + (padding * 2),
                height: fontSize + (padding * 2)
            };

            var distanceToTextRect = cornerstoneMath.rect.distanceToPoint(rect, coords);
            return (distanceToTextRect < 25);
        }
    }

    ///////// BEGIN IMAGE RENDERING ///////
    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.arrowAnnotate.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }
            
            // Draw the arrow
            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            if (config.arrowFirst) {
                cornerstoneTools.drawArrow(context, handleEndCanvas, handleStartCanvas, color, lineWidth);
            } else {
                cornerstoneTools.drawArrow(context, handleStartCanvas, handleEndCanvas, color, lineWidth);
            }

            if (config.drawHandles) {
                cornerstoneTools.drawHandles(context, eventData, data.handles, color);
            } else if (config.drawHandlesOnHover && data.handles.start.active) {
                cornerstoneTools.drawHandles(context, eventData, [ data.handles.start ], color);
            } else if (config.drawHandlesOnHover && data.handles.end.active) {
                cornerstoneTools.drawHandles(context, eventData, [ data.handles.end ], color);
            }

            // Draw the text
            if (data.text && data.text !== '') {
                context.font = font;
                
                var distance = 13;

                // TODO: add 2 dimensional vector operations to cornerstoneMath
                var vector;
                
                var displacement = {
                    x: distance,
                    y: distance / 2
                };

                vector = {
                    x: handleEndCanvas.x - handleStartCanvas.x,
                    y: handleEndCanvas.y - handleStartCanvas.y
                };

                var textWidth = context.measureText(data.text).width;

                var textCoords;
                if (config.arrowFirst) {
                    // Fix text placement if arrow faces right
                    if (vector.x < 0) {
                        displacement.x = -displacement.x - textWidth;
                    }

                    textCoords = {
                        x: vector.x + handleStartCanvas.x + displacement.x,
                        y: vector.y + handleStartCanvas.y + displacement.y
                    };
                } else {
                    // Fix text placement if arrow faces right
                    if (vector.x > 0) {
                        displacement.x = -displacement.x - textWidth;
                    }

                    textCoords = {
                        x: -vector.x + handleEndCanvas.x + displacement.x,
                        y: -vector.y + handleEndCanvas.y + displacement.y
                    };
                }

                data.textCoords = textCoords;
                data.textWidth = textWidth;
                cornerstoneTools.drawTextBox(context, data.text, textCoords.x, textCoords.y, color);
            }

            context.restore();
        }
    }
    // ---- Touch tool ----

    ///////// BEGIN ACTIVE TOOL ///////
    function addNewMeasurementTouch(touchEventData) {
        var element = touchEventData.element;
        var measurementData = createNewMeasurement(touchEventData);
        
        function doneChangingTextCallback(text) {
            if (text !== null) {
                measurementData.text = text;
            } else {
                cornerstoneTools.removeToolState(element, toolType, measurementData);
            }

            measurementData.active = false;
            cornerstone.updateImage(element);
        }
        
        cornerstoneTools.addToolState(element, toolType, measurementData);
        $(element).off('CornerstoneToolsTouchStartActive', cornerstoneTools.arrowAnnotateTouch.touchDownActivateCallback);
        $(element).off('CornerstoneToolsTap', cornerstoneTools.arrowAnnotateTouch.tapCallback);
        cornerstone.updateImage(element);

        cornerstoneTools.moveNewHandleTouch(touchEventData, toolType, measurementData, measurementData.handles.end, function() {
            cornerstone.updateImage(element);

            if (cornerstoneTools.anyHandlesOutsideImage(touchEventData, measurementData.handles)) {
                // delete the measurement
                cornerstoneTools.removeToolState(element, toolType, measurementData);
            }

            var config = cornerstoneTools.arrowAnnotate.getConfiguration();
            if (measurementData.text === undefined) {
                config.getTextCallback(doneChangingTextCallback);
            }

            $(element).on('CornerstoneToolsTouchStartActive', cornerstoneTools.arrowAnnotateTouch.touchDownActivateCallback);
            $(element).on('CornerstoneToolsTap', cornerstoneTools.arrowAnnotateTouch.tapCallback);
        });
    }

    function doubleClickCallback(e, eventData) {
        var element = eventData.element;
        var data;

        function doneChangingTextCallback(data, updatedText, deleteTool) {
            if (deleteTool === true) {
                cornerstoneTools.removeToolState(element, toolType, data);
            } else {
                data.text = updatedText;
            }

            data.active = false;
            cornerstone.updateImage(element);
        }

        if (e.data && e.data.mouseButtonMask && !cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            return false;
        }

        var config = cornerstoneTools.arrowAnnotate.getConfiguration();

        var coords = eventData.currentPoints.canvas;
        var toolData = cornerstoneTools.getToolState(element, toolType);

        // now check to see if there is a handle we can move
        if (!toolData) {
            return false;
        }

        for (var i = 0; i < toolData.data.length; i++) {
            data = toolData.data[i];
            if (pointNearTool(element, data, coords)) {
                data.active = true;
                cornerstone.updateImage(element);
                // Allow relabelling via a callback
                config.changeTextCallback(data, doneChangingTextCallback);
                
                e.stopImmediatePropagation();
                return false;
            }
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    function pressCallback(e, eventData) {
        var element = eventData.element;
        var data;

        function doneChangingTextCallback(data, updatedText, deleteTool) {
            if (deleteTool === true) {
                cornerstoneTools.removeToolState(element, toolType, data);
            } else {
                data.text = updatedText;
            }

            data.active = false;
            cornerstone.updateImage(element);
            $(element).on('CornerstoneToolsTouchStart', cornerstoneTools.arrowAnnotateTouch.touchStartCallback);
            $(element).on('CornerstoneToolsTouchStartActive', cornerstoneTools.arrowAnnotateTouch.touchDownActivateCallback);
        }

        if (e.data && e.data.mouseButtonMask && !cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            return false;
        }

        var config = cornerstoneTools.arrowAnnotate.getConfiguration();

        var coords = eventData.currentPoints.canvas;
        var toolData = cornerstoneTools.getToolState(element, toolType);

        // now check to see if there is a handle we can move
        if (!toolData) {
            return false;
        }

        for (var i = 0; i < toolData.data.length; i++) {
            data = toolData.data[i];
            if (pointNearTool(element, data, coords)) {
                data.active = true;
                cornerstone.updateImage(element);
                // Allow relabelling via a callback
                $(element).off('CornerstoneToolsTouchStart', cornerstoneTools.arrowAnnotateTouch.touchStartCallback);
                $(element).off('CornerstoneToolsTouchStartActive', cornerstoneTools.arrowAnnotateTouch.touchDownActivateCallback);
                config.changeTextCallback(data, doneChangingTextCallback);
                
                e.stopImmediatePropagation();
                return false;
            }
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    cornerstoneTools.arrowAnnotate = cornerstoneTools.mouseButtonTool({
        addNewMeasurement: addNewMeasurement,
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType,
        mouseDoubleClickCallback: doubleClickCallback
    });

    cornerstoneTools.arrowAnnotate.setConfiguration(configuration);

    cornerstoneTools.arrowAnnotateTouch = cornerstoneTools.touchTool({
        addNewMeasurement: addNewMeasurementTouch,
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType,
        pressCallback: pressCallback
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/annotation.js

// Begin Source: src/imageTools/crosshairs.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'crosshairs';

    function chooseLocation(e, eventData) {
        e.stopImmediatePropagation(); // Prevent CornerstoneToolsTouchStartActive from killing any press events
        
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (!toolData) {
            return;
        }

        // Get current element target information
        var sourceElement = e.currentTarget;
        var sourceEnabledElement = cornerstone.getEnabledElement(sourceElement);
        var sourceImageId = sourceEnabledElement.image.imageId;
        var sourceImagePlane = cornerstoneTools.metaData.get('imagePlane', sourceImageId);

        // Get currentPoints from mouse cursor on selected element
        var sourceImagePoint = eventData.currentPoints.image;

        // Transfer this to a patientPoint given imagePlane metadata
        var patientPoint = cornerstoneTools.imagePointToPatientPoint(sourceImagePoint, sourceImagePlane);

        // Get the enabled elements associated with this synchronization context
        var syncContext = toolData.data[0].synchronizationContext;
        var enabledElements = syncContext.getSourceElements();

        // Iterate over each synchronized element
        $.each(enabledElements, function(index, targetElement) {
            // don't do anything if the target is the same as the source
            if (targetElement === sourceElement) {
                return; // Same as 'continue' in a normal for loop
            }

            var minDistance = Number.MAX_VALUE;
            var newImageIdIndex = -1;

            var stackToolDataSource = cornerstoneTools.getToolState(targetElement, 'stack');
            if (stackToolDataSource === undefined) {
                return; // Same as 'continue' in a normal for loop
            }

            var stackData = stackToolDataSource.data[0];

            // Find within the element's stack the closest image plane to selected location
            $.each(stackData.imageIds, function(index, imageId) {
                var imagePlane = cornerstoneTools.metaData.get('imagePlane', imageId);
                var imagePosition = imagePlane.imagePositionPatient;
                var row = imagePlane.rowCosines.clone();
                var column = imagePlane.columnCosines.clone();
                var normal = column.clone().cross(row.clone());
                var distance = Math.abs(normal.clone().dot(imagePosition) - normal.clone().dot(patientPoint));
                //console.log(index + '=' + distance);
                if (distance < minDistance) {
                    minDistance = distance;
                    newImageIdIndex = index;
                }
            });

            if (newImageIdIndex === stackData.currentImageIdIndex) {
                return;
            }

            // Switch the loaded image to the required image
            if (newImageIdIndex !== -1 && stackData.imageIds[newImageIdIndex] !== undefined) {
                var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
                var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
                var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

                if (startLoadingHandler) {
                    startLoadingHandler(targetElement);
                }

                var loader;
                if (stackData.preventCache === true) {
                    loader = cornerstone.loadImage(stackData.imageIds[newImageIdIndex]);
                } else {
                    loader = cornerstone.loadAndCacheImage(stackData.imageIds[newImageIdIndex]);
                }

                loader.then(function(image) {
                    var viewport = cornerstone.getViewport(targetElement);
                    stackData.currentImageIdIndex = newImageIdIndex;
                    cornerstone.displayImage(targetElement, image, viewport);
                    if (endLoadingHandler) {
                        endLoadingHandler(targetElement);
                    }
                }, function(error) {
                    var imageId = stackData.imageIds[newImageIdIndex];
                    if (errorLoadingHandler) {
                        errorLoadingHandler(targetElement, imageId, error);
                    }
                });
            }
        });
    }

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', mouseDragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', mouseDragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            chooseLocation(e, eventData);
            return false; // false = cases jquery to preventDefault() and stopPropagation() this event
        }
    }

    function mouseDragCallback(e, eventData) {
        chooseLocation(e, eventData);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    function enable(element, mouseButtonMask, synchronizationContext) {
        var eventData = {
            mouseButtonMask: mouseButtonMask,
        };
        
        // Clear any currently existing toolData
        var toolData = cornerstoneTools.getToolState(element, toolType);
        toolData = [];

        cornerstoneTools.addToolState(element, toolType, {
            synchronizationContext: synchronizationContext,
        });

        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);

        $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);
    }

    // disables the reference line tool for the given element
    function disable(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
    }

    // module/private exports
    cornerstoneTools.crosshairs = {
        activate: enable,
        deactivate: disable,
        enable: enable,
        disable: disable
    };

    function dragEndCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsTouchDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsDragEnd', dragEndCallback);
    }

    function dragStartCallback(e, eventData) {
        $(eventData.element).on('CornerstoneToolsTouchDrag', dragCallback);
        $(eventData.element).on('CornerstoneToolsDragEnd', dragEndCallback);
        chooseLocation(e, eventData);
        return false;
    }

    function dragCallback(e, eventData) {
        chooseLocation(e, eventData);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    function enableTouch(element, synchronizationContext) {
        // Clear any currently existing toolData
        var toolData = cornerstoneTools.getToolState(element, toolType);
        toolData = [];

        cornerstoneTools.addToolState(element, toolType, {
            synchronizationContext: synchronizationContext,
        });

        $(element).off('CornerstoneToolsTouchStart', dragStartCallback);

        $(element).on('CornerstoneToolsTouchStart', dragStartCallback);
    }

    // disables the reference line tool for the given element
    function disableTouch(element) {
        $(element).off('CornerstoneToolsTouchStart', dragStartCallback);
    }

    cornerstoneTools.crosshairsTouch = {
        activate: enableTouch,
        deactivate: disableTouch,
        enable: enableTouch,
        disable: disableTouch
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/crosshairs.js

// Begin Source: src/imageTools/displayTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function displayTool(onImageRendered) {
        var configuration = {};

        var toolInterface = {
            disable: function(element) {$(element).off('CornerstoneImageRendered', onImageRendered);},
            enable: function(element) {
                $(element).off('CornerstoneImageRendered', onImageRendered);
                $(element).on('CornerstoneImageRendered', onImageRendered);
                cornerstone.updateImage(element);
            },
            getConfiguration: function() { return configuration; },
            setConfiguration: function(config) {configuration = config;}
        };

        return toolInterface;
    }

    // module exports
    cornerstoneTools.displayTool = displayTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/displayTool.js

// Begin Source: src/imageTools/dragProbe.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function defaultStrategy(eventData) {
        var enabledElement = cornerstone.getEnabledElement(eventData.element);

        cornerstone.updateImage(eventData.element);

        var context = enabledElement.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color = cornerstoneTools.toolColors.getActiveColor();
        var font = cornerstoneTools.textStyle.getFont();
        var fontHeight = cornerstoneTools.textStyle.getFontSize();
        var config = cornerstoneTools.dragProbe.getConfiguration();

        context.save();

        if (config && config.shadow) {
            context.shadowColor = config.shadowColor || '#000000';
            context.shadowOffsetX = config.shadowOffsetX || 1;
            context.shadowOffsetY = config.shadowOffsetY || 1;
        }

        var x = Math.round(eventData.currentPoints.image.x);
        var y = Math.round(eventData.currentPoints.image.y);

        var storedPixels;
        var text,
            str;

        if (x < 0 || y < 0 || x >= eventData.image.columns || y >= eventData.image.rows) {
            return;
        }

        if (eventData.image.color) {
            storedPixels = cornerstoneTools.getRGBPixels(eventData.element, x, y, 1, 1);
            text = '' + x + ', ' + y;
            str = 'R: ' + storedPixels[0] + ' G: ' + storedPixels[1] + ' B: ' + storedPixels[2] + ' A: ' + storedPixels[3];
        } else {
            storedPixels = cornerstone.getStoredPixels(eventData.element, x, y, 1, 1);
            var sp = storedPixels[0];
            var mo = sp * eventData.image.slope + eventData.image.intercept;
            var suv = cornerstoneTools.calculateSUV(eventData.image, sp);

            // Draw text
            text = '' + x + ', ' + y;
            str = 'SP: ' + sp + ' MO: ' + parseFloat(mo.toFixed(3));
            if (suv) {
                str += ' SUV: ' + parseFloat(suv.toFixed(3));
            }

        }

        // Draw text
        var coords = {
            // translate the x/y away from the cursor
            x: eventData.currentPoints.image.x + 3,
            y: eventData.currentPoints.image.y - 3
        };
        var textCoords = cornerstone.pixelToCanvas(eventData.element, coords);
        
        context.font = font;
        context.fillStyle = color;

        cornerstoneTools.drawTextBox(context, str, textCoords.x, textCoords.y + fontHeight + 5, color);
        cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);
        context.restore();
    }

    function minimalStrategy(eventData) {
        var element = eventData.element;
        var enabledElement = cornerstone.getEnabledElement(element);
        var image = enabledElement.image;

        cornerstone.updateImage(element);

        var context = enabledElement.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color = cornerstoneTools.toolColors.getActiveColor();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.dragProbe.getConfiguration();
        
        context.save();

        if (config && config.shadow) {
            context.shadowColor = config.shadowColor || '#000000';
            context.shadowOffsetX = config.shadowOffsetX || 1;
            context.shadowOffsetY = config.shadowOffsetY || 1;
        }

        var toolCoords;
        if (eventData.isTouchEvent === true) {
            toolCoords = cornerstone.pageToPixel(element, eventData.currentPoints.page.x,
                eventData.currentPoints.page.y - cornerstoneTools.textStyle.getFontSize() * 4);
        } else {
            toolCoords = eventData.currentPoints.image;
        }

        var storedPixels;
        var text;

        if (toolCoords.x < 0 || toolCoords.y < 0 ||
            toolCoords.x >= image.columns || toolCoords.y >= image.rows) {
            return;
        }
        
        if (image.color) {
            storedPixels = cornerstone.getStoredPixels(element, toolCoords.x, toolCoords.y, 3, 1);
            text = 'R: ' + storedPixels[0] + ' G: ' + storedPixels[1] + ' B: ' + storedPixels[2];
        } else {
            storedPixels = cornerstone.getStoredPixels(element, toolCoords.x, toolCoords.y, 1, 1);
            var huValue = storedPixels[0] * image.slope + image.intercept;
            text = parseFloat(huValue.toFixed(3));
        }

        // Prepare text
        var textCoords = cornerstone.pixelToCanvas(element, toolCoords);
        context.font = font;
        context.fillStyle = color;

        // Translate the x/y away from the cursor
        var translation;
        if (eventData.isTouchEvent === true) {
            var width = context.measureText(text).width;
            translation = {
                x: -width / 2 - 5,
                y: -cornerstoneTools.textStyle.getFontSize() * 1.5
            };

            var handleRadius = 6;

            context.beginPath();
            context.strokeStyle = color;
            context.arc(textCoords.x, textCoords.y, handleRadius, 0, 2 * Math.PI);
            context.stroke();
        } else {
            translation = {
                x: 4,
                y: -4
            };
        }

        cornerstoneTools.drawTextBox(context, text, textCoords.x + translation.x, textCoords.y + translation.y, color);
        context.restore();
    }

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
        cornerstone.updateImage(eventData.element);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', dragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            cornerstoneTools.dragProbe.strategy(eventData);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    function dragCallback(e, eventData) {
        cornerstoneTools.dragProbe.strategy(eventData);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    cornerstoneTools.dragProbe = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    
    cornerstoneTools.dragProbe.strategies = {
        default: defaultStrategy,
        minimal: minimalStrategy
    };
    cornerstoneTools.dragProbe.strategy = defaultStrategy;

    var options = {
        fireOnTouchStart: true
    };
    cornerstoneTools.dragProbeTouch = cornerstoneTools.touchDragTool(dragCallback, options);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/dragProbe.js

// Begin Source: src/imageTools/ellipticalRoi.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'ellipticalRoi';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            invalidated: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    ///////// BEGIN IMAGE RENDERING ///////
    function pointInEllipse(ellipse, location) {
        var xRadius = ellipse.width / 2;
        var yRadius = ellipse.height / 2;

        if (xRadius <= 0.0 || yRadius <= 0.0) {
            return false;
        }

        var center = {
            x: ellipse.left + xRadius,
            y: ellipse.top + yRadius
        };

        /* This is a more general form of the circle equation
         *
         * X^2/a^2 + Y^2/b^2 <= 1
         */

        var normalized = {
            x: location.x - center.x,
            y: location.y - center.y
        };

        var inEllipse = ((normalized.x * normalized.x) / (xRadius * xRadius)) + ((normalized.y * normalized.y) / (yRadius * yRadius)) <= 1.0;
        return inEllipse;
    }

    function calculateMeanStdDev(sp, ellipse) {
        // TODO: Get a real statistics library here that supports large counts

        var sum = 0;
        var sumSquared = 0;
        var count = 0;
        var index = 0;

        for (var y = ellipse.top; y < ellipse.top + ellipse.height; y++) {
            for (var x = ellipse.left; x < ellipse.left + ellipse.width; x++) {
                if (pointInEllipse(ellipse, {
                    x: x,
                    y: y
                }) === true) {
                    sum += sp[index];
                    sumSquared += sp[index] * sp[index];
                    count++;
                }

                index++;
            }
        }

        if (count === 0) {
            return {
                count: count,
                mean: 0.0,
                variance: 0.0,
                stdDev: 0.0
            };
        }

        var mean = sum / count;
        var variance = sumSquared / count - mean * mean;

        return {
            count: count,
            mean: mean,
            variance: variance,
            stdDev: Math.sqrt(variance)
        };
    }

    function pointNearEllipse(element, data, coords, distance) {
        var startCanvas = cornerstone.pixelToCanvas(element, data.handles.start);
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);

        var minorEllipse = {
            left: Math.min(startCanvas.x, endCanvas.x) + distance / 2,
            top: Math.min(startCanvas.y, endCanvas.y) + distance / 2 ,
            width: Math.abs(startCanvas.x - endCanvas.x) - distance,
            height: Math.abs(startCanvas.y - endCanvas.y) - distance
        };
        
        var majorEllipse = {
            left: Math.min(startCanvas.x, endCanvas.x) - distance / 2,
            top: Math.min(startCanvas.y, endCanvas.y) - distance / 2 ,
            width: Math.abs(startCanvas.x - endCanvas.x) + distance,
            height: Math.abs(startCanvas.y - endCanvas.y) + distance
        };

        var pointInMinorEllipse = pointInEllipse(minorEllipse, coords);
        var pointInMajorEllipse = pointInEllipse(majorEllipse, coords);

        if (pointInMajorEllipse && !pointInMinorEllipse) {
            return true;
        }

        return false;
    }

    function pointNearTool(element, data, coords) {
        return pointNearEllipse(element, data, coords, 15);
    }

    function pointNearToolTouch(element, data, coords) {
        return pointNearEllipse(element, data, coords, 25);
    }

    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        //activation color 
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var fontHeight = cornerstoneTools.textStyle.getFontSize();
        var config = cornerstoneTools.ellipticalRoi.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();
            
            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the ellipse
            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            var widthCanvas = Math.abs(handleStartCanvas.x - handleEndCanvas.x);
            var heightCanvas = Math.abs(handleStartCanvas.y - handleEndCanvas.y);
            var leftCanvas = Math.min(handleStartCanvas.x, handleEndCanvas.x);
            var topCanvas = Math.min(handleStartCanvas.y, handleEndCanvas.y);
            var centerX = (handleStartCanvas.x + handleEndCanvas.x) / 2;
            var centerY = (handleStartCanvas.y + handleEndCanvas.y) / 2;

            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;
            cornerstoneTools.drawEllipse(context, leftCanvas, topCanvas, widthCanvas, heightCanvas);
            context.closePath();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color);
            
            context.font = font;

            var textX,
                textY,
                area,
                meanStdDev;

            if (!data.invalidated) {
                textX = data.textX;
                textY = data.textY;
                meanStdDev = data.meanStdDev;
                area = data.area;
            } else {
                // TODO: calculate this in web worker for large pixel counts...
                var width = Math.abs(data.handles.start.x - data.handles.end.x);
                var height = Math.abs(data.handles.start.y - data.handles.end.y);
                var left = Math.min(data.handles.start.x, data.handles.end.x);
                var top = Math.min(data.handles.start.y, data.handles.end.y);

                var pixels = cornerstone.getPixels(eventData.element, left, top, width, height);

                var ellipse = {
                    left: left,
                    top: top,
                    width: width,
                    height: height
                };

                // Calculate the mean, stddev, and area
                meanStdDev = calculateMeanStdDev(pixels, ellipse);
                area = Math.PI * (width * eventData.image.columnPixelSpacing / 2) * (height * eventData.image.rowPixelSpacing / 2);

                data.invalidated = false;
                if (!isNaN(area)) {
                    data.area = area;
                }

                if (!isNaN(meanStdDev.mean) && !isNaN(meanStdDev.stdDev)) {
                    data.meanStdDev = meanStdDev;
                }
            }

            // Draw text

            var areaText,
                areaTextWidth = 0;
            if (area !== undefined) {
                //areaText = 'Area: ' + area.toFixed(2) + ' mm' + String.fromCharCode(178);
                areaText = 'Area: ' + area.toFixed(0) + ' mm' + String.fromCharCode(178);
                areaTextWidth = context.measureText(areaText).width;
            }

            //zyy change
            //var meanText = 'Mean: ' + meanStdDev.mean.toFixed(2);
            var meanText = 'Mean: ' + meanStdDev.mean.toFixed(1);
            var meanTextWidth = context.measureText(meanText).width;

            //var stdDevText = 'StdDev: ' + meanStdDev.stdDev.toFixed(2);
            var stdDevText = 'StdDev: ' + meanStdDev.stdDev.toFixed(1);
            var stdDevTextWidth = context.measureText(stdDevText).width;

            var longestTextWidth = Math.max(meanTextWidth, areaTextWidth, stdDevTextWidth);

          /*  textX = centerX < (eventData.image.columns / 2) ? centerX + (widthCanvas / 2) + longestTextWidth: centerX - (widthCanvas / 2) - longestTextWidth - 30; //15=》25
            textY = centerY < (eventData.image.rows / 2) ? centerY + (heightCanvas / 2): centerY - (heightCanvas / 2);
            */
            //新的计算标识的显示位置
            //sj change
            //比例可以了，但是方向还不完美
            // textX = centerX < (eventData.image.columns / 2) ?  handleEndCanvas.x+20 :centerX - (widthCanvas / 2) - longestTextWidth - 30;
            // textY = centerY < (eventData.image.rows / 2) ? handleEndCanvas.y:centerY - (heightCanvas / 2);
            // 把标识统一到右边
            textX = handleEndCanvas.x>handleStartCanvas.x?handleEndCanvas.x+10:handleStartCanvas.x+10;
            textY = handleEndCanvas.y>handleStartCanvas.y?handleEndCanvas.y+10:handleStartCanvas.y+10;
            //sj change end
            context.fillStyle = color;
            /*if (meanStdDev) {
                cornerstoneTools.drawTextBox(context, meanText, textX, textY - fontHeight - 5, color);
                cornerstoneTools.drawTextBox(context, stdDevText, textX, textY, color);
            }

            // Char code 178 is a superscript 2 for mm^2
            if (area !== undefined && !isNaN(area)) {
                cornerstoneTools.drawTextBox(context, areaText, textX, textY + fontHeight + 5, color);
            }*/

            //sj change ellipse
            var textwidth;
            if (meanStdDev)
            {
                textwidth=  Math.max(context.measureText(meanText).width,context.measureText(stdDevText).width);

            }
            if (area !== undefined && !isNaN(area))
            {
                textwidth= Math.max(textwidth,context.measureText(areaText).width);
            }
            //sj add end
            if (meanStdDev) {
                cornerstoneTools.drawTextBox(context, meanText, textX, textY - fontHeight - 5, color,textwidth);
                cornerstoneTools.drawTextBox(context, stdDevText, textX, textY, color,textwidth);
            }

            // Char code 178 is a superscript 2 for mm^2
            if (area !== undefined && !isNaN(area)) {
                cornerstoneTools.drawTextBox(context, areaText, textX, textY + fontHeight + 5, color,textwidth);
            }
            //sj change ellipse end

            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.ellipticalRoi = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });
    cornerstoneTools.ellipticalRoiTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearToolTouch,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/ellipticalRoi.js

// Begin Source: src/imageTools/freehand.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'freehand';
    var configuration = {
        mouseLocation: {
            handles: {
                start: {
                    highlight: true,
                    active: true,
                }
            }
        },
        freehand: false,
        modifying: false,
        currentHandle: 0,
        currentTool: -1
    };

    ///////// BEGIN ACTIVE TOOL ///////
    function addPoint(eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (toolData === undefined) {
            return;
        }

        var config = cornerstoneTools.freehand.getConfiguration();

        // Get the toolData from the last-drawn drawing
        // (this should change when modification is added)
        var data = toolData.data[config.currentTool];

        var handleData = {
            x: eventData.currentPoints.image.x,
            y: eventData.currentPoints.image.y,
            highlight: true,
            active: true,
            lines: []
        };

        // If this is not the first handle
        if (data.handles.length){
            // Add the line from the current handle to the new handle
            data.handles[config.currentHandle - 1].lines.push(eventData.currentPoints.image);
        }

        // Add the new handle
        data.handles.push(handleData);

        // Increment the current handle value
        config.currentHandle += 1;

        // Reset freehand value
        config.freehand = false;

        // Force onImageRendered to fire
        cornerstone.updateImage(eventData.element);
    }

    function pointNearHandle(eventData, toolIndex) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (toolData === undefined) {
            return;
        }

        var data = toolData.data[toolIndex];
        if (data.handles === undefined) {
            return;
        }

        var mousePoint = eventData.currentPoints.canvas;
        for (var i = 0; i < data.handles.length; i++) {
            var handleCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles[i]);
            if (cornerstoneMath.point.distance(handleCanvas, mousePoint) < 5) {
                return i;
            }
        }

        return;
    }

    function pointNearHandleAllTools(eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        var handleNearby;
        for (var toolIndex = 0; toolIndex < toolData.data.length; toolIndex++) {
            handleNearby = pointNearHandle(eventData, toolIndex);
            if (handleNearby !== undefined) {
                return {
                    handleNearby: handleNearby,
                    toolIndex: toolIndex
                };
            }
        }
    }

    // --- Drawing loop ---
    // On first click, add point
    // After first click, on mouse move, record location
    // If mouse comes close to previous point, snap to it
    // On next click, add another point -- continuously
    // On each click, if it intersects with a current point, end drawing loop

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);

        // Check if drawing is finished
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (toolData === undefined) {
            return;
        }

        var config = cornerstoneTools.freehand.getConfiguration();

        if (!eventData.event.shiftKey) {
            config.freehand = false;
        }

        cornerstone.updateImage(eventData.element);
    }

    function mouseMoveCallback(e, eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        var config = cornerstoneTools.freehand.getConfiguration();

        var data = toolData.data[config.currentTool];

        // Set the mouseLocation handle
        var x = Math.max(eventData.currentPoints.image.x, 0);
        x = Math.min(x, eventData.image.width);
        config.mouseLocation.handles.start.x = x;

        var y = Math.max(eventData.currentPoints.image.y, 0);
        y = Math.min(y, eventData.image.height);
        config.mouseLocation.handles.start.y = y;

        var currentHandle = config.currentHandle;

        if (config.modifying) {
            // Move the handle
            data.active = true;
            data.highlight = true;
            data.handles[currentHandle].x = config.mouseLocation.handles.start.x;
            data.handles[currentHandle].y = config.mouseLocation.handles.start.y;
            if (currentHandle) {
                var lastLineIndex = data.handles[currentHandle - 1].lines.length - 1;
                var lastLine = data.handles[currentHandle - 1].lines[lastLineIndex];
                lastLine.x = config.mouseLocation.handles.start.x;
                lastLine.y = config.mouseLocation.handles.start.y;
            }
        }

        if (config.freehand) {
            data.handles[currentHandle - 1].lines.push(eventData.currentPoints.image);
        } else {
            // No snapping in freehand mode
            var handleNearby = pointNearHandle(eventData, config.currentTool);

            // If there is a handle nearby to snap to
            // (and it's not the actual mouse handle)
            if (handleNearby !== undefined && handleNearby < (data.handles.length - 1)) {
                config.mouseLocation.handles.start.x = data.handles[handleNearby].x;
                config.mouseLocation.handles.start.y = data.handles[handleNearby].y;
            }
        }

        // Force onImageRendered
        cornerstone.updateImage(eventData.element);
    }

    function startDrawing(eventData) {
        $(eventData.element).on('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);

        var measurementData = {
            visible: true,
            active: true,
            handles: []
        };

        var config = cornerstoneTools.freehand.getConfiguration();
        config.mouseLocation.handles.start.x = eventData.currentPoints.image.x;
        config.mouseLocation.handles.start.y = eventData.currentPoints.image.y;

        cornerstoneTools.addToolState(eventData.element, toolType, measurementData);

        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        config.currentTool = toolData.data.length - 1;
    }

    function endDrawing(eventData, handleNearby) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        var config = cornerstoneTools.freehand.getConfiguration();

        var data = toolData.data[config.currentTool];

        data.active = false;
        data.highlight = false;

        // Connect the end of the drawing to the handle nearest to the click
        if (handleNearby !== undefined){
            data.handles[config.currentHandle - 1].lines.push(data.handles[handleNearby]);
        }

        if (config.modifying) {
            config.modifying = false;
        }

        // Reset the current handle
        config.currentHandle = 0;
        config.currentTool = -1;

        $(eventData.element).off('CornerstoneToolsMouseMove', mouseMoveCallback);

        cornerstone.updateImage(eventData.element);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            var toolData = cornerstoneTools.getToolState(eventData.element, toolType);

            var handleNearby, toolIndex;

            var config = cornerstoneTools.freehand.getConfiguration();
            var currentTool = config.currentTool;

            if (config.modifying) {
                endDrawing(eventData);
                return;
            }

            if (currentTool < 0) {
                var nearby = pointNearHandleAllTools(eventData);
                if (nearby) {
                    handleNearby = nearby.handleNearby;
                    toolIndex = nearby.toolIndex;
                    // This means the user is trying to modify a point
                    if (handleNearby !== undefined) {
                        $(eventData.element).on('CornerstoneToolsMouseMove', mouseMoveCallback);
                        $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
                        config.modifying = true;
                        config.currentHandle = handleNearby;
                        config.currentTool = toolIndex;
                    }
                } else {
                    startDrawing(eventData);
                    addPoint(eventData);
                }
            } else if (currentTool >= 0 && toolData.data[currentTool].active) {
                handleNearby = pointNearHandle(eventData, currentTool);
                if (handleNearby !== undefined) {
                    endDrawing(eventData, handleNearby);
                } else if (eventData.event.shiftKey) {
                    config.freehand = true;
                } else {
                    addPoint(eventData);
                }
            }

            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    ///////// END ACTIVE TOOL ///////

    ///////// BEGIN IMAGE RENDERING ///////
    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        var config = cornerstoneTools.freehand.getConfiguration();

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var fillColor = cornerstoneTools.toolColors.getFillColor();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            var data = toolData.data[i];

            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
                fillColor = cornerstoneTools.toolColors.getFillColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
                fillColor = cornerstoneTools.toolColors.getToolColor();
            }

            var handleStart;

            if (data.handles.length) {
                for (var j = 0; j < data.handles.length; j++) {
                    // Draw a line between handle j and j+1
                    handleStart = data.handles[j];
                    var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, handleStart);

                    context.beginPath();
                    context.strokeStyle = color;
                    context.lineWidth = lineWidth;
                    context.moveTo(handleStartCanvas.x, handleStartCanvas.y);

                    for (var k = 0; k < data.handles[j].lines.length; k++) {
                        var lineCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles[j].lines[k]);
                        context.lineTo(lineCanvas.x, lineCanvas.y);
                        context.stroke();
                    }

                    var mouseLocationCanvas = cornerstone.pixelToCanvas(eventData.element, config.mouseLocation.handles.start);
                    if (j === (data.handles.length - 1)) {
                        if (data.active && !config.freehand && !config.modifying) {
                            // If it's still being actively drawn, keep the last line to 
                            // the mouse location
                            context.lineTo(mouseLocationCanvas.x, mouseLocationCanvas.y);
                            context.stroke();
                        }
                    }
                }
            }
            
            // If the tool is active, draw a handle at the cursor location
            if (data.active){
                cornerstoneTools.drawHandles(context, eventData, config.mouseLocation.handles, color, fillColor);
            }
            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color, fillColor);

            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////
    function enable(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        $(element).on('CornerstoneImageRendered', onImageRendered);
        cornerstone.updateImage(element);
    }

    // disables the reference line tool for the given element
    function disable(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);
        cornerstone.updateImage(element);
    }

    // visible and interactive
    function activate(element, mouseButtonMask) {
        var eventData = {
            mouseButtonMask: mouseButtonMask,
        };

        $(element).off('CornerstoneToolsMouseDown', eventData, mouseDownCallback);
        $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        $(element).on('CornerstoneImageRendered', onImageRendered);
        $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);

        cornerstone.updateImage(element);
    }

    // visible, but not interactive
    function deactivate(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        $(element).on('CornerstoneImageRendered', onImageRendered);

        cornerstone.updateImage(element);
    }

    function getConfiguration() {
        return configuration;
    }

    function setConfiguration(config) {
        configuration = config;
    }

    // module/private exports
    cornerstoneTools.freehand = {
        enable: enable,
        disable: disable,
        activate: activate,
        deactivate: deactivate,
        getConfiguration: getConfiguration,
        setConfiguration: setConfiguration
    };

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/freehand.js

// Begin Source: src/imageTools/highlight.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'highlight';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        //if already a highlight measurement, creating a new one will be useless
        var existingToolData = cornerstoneTools.getToolState(mouseEventData.event.currentTarget, toolType);
        if (existingToolData && existingToolData.data && existingToolData.data.length > 0) {
            return;
        }
    
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointInsideRect(element, data, coords) {
        var startCanvas = cornerstone.pixelToCanvas(element, data.handles.start);
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);

        var rect = {
            left: Math.min(startCanvas.x, endCanvas.x),
            top: Math.min(startCanvas.y, endCanvas.y),
            width: Math.abs(startCanvas.x - endCanvas.x),
            height: Math.abs(startCanvas.y - endCanvas.y)
        };

        var insideBox = false;
        if ((coords.x >= rect.left && coords.x <= (rect.left + rect.width)) && coords.y >= rect.top && coords.y <= (rect.top + rect.height)) {
            insideBox = true;
        }

        return insideBox;
    }

    function pointNearTool(element, data, coords) {
        var startCanvas = cornerstone.pixelToCanvas(element, data.handles.start);
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);

        var rect = {
            left: Math.min(startCanvas.x, endCanvas.x),
            top: Math.min(startCanvas.y, endCanvas.y),
            width: Math.abs(startCanvas.x - endCanvas.x),
            height: Math.abs(startCanvas.y - endCanvas.y)
        };

        var distanceToPoint = cornerstoneMath.rect.distanceToPoint(rect, coords);
        return (distanceToPoint < 5);
    }

    ///////// BEGIN IMAGE RENDERING ///////

    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this elemen
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();

        context.save();

        var data = toolData.data[0];

        if (!data) {
            return;
        }

        if (data.active) {
            color = cornerstoneTools.toolColors.getActiveColor();
        } else {
            color = cornerstoneTools.toolColors.getToolColor();
        }

        var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
        var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

        var rect = {
            left: Math.min(handleStartCanvas.x, handleEndCanvas.x),
            top: Math.min(handleStartCanvas.y, handleEndCanvas.y),
            width: Math.abs(handleStartCanvas.x - handleEndCanvas.x),
            height: Math.abs(handleStartCanvas.y - handleEndCanvas.y)
        };

        // draw dark fill outside the rectangle
        context.beginPath();
        context.strokeStyle = 'transparent';

        context.rect(0, 0, context.canvas.clientWidth, context.canvas.clientHeight);

        context.rect(rect.width + rect.left, rect.top, -rect.width, rect.height);
        context.stroke();
        // context.fillStyle = 'rgba(0,0,0,0.7)';//sj Authorize

        context.fillStyle = 'rgba(0,0,0,0.0)';//sj Authorize
        context.fill();
        context.closePath();

        // draw dashed stroke rectangle
        context.beginPath();
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.setLineDash([ 4 ]);
        context.strokeRect(rect.left, rect.top, rect.width, rect.height);

        // Strange fix, but restore doesn't seem to reset the line dashes?
        context.setLineDash([]);
        
        // draw the handles last, so they will be on top of the overlay
        cornerstoneTools.drawHandles(context, eventData, data.handles, color);
        context.restore();
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    var preventHandleOutsideImage = true;

    cornerstoneTools.highlight = cornerstoneTools.mouseButtonRectangleTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        pointInsideRect: pointInsideRect,
        toolType: toolType
    }, preventHandleOutsideImage);
    
    cornerstoneTools.highlightTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        pointInsideRect: pointInsideRect,
        toolType: toolType
    }, preventHandleOutsideImage);

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/highlight.js

// Begin Source: src/imageTools/keyboardTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function keyboardTool(keyDownCallback) {
        var configuration = {};

        var toolInterface = {
            activate: function(element) {
                $(element).off('CornerstoneToolsKeyDown', keyDownCallback);
                $(element).on('CornerstoneToolsKeyDown', keyDownCallback);
            },
            disable: function(element) {$(element).off('CornerstoneToolsKeyDown', keyDownCallback);},
            enable: function(element) {$(element).off('CornerstoneToolsKeyDown', keyDownCallback);},
            deactivate: function(element) {$(element).off('CornerstoneToolsKeyDown', keyDownCallback);},
            getConfiguration: function() { return configuration; },
            setConfiguration: function(config) {configuration = config;}
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.keyboardTool = keyboardTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/keyboardTool.js

// Begin Source: src/imageTools/lengthTool.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'length';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointNearTool(element, data, coords) {

        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.end)
        };
        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        //return (distanceToPoint < 25);
        //zyy add
        var R;
        if(cornerstoneTools.recognizeR === undefined){
            R = 25;
        }else{
            R = cornerstoneTools.recognizeR;    // jshint ignore:line
        }
        return (distanceToPoint < R);
        //zyy add end
    }

    ///////// BEGIN IMAGE RENDERING ///////
    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (!toolData) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var config = cornerstoneTools.length.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            // configurable shadow
            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];
            var color = cornerstoneTools.toolColors.getColorIfActive(data.active);

            // Get the handle positions in canvas coordinates
            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            // Draw the measurement line
            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;
            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);
            context.stroke();

            // Draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color);

            // Draw the text
            context.fillStyle = color;
            //sjdrawruler
            // Set rowPixelSpacing and columnPixelSpacing to 1 if they are undefined (or zero)
            var dx = (data.handles.end.x - data.handles.start.x) * (eventData.image.columnPixelSpacing || 1);
            var dy = (data.handles.end.y - data.handles.start.y) * (eventData.image.rowPixelSpacing || 1);

            // Calculate the length, and create the text variable with the millimeters or pixels suffix            
            var length = Math.sqrt(dx * dx + dy * dy);

            // Set the length text suffix depending on whether or not pixelSpacing is available
            var suffix = ' mm';
            if (!eventData.image.rowPixelSpacing || !eventData.image.columnPixelSpacing) {
                suffix = ' pixels';
            }

            // Store the length measurement text
            var text = '' + length.toFixed(1) + suffix;//zyy changed 2 to 1

            // Place the length measurement text next to the right-most handle
            var fontSize = cornerstoneTools.textStyle.getFontSize();
            var textCoords = {
                x: Math.max(handleStartCanvas.x, handleEndCanvas.x),
            };

            // Depending on which handle has the largest x-value, 
            // set the y-value for the text box
            if (textCoords.x === handleStartCanvas.x) {
                textCoords.y = handleStartCanvas.y;
            } else {
                textCoords.y = handleEndCanvas.y;
            }

            // Move the textbox slightly to the right and upwards
            // so that it sits beside the length tool handle
            textCoords.x += 10;
            textCoords.y -= fontSize / 2 + 7;

            // Draw the textbox
            cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);

            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.length = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

    cornerstoneTools.lengthTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/lengthTool.js

//局部放大
// Begin Source: src/imageTools/magnify.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var configuration = {
        magnifySize: 400,//放大后的size
        magnificationLevel: 2//放大倍数
    };

    var browserName;

    /** Remove the magnifying glass when the mouse event ends */
    function mouseUpCallback(e, eventData) {

        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);

        // $(eventData.element).off('CornerstoneToolsClick', mouseUpCallback);

        hideTool(eventData);
    }

    function hideTool(eventData) {
        $(eventData.element).find('.magnifyTool').hide();
        // Re-enable the mouse cursor
        document.body.style.cursor = 'default';
    }

    /** Draw the magnifying glass on mouseDown, and begin tracking mouse movements */
    function mouseDownCallback(e, eventData) {

        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseUp', eventData, mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseDrag', eventData, dragCallback);

            // $(eventData.element).on('CornerstoneToolsClick', eventData, mouseUpCallback);

            drawMagnificationTool(eventData);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    function dragEndCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsDragEnd', dragEndCallback);
        $(eventData.element).off('CornerstoneToolsTouchEnd', dragEndCallback);
        hideTool(eventData);
    }

    /** Drag callback is triggered by both the touch and mouse magnify tools */
    function dragCallback(e, eventData) {

        drawMagnificationTool(eventData);
        if (eventData.isTouchEvent === true) {
            $(eventData.element).on('CornerstoneToolsDragEnd', dragEndCallback);
            $(eventData.element).on('CornerstoneToolsTouchEnd', dragEndCallback);
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    /** Draws the magnifying glass *///放大镜
    function drawMagnificationTool(eventData) {

        var magnify = $(eventData.element).find('.magnifyTool').get(0);

        if (!magnify) {
            createMagnificationCanvas(eventData.element);
        }

        var config = cornerstoneTools.magnify.getConfiguration();

        var magnifySize = config.magnifySize;
        var magnificationLevel = config.magnificationLevel;

        // The 'not' magnifyTool class here is necessary because cornerstone places
        // no classes of it's own on the canvas we want to select
        var canvas = $(eventData.element).find('canvas').not('.magnifyTool').get(0);
        var context = canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var zoomCtx = magnify.getContext('2d');
        zoomCtx.setTransform(1, 0, 0, 1, 0, 0);

        var getSize = magnifySize / magnificationLevel;

        // Calculate the on-canvas location of the mouse pointer / touch
        var canvasLocation = cornerstone.pixelToCanvas(eventData.element, eventData.currentPoints.image);

        if (eventData.isTouchEvent === true) {
            canvasLocation.y -= 1.25 * getSize;
        }

        canvasLocation.x = Math.max(canvasLocation.x, 0);
        canvasLocation.x = Math.min(canvasLocation.x, canvas.width);

        canvasLocation.y = Math.max(canvasLocation.y, 0);
        canvasLocation.y = Math.min(canvasLocation.y, canvas.height);

        // Clear the rectangle
        zoomCtx.clearRect(0, 0, magnifySize, magnifySize);
        zoomCtx.fillStyle = 'transparent';

        // Fill it with the pixels that the mouse is clicking on
        zoomCtx.fillRect(0, 0, magnifySize, magnifySize);
        
        var copyFrom = {
            x: canvasLocation.x - 0.5 * getSize,
            y: canvasLocation.y - 0.5 * getSize
        };

        if (browserName === 'Safari') {
            // Safari breaks when trying to copy pixels with negative indices
            // This prevents proper Magnify usage
            copyFrom.x = Math.max(copyFrom.x, 0);
            copyFrom.y = Math.max(copyFrom.y, 0);
        }

        copyFrom.x = Math.min(copyFrom.x, canvas.width);
        copyFrom.y = Math.min(copyFrom.y, canvas.height);

        var scaledMagnify = {
            x: (canvas.width - copyFrom.x) * magnificationLevel,
            y: (canvas.height - copyFrom.y) * magnificationLevel
        };
        zoomCtx.drawImage(canvas, copyFrom.x, copyFrom.y, canvas.width - copyFrom.x, canvas.height - copyFrom.y, 0, 0, scaledMagnify.x, scaledMagnify.y);

        // Place the magnification tool at the same location as the pointer
        magnify.style.top = canvasLocation.y - 0.5 * magnifySize + 'px';
        magnify.style.left = canvasLocation.x - 0.5 * magnifySize + 'px';

        magnify.style.display = 'block';

        // Hide the mouse cursor, so the user can see better
        document.body.style.cursor = 'none';
    }

    /** Creates the magnifying glass canvas */
    function createMagnificationCanvas(element) {

        // If the magnifying glass canvas doesn't already exist
        if ($(element).find('.magnifyTool').length === 0) {
            // Create a canvas and append it as a child to the element
            var magnify = document.createElement('canvas');
            // The magnifyTool class is used to find the canvas later on
            magnify.classList.add('magnifyTool');

            var config = cornerstoneTools.magnify.getConfiguration();
            magnify.width = config.magnifySize;
            magnify.height = config.magnifySize;

            // Make sure position is absolute so the canvas can follow the mouse / touch
            magnify.style.position = 'absolute';
            //sj  magnify add
            magnify.style.backgroundColor='blue';
            magnify.style.border='1px deepskyblue solid';//修改canvas 边框颜色，边框linewidth
            //sj magnify add end
            element.appendChild(magnify);
        }
    }

    /** Find the magnifying glass canvas and remove it */
    function removeMagnificationCanvas(element) {

        $(element).find('.magnifyTool').remove();
    }

    // --- Mouse tool activate / disable --- //
    function disable(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        removeMagnificationCanvas(element);
    }

    function enable(element) {
        var config = cornerstoneTools.magnify.getConfiguration(config);

        if (!browserName) {
            var infoString = cornerstoneTools.getBrowserInfo();
            var info = infoString.split(' ');
            browserName = info[0];
        }

        createMagnificationCanvas(element);
    }

    function activate(element, mouseButtonMask) {
        var eventData = {
            mouseButtonMask: mouseButtonMask,
        };

        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);

        $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);
        createMagnificationCanvas(element);
    }

    // --- Touch tool activate / disable --- //
    function getConfiguration() {
        return configuration;
    }

    function setConfiguration(config) {
        configuration = config;
    }

    // module exports
    cornerstoneTools.magnify = {
        enable: enable,
        activate: activate,
        deactivate: disable,
        disable: disable,
        getConfiguration: getConfiguration,
        setConfiguration: setConfiguration
    };

    var options = {
        fireOnTouchStart: true,
        activateCallback: createMagnificationCanvas,
        disableCallback: removeMagnificationCanvas
    };
    cornerstoneTools.magnifyTouchDrag = cornerstoneTools.touchDragTool(dragCallback, options);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/magnify.js

// Begin Source: src/imageTools/multiTouchDragTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function multiTouchDragTool(touchDragCallback) {
        var configuration = {};
        var events = 'CornerstoneToolsMultiTouchDrag';
        
        var toolInterface = {
            activate: function(element) {
                $(element).off(events, touchDragCallback);
                $(element).on(events, touchDragCallback);
            },
            disable: function(element) {
                $(element).off(events, touchDragCallback);
            },
            enable: function(element) {
                $(element).off(events, touchDragCallback);
            },
            deactivate: function(element) {
                $(element).off(events, touchDragCallback);
            },
            getConfiguration: function() {
                return configuration;
            },
            setConfiguration: function(config) {
                configuration = config;
            }
        };
        return toolInterface;
    }

    // module exports
    cornerstoneTools.multiTouchDragTool = multiTouchDragTool;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/multiTouchDragTool.js

// Begin Source: src/imageTools/orientationMarkers.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function getOrientationMarkers(element) {
        var enabledElement = cornerstone.getEnabledElement(element);
        var imagePlaneMetaData = cornerstoneTools.metaData.get('imagePlane', enabledElement.image.imageId);

        if (!imagePlaneMetaData || !imagePlaneMetaData.rowCosines || !imagePlaneMetaData.columnCosines) {
            return;
        }

        var rowString = cornerstoneTools.orientation.getOrientationString(imagePlaneMetaData.rowCosines);
        var columnString = cornerstoneTools.orientation.getOrientationString(imagePlaneMetaData.columnCosines);

        var oppositeRowString = cornerstoneTools.orientation.invertOrientationString(rowString);
        var oppositeColumnString = cornerstoneTools.orientation.invertOrientationString(columnString);

        return {
            top: oppositeColumnString,
            bottom: columnString,
            left: oppositeRowString,
            right: rowString
        };
    }

    function getOrientationMarkerPositions(element) {
        var enabledElement = cornerstone.getEnabledElement(element);
        var coords;

        coords = {
            x: enabledElement.image.width / 2,
            y: 5
        };
        var topCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: enabledElement.image.width / 2,
            y: enabledElement.image.height - 5
        };
        var bottomCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: 5,
            y: enabledElement.image.height / 2
        };
        var leftCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: enabledElement.image.width - 10,
            y: enabledElement.image.height / 2
        };
        var rightCoords = cornerstone.pixelToCanvas(element, coords);

        return {
            top: topCoords,
            bottom: bottomCoords,
            left: leftCoords,
            right: rightCoords
        };
    }
    
    function onImageRendered(e, eventData) {
        var element = eventData.element;

        var markers = getOrientationMarkers(element);
        // console.log("markers===================================");
        // console.log(markers);
        if (!markers) {
            return;
        }

        var coords = getOrientationMarkerPositions(element, markers);
        //sj add
        var viewport = deepCopy1(cornerstone.getViewport(element));
        var translation = viewport.translation;
        var scale = viewport.scale;
        //sj add end

        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);
        // context.scale(scale, scale);
        //sj add

        var color = cornerstoneTools.toolColors.getToolColor();
        color = 'white';//这个强行
        var textWidths = {
            top: context.measureText(markers.top).width,
            left: context.measureText(markers.left).width,
            right: context.measureText(markers.right).width,
            bottom: context.measureText(markers.bottom).width
        };
        var font="15px Arxial";
        var fontSize=15;


          //markertop
          cornerstoneTools.drawMarkTextBox(context,font,fontSize, markers.top, coords.top.x - textWidths.top / 2, coords.top.y, color);
          //markerleft
          cornerstoneTools.drawMarkTextBox(context,font,fontSize, markers.left, coords.left.x - textWidths.left / 2, coords.left.y, color);

      //会多绘制一个L方向
          /*  if(printStruct.openFlag==false){
            var config = cornerstoneTools.orientationMarkers.getConfiguration();
            if (config && config.drawAllMarkers) {
                cornerstoneTools.drawMarkTextBox(context,font,fontSize, markers.right, coords.right.x - textWidths.right / 2, coords.right.y, color);
                cornerstoneTools.drawMarkTextBox(context, font,fontSize, markers.bottom, coords.bottom.x - textWidths.bottom / 2, coords.bottom.y, color);
            }
        }*/



    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.orientationMarkers = cornerstoneTools.displayTool(onImageRendered);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/orientationMarkers.js

//sj add
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function getOrientationMarkers(element) {
        var enabledElement = cornerstone.getEnabledElement(element);
        var imagePlaneMetaData = cornerstoneTools.metaData.get('imagePlane', enabledElement.image.imageId);

        if (!imagePlaneMetaData || !imagePlaneMetaData.rowCosines || !imagePlaneMetaData.columnCosines) {
            return;
        }

        var rowString = cornerstoneTools.orientation.getOrientationString(imagePlaneMetaData.rowCosines);
        var columnString = cornerstoneTools.orientation.getOrientationString(imagePlaneMetaData.columnCosines);

        var oppositeRowString = cornerstoneTools.orientation.invertOrientationString(rowString);
        var oppositeColumnString = cornerstoneTools.orientation.invertOrientationString(columnString);

        return {
            top: oppositeColumnString,
            bottom: columnString,
            left: oppositeRowString,
            right: rowString
        };
    }

    function getOrientationMarkerPositions(element) {
        var enabledElement = cornerstone.getEnabledElement(element);
        var coords;

        coords = {
            x: enabledElement.image.width / 2,
            y: 5
        };
        var topCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: enabledElement.image.width / 2,
            y: enabledElement.image.height - 5
        };
        var bottomCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: 5,
            y: enabledElement.image.height / 2
        };
        var leftCoords = cornerstone.pixelToCanvas(element, coords);

        coords = {
            x: enabledElement.image.width - 10,
            y: enabledElement.image.height / 2
        };
        var rightCoords = cornerstone.pixelToCanvas(element, coords);

        return {
            top: topCoords,
            bottom: bottomCoords,
            left: leftCoords,
            right: rightCoords
        };
    }

    function onImageRendered(e, eventData) {
        var element = eventData.element;

        var markers = getOrientationMarkers(element);
        // console.log("markers===================================");
        // console.log(markers);
        if (!markers) {
            return;
        }

        var coords = getOrientationMarkerPositions(element, markers);
        //sj add
        var viewport = deepCopy1(cornerstone.getViewport(element));
        var translation = viewport.translation;
        var scale = viewport.scale;
        //sj add end

        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);
        // context.scale(scale, scale);
        //sj add

        var color = cornerstoneTools.toolColors.getToolColor();
        color = 'white';//这个强行
        var textWidths = {
            top: context.measureText(markers.top).width,
            left: context.measureText(markers.left).width,
            right: context.measureText(markers.right).width,
            bottom: context.measureText(markers.bottom).width
        };
        var font="15px Arxial";
        var fontSize=15;


        //markertop
        cornerstoneTools.drawMarkTextBox(context,font,fontSize, "标尺下", coords.bottom.x - textWidths.bottom / 2, coords.bottom.y, color);
        //markerleft
        cornerstoneTools.drawMarkTextBox(context,font,fontSize, "标尺右", coords.right.x - textWidths.right / 2, coords.right.y, color);

        //会多绘制一个L方向
        /*  if(printStruct.openFlag==false){
         var config = cornerstoneTools.orientationMarkers.getConfiguration();
         if (config && config.drawAllMarkers) {
         cornerstoneTools.drawMarkTextBox(context,font,fontSize, markers.right, coords.right.x - textWidths.right / 2, coords.right.y, color);
         cornerstoneTools.drawMarkTextBox(context, font,fontSize, markers.bottom, coords.bottom.x - textWidths.bottom / 2, coords.bottom.y, color);
         }
         }*/



    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.drarRuler = cornerstoneTools.displayTool(onImageRendered);

})($, cornerstone, cornerstoneTools);
//sj add end
// Begin Source: src/imageTools/pan.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', dragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }
    
    function dragCallback(e, eventData) {//console.log(eventData);//Object {which: 1, viewport: Object, image: Object, element: div#ele1461598669454rTZJ1LQ6.viewport.ui-droppable, startPoints: Object…}
        var scale =  eventData.viewport.scale * cornerstone.diy.iniScaleCal(eventData);
        eventData.viewport.translation.x += (eventData.deltaPoints.page.x / scale);
        eventData.viewport.translation.y += (eventData.deltaPoints.page.y / scale);
        cornerstone.setViewport(eventData.element, eventData.viewport);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    cornerstoneTools.pan = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.panTouchDrag = cornerstoneTools.touchDragTool(dragCallback);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/pan.js

// Begin Source: src/imageTools/panMultiTouch.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function touchPanCallback(e, eventData) {
        var config = cornerstoneTools.panMultiTouch.getConfiguration();
        if (config && config.testPointers(eventData)) {
			 var scale =  eventData.viewport.scale * cornerstone.diy.iniScaleCal(eventData)
            eventData.viewport.translation.x += (eventData.deltaPoints.page.x / scale);
            eventData.viewport.translation.y += (eventData.deltaPoints.page.y / scale);
            cornerstone.setViewport(eventData.element, eventData.viewport);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    var configuration = {
        testPointers: function(eventData) {
            return (eventData.numPointers >= 2);//
        }
    };

    cornerstoneTools.panMultiTouch = cornerstoneTools.multiTouchDragTool(touchPanCallback);
    cornerstoneTools.panMultiTouch.setConfiguration(configuration);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/panMultiTouch.js

// Begin Source: src/imageTools/probe.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'probe';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };
        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    ///////// BEGIN IMAGE RENDERING ///////
    function pointNearTool(element, data, coords) {
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);
        //return cornerstoneMath.point.distance(endCanvas, coords) < 5;
        return cornerstoneMath.point.distance(endCanvas, coords) < 1.2;
    }

    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (!toolData) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color;
        var font = cornerstoneTools.textStyle.getFont();
        var fontHeight = cornerstoneTools.textStyle.getFontSize();

        for (var i = 0; i < toolData.data.length; i++) {

            context.save();
            var data = toolData.data[i];
            
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color,undefined,{R:1.2});

            var x = Math.round(data.handles.end.x);
            var y = Math.round(data.handles.end.y);
            var storedPixels;

            var text,
                str;

            if (x < 0 || y < 0 || x >= eventData.image.columns || y >= eventData.image.rows) {
                return;
            }

            if (eventData.image.color) {
                text = '' + x + ', ' + y;
                storedPixels = cornerstoneTools.getRGBPixels(eventData.element, x, y, 1, 1);
                str = 'R: ' + storedPixels[0] + ' G: ' + storedPixels[1] + ' B: ' + storedPixels[2];
            } else {
                storedPixels = cornerstone.getStoredPixels(eventData.element, x, y, 1, 1);
                var sp = storedPixels[0];
                var mo = sp * eventData.image.slope + eventData.image.intercept;
                var suv = cornerstoneTools.calculateSUV(eventData.image, sp);

                // Draw text

                //sj change
                text ='X,Y: ' + x + ', ' + y;
                str='MO : '+parseFloat(mo.toFixed(1));
                var textwidth=  Math.max(context.measureText(text).width,context.measureText(str).width);
                /*
                text = '' + x + ', ' + y;
                //zyy change
                //str = 'SP: ' + sp + ' MO: ' + parseFloat(mo.toFixed(3));
                str = 'SP: ' + sp + ' MO: ' + parseFloat(mo.toFixed(1));
                if (suv) {
                    //str += ' SUV: ' + parseFloat(suv.toFixed(3));
                    str += ' SUV: ' + parseFloat(suv.toFixed(1));
                }
                */
                //sj change end
            }

            var coords = {
                // translate the x/y away from the cursor
                x: data.handles.end.x + 3,
                y: data.handles.end.y - 3
            };
            var textCoords = cornerstone.pixelToCanvas(eventData.element, coords);
            
            context.font = font;
            context.fillStyle = color;

            //sj change point
            cornerstoneTools.drawTextBox(context, text, textCoords.x+5, textCoords.y + fontHeight + 5, color,textwidth);
            cornerstoneTools.drawTextBox(context, str, textCoords.x+5, textCoords.y, color,textwidth);
            //sj change point end

            // cornerstoneTools.drawTextBox(context, str, textCoords.x, textCoords.y + fontHeight + 5, color);
            // cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);
            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.probe = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });
    cornerstoneTools.probeTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/probe.js

// Begin Source: src/imageTools/rectangleRoi.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'rectangleRoi';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointNearTool(element, data, coords) {
        var startCanvas = cornerstone.pixelToCanvas(element, data.handles.start);
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);

        var rect = {
            left: Math.min(startCanvas.x, endCanvas.x),
            top: Math.min(startCanvas.y, endCanvas.y),
            width: Math.abs(startCanvas.x - endCanvas.x),
            height: Math.abs(startCanvas.y - endCanvas.y)
        };

        var distanceToPoint = cornerstoneMath.rect.distanceToPoint(rect, coords);
        return (distanceToPoint < 5);
    }

    ///////// BEGIN IMAGE RENDERING ///////

    function calculateMeanStdDev(sp, ellipse) {
        // TODO: Get a real statistics library here that supports large counts

        var sum = 0;
        var sumSquared = 0;
        var count = 0;
        var index = 0;

        for (var y = ellipse.top; y < ellipse.top + ellipse.height; y++) {
            for (var x = ellipse.left; x < ellipse.left + ellipse.width; x++) {
                sum += sp[index];
                sumSquared += sp[index] * sp[index];
                count++;
                index++;
            }
        }

        if (count === 0) {
            return {
                count: count,
                mean: 0.0,
                variance: 0.0,
                stdDev: 0.0
            };
        }

        var mean = sum / count;
        var variance = sumSquared / count - mean * mean;

        return {
            count: count,
            mean: mean,
            variance: variance,
            stdDev: Math.sqrt(variance)
        };
    }

    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        //activation color 
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var fontHeight = cornerstoneTools.textStyle.getFontSize();
        
        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the rectangle
            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            var widthCanvas = Math.abs(handleStartCanvas.x - handleEndCanvas.x);
            var heightCanvas = Math.abs(handleStartCanvas.y - handleEndCanvas.y);
            var leftCanvas = Math.min(handleStartCanvas.x, handleEndCanvas.x);
            var topCanvas = Math.min(handleStartCanvas.y, handleEndCanvas.y);
            var centerX = (handleStartCanvas.x + handleEndCanvas.x) / 2;
            var centerY = (handleStartCanvas.y + handleEndCanvas.y) / 2;

            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;
            context.rect(leftCanvas, topCanvas, widthCanvas, heightCanvas);
            context.stroke();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color);

            // Calculate the mean, stddev, and area
            // TODO: calculate this in web worker for large pixel counts...

            var width = Math.abs(data.handles.start.x - data.handles.end.x);
            var height = Math.abs(data.handles.start.y - data.handles.end.y);
            var left = Math.min(data.handles.start.x, data.handles.end.x);
            var top = Math.min(data.handles.start.y, data.handles.end.y);
            var pixels = cornerstone.getPixels(eventData.element, left, top, width, height);

            var ellipse = {
                left: left,
                top: top,
                width: width,
                height: height
            };

            var meanStdDev = calculateMeanStdDev(pixels, ellipse);
            var area = (width * eventData.image.columnPixelSpacing) * (height * eventData.image.rowPixelSpacing);
          //  console.log(eventData.image.columnPixelSpacing,height * eventData.image.rowPixelSpacing);
            // console.log("area1:"+area);
            //var areaText = 'Area: ' + area.toFixed(2) + ' mm^2';//这尼玛呀^2都出来了
            var areaText = 'Area: ' + area.toFixed(0) + ' mm' + String.fromCharCode(178);
            // Draw text
            context.font = font;
            // console.log("area:"+area);
            var textSize = context.measureText(area);
            //sj change
            // var textX = centerX < (eventData.image.columns / 2) ? centerX + (widthCanvas / 2) +15: centerX - (widthCanvas / 2) - textSize.width;//加15处理，调整标识位置
            // var textY = centerY < (eventData.image.rows / 2) ? centerY + (heightCanvas / 2): centerY - (heightCanvas / 2);
            //把标识统一到右侧
            var textX = handleEndCanvas.x>handleStartCanvas.x?handleEndCanvas.x+10:handleStartCanvas.x+10;
            var textY = handleEndCanvas.y>handleStartCanvas.y?handleEndCanvas.y+10:handleStartCanvas.y+10;
            //sj change end
            context.fillStyle = color;

            // //cornerstoneTools.drawTextBox(context, 'Mean: ' + meanStdDev.mean.toFixed(2), textX, textY - fontHeight - 5, color);
            // cornerstoneTools.drawTextBox(context, 'Mean: ' + meanStdDev.mean.toFixed(1), textX, textY - fontHeight - 5, color);
            // //cornerstoneTools.drawTextBox(context, 'StdDev: ' + meanStdDev.stdDev.toFixed(2), textX, textY, color);
            // cornerstoneTools.drawTextBox(context, 'StdDev: ' + meanStdDev.stdDev.toFixed(1), textX, textY, color);
            // cornerstoneTools.drawTextBox(context, areaText, textX, textY + fontHeight + 5, color);


            //sj change rect
            var str1='Mean: ' + meanStdDev.mean.toFixed(1);
            var str2='StdDev: ' + meanStdDev.stdDev.toFixed(1);
            var textwidth=  Math.max(context.measureText(str1).width,context.measureText(str2).width);
            textwidth= Math.max(width,context.measureText(areaText).width);
            cornerstoneTools.drawTextBox(context, 'Mean: ' + meanStdDev.mean.toFixed(1), textX, textY - fontHeight - 5, color,textwidth);//1
            cornerstoneTools.drawTextBox(context, 'StdDev: ' + meanStdDev.stdDev.toFixed(1), textX, textY, color,textwidth);//2
            // console.log("xxxxx:"+areaText);
            cornerstoneTools.drawTextBox(context, areaText, textX, textY + fontHeight + 5, color,textwidth);//3
            //sj change rect end


            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.rectangleRoi = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });
    cornerstoneTools.rectangleRoiTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/rectangleRoi.js

// Begin Source: src/imageTools/rotate.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // --- Strategies --- //
    function defaultStrategy(eventData) {
        // Calculate distance from the center of the image
        var rect = eventData.element.getBoundingClientRect(eventData.element);

        var points = {
            x: eventData.currentPoints.client.x,
            y: eventData.currentPoints.client.y
        };

        var width = eventData.element.clientWidth;
        var height = eventData.element.clientHeight;

        var pointsFromCenter = {
            x: points.x - rect.left - width / 2,
            // Invert the coordinate system so that up is positive
            y: -1 * (points.y - rect.top - height / 2)
        };

        var rotationRadians = Math.atan2(pointsFromCenter.y, pointsFromCenter.x);
        var rotationDegrees = rotationRadians * (180 / Math.PI);
        var rotation = -1 * rotationDegrees + 90;
        eventData.viewport.rotation = rotation;
        cornerstone.setViewport(eventData.element, eventData.viewport);
    }

    function horizontalStrategy(eventData) {
        eventData.viewport.rotation += (eventData.deltaPoints.page.x / eventData.viewport.scale);
        cornerstone.setViewport(eventData.element, eventData.viewport);
    }

    function verticalStrategy(eventData) {
        eventData.viewport.rotation += (eventData.deltaPoints.page.y / eventData.viewport.scale);
        cornerstone.setViewport(eventData.element, eventData.viewport);
    }

    // --- Mouse event callbacks --- //
    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', dragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    function dragCallback(e, eventData) {
        cornerstoneTools.rotate.strategy(eventData);
        cornerstone.setViewport(eventData.element, eventData.viewport);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    cornerstoneTools.rotate = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.rotate.strategies = {
        default: defaultStrategy,
        horizontal: horizontalStrategy,
        vertical: verticalStrategy
    };
    
    cornerstoneTools.rotate.strategy = defaultStrategy;

    cornerstoneTools.rotateTouchDrag = cornerstoneTools.touchDragTool(dragCallback);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/rotate.js

// Begin Source: src/imageTools/rotateTouch.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function touchRotateCallback(e, eventData) {
        eventData.viewport.rotation += eventData.rotation;
        cornerstone.setViewport(eventData.element, eventData.viewport);
        return false;
    }

    function disable(element) {
        $(element).off('CornerstoneToolsTouchRotate', touchRotateCallback);
    }

    function activate(element) {
        $(element).off('CornerstoneToolsTouchRotate', touchRotateCallback);
        $(element).on('CornerstoneToolsTouchRotate', touchRotateCallback);
    }

    cornerstoneTools.rotateTouch = {
        activate: activate,
        disable: disable
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/rotateTouch.js

// Begin Source: src/imageTools/saveImage.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function saveAs(element, filename) {
        var canvas = $(element).find('canvas').get(0);

        // Thanks to Ken Fyrstenber
        // http://stackoverflow.com/questions/18480474/how-to-save-an-image-from-canvas
        var lnk = document.createElement('a');

        /// the key here is to set the download attribute of the a tag
        lnk.download = filename;

        /// convert canvas content to data-uri for link. When download
        /// attribute is set the content pointed to by link will be
        /// pushed as 'download' in HTML5 capable browsers
        lnk.href = canvas.toDataURL();

        /// create a 'fake' click-event to trigger the download
        if (document.createEvent) {

            var e = document.createEvent('MouseEvents');
            e.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

            lnk.dispatchEvent(e);

        } else if (lnk.fireEvent) {

            lnk.fireEvent('onclick');
        }
    }

    cornerstoneTools.saveAs = saveAs;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/saveImage.js

// Begin Source: src/imageTools/simpleAngle.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'simpleAngle';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var angleData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                middle: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                }
            }
        };

        return angleData;
    }
    ///////// END ACTIVE TOOL ///////

    function pointNearTool(element, data, coords) {
        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.middle)
        };

        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        if (distanceToPoint < 25) {
            return true;
        }

        lineSegment.start = cornerstone.pixelToCanvas(element, data.handles.middle);
        lineSegment.end = cornerstone.pixelToCanvas(element, data.handles.end);

        distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        return (distanceToPoint < 25);
    }

    function length(vector) {
        return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
    }

    ///////// BEGIN IMAGE RENDERING ///////
    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);
        
        //activation color 
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.simpleAngle.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the line
            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;

            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleMiddleCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.middle);

            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleMiddleCanvas.x, handleMiddleCanvas.y);

            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);
            context.stroke();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles, color);

            // Draw the text
            context.fillStyle = color;

            // Default to isotropic pixel size, update suffix to reflect this
            var columnPixelSpacing = eventData.image.columnPixelSpacing || 1;
            var rowPixelSpacing = eventData.image.rowPixelSpacing || 1;
            var suffix = '';
            if (!eventData.image.rowPixelSpacing || !eventData.image.columnPixelSpacing) {
                suffix = ' (isotropic)';
            }

            var sideA = {
                x: (Math.ceil(data.handles.middle.x) - Math.ceil(data.handles.start.x)) * columnPixelSpacing,
                y: (Math.ceil(data.handles.middle.y) - Math.ceil(data.handles.start.y)) * rowPixelSpacing
            };

            var sideB = {
                x: (Math.ceil(data.handles.end.x) - Math.ceil(data.handles.middle.x)) * columnPixelSpacing,
                y: (Math.ceil(data.handles.end.y) - Math.ceil(data.handles.middle.y)) * rowPixelSpacing
            };

            var sideC = {
                x: (Math.ceil(data.handles.end.x) - Math.ceil(data.handles.start.x)) * columnPixelSpacing,
                y: (Math.ceil(data.handles.end.y) - Math.ceil(data.handles.start.y)) * rowPixelSpacing
            };

            var sideALength = length(sideA);
            var sideBLength = length(sideB);
            var sideCLength = length(sideC);

            // Cosine law
            var angle = Math.acos((Math.pow(sideALength, 2) + Math.pow(sideBLength, 2) - Math.pow(sideCLength, 2)) / (2 * sideALength * sideBLength));
            angle = angle * (180 / Math.PI);

            var rAngle = cornerstoneTools.roundToDecimal(angle, 2);

            if (rAngle) {
                var str = '00B0'; // degrees symbol
                var text = rAngle.toString() + String.fromCharCode(parseInt(str, 16)) + suffix;
                
                var distance = 15;

                var textX = handleMiddleCanvas.x + distance;
                var textY = handleMiddleCanvas.y + distance;

                context.font = font;
                var textWidth = context.measureText(text).width;

                if ((handleMiddleCanvas.x - handleStartCanvas.x) < 0) {
                    textX = handleMiddleCanvas.x - distance - textWidth - 10;
                } else {
                    textX = handleMiddleCanvas.x + distance;
                }

                textY = handleMiddleCanvas.y;
                cornerstoneTools.drawTextBox(context, text, textX, textY, color);
            }

            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    ///////// BEGIN ACTIVE TOOL ///////
    function addNewMeasurement(mouseEventData) {
        var measurementData = createNewMeasurement(mouseEventData);
        var element = mouseEventData.element;

        var eventData = {
            mouseButtonMask: mouseEventData.which,
        };

        // associate this data with this imageId so we can render it and manipulate it
        cornerstoneTools.addToolState(element, toolType, measurementData);

        // since we are dragging to another place to drop the end point, we can just activate
        // the end point and let the moveHandle move it for us.
        $(element).off('CornerstoneToolsMouseMove', cornerstoneTools.simpleAngle.mouseMoveCallback);
        $(element).off('CornerstoneToolsMouseDrag', cornerstoneTools.simpleAngle.mouseMoveCallback);
        $(element).off('CornerstoneToolsMouseDown', cornerstoneTools.simpleAngle.mouseDownCallback);
        $(element).off('CornerstoneToolsMouseDownActivate', cornerstoneTools.simpleAngle.mouseDownActivateCallback);
        cornerstone.updateImage(element);

        cornerstoneTools.moveNewHandle(mouseEventData, toolType, measurementData, measurementData.handles.middle, function() {
            measurementData.active = false;
            if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                // delete the measurement
                cornerstoneTools.removeToolState(element, toolType, measurementData);
            }

            measurementData.handles.end.active = true;
            cornerstone.updateImage(element);

            cornerstoneTools.moveNewHandle(mouseEventData, toolType, measurementData, measurementData.handles.end, function() {
                measurementData.active = false;
                if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, toolType, measurementData);
                }

                $(element).on('CornerstoneToolsMouseMove', cornerstoneTools.simpleAngle.mouseMoveCallback);
                $(element).on('CornerstoneToolsMouseDrag', cornerstoneTools.simpleAngle.mouseMoveCallback);
                $(element).on('CornerstoneToolsMouseDown', eventData, cornerstoneTools.simpleAngle.mouseDownCallback);
                $(element).on('CornerstoneToolsMouseDownActivate', eventData, cornerstoneTools.simpleAngle.mouseDownActivateCallback);
                cornerstone.updateImage(element);
            });
        });
    }

    function addNewMeasurementTouch(touchEventData) {
        var measurementData = createNewMeasurement(touchEventData);
        var element = touchEventData.element;

        // associate this data with this imageId so we can render it and manipulate it
        cornerstoneTools.addToolState(element, toolType, measurementData);

        // since we are dragging to another place to drop the end point, we can just activate
        // the end point and let the moveHandle move it for us.
        $(element).off('CornerstoneToolsTouchDrag', cornerstoneTools.simpleAngleTouch.touchMoveCallback);
        $(element).off('CornerstoneToolsTouchStartActive', cornerstoneTools.simpleAngleTouch.touchDownActivateCallback);
        $(element).off('CornerstoneToolsTouchStart', cornerstoneTools.simpleAngleTouch.touchStartCallback);
        $(element).off('CornerstoneToolsTap', cornerstoneTools.simpleAngleTouch.tapCallback);
        cornerstone.updateImage(element);

        cornerstoneTools.moveNewHandleTouch(touchEventData, measurementData.handles.middle, function() {
            measurementData.active = false;
            if (cornerstoneTools.anyHandlesOutsideImage(touchEventData, measurementData.handles)) {
                // delete the measurement
                cornerstoneTools.removeToolState(element, toolType, measurementData);
            }

            measurementData.handles.end.active = true;
            cornerstone.updateImage(element);

            cornerstoneTools.moveNewHandleTouch(touchEventData, measurementData.handles.end, function() {
                measurementData.active = false;
                if (cornerstoneTools.anyHandlesOutsideImage(touchEventData, measurementData.handles)) {
                    // delete the measurement
                    cornerstoneTools.removeToolState(element, toolType, measurementData);
                }

                $(element).on('CornerstoneToolsTouchDrag', cornerstoneTools.simpleAngleTouch.touchMoveCallback);
                $(element).on('CornerstoneToolsTouchStart', cornerstoneTools.simpleAngleTouch.touchStartCallback);
                $(element).on('CornerstoneToolsTouchStartActive', cornerstoneTools.simpleAngleTouch.touchDownActivateCallback);
                $(element).on('CornerstoneToolsTap', cornerstoneTools.simpleAngleTouch.tapCallback);
                cornerstone.updateImage(element);
            });
        });
    }

    cornerstoneTools.simpleAngle = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        addNewMeasurement: addNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

    cornerstoneTools.simpleAngleTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        addNewMeasurement: addNewMeasurementTouch,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/simpleAngle.js

// Begin Source: src/imageTools/textMarker.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'textMarker';

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        var config = cornerstoneTools.textMarker.getConfiguration();

        if (!config.current) {
            return;
        }

        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            visible: true,
            active: true,
            text: config.current,
            handles: {
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };

        // Update the current marker for the next marker
        var currentIndex = config.markers.indexOf(config.current);
        if (config.ascending) {
            currentIndex += 1;
            if (currentIndex >= config.markers.length) {
                if (!config.loop) {
                    currentIndex = -1;
                } else {
                    currentIndex -= config.markers.length;
                }
            }
        } else {
            currentIndex -= 1;
            if (currentIndex < 0) {
                if (!config.loop) {
                    currentIndex = -1;
                } else {
                    currentIndex += config.markers.length;
                }
            }
        }

        config.current = config.markers[currentIndex];

        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    ///////// BEGIN IMAGE RENDERING ///////
    function pointNearTool(element, data, coords) {
        var endCanvas = cornerstone.pixelToCanvas(element, data.handles.end);

        var rect = {
            left: endCanvas.x - data.textWidth / 2,
            top: endCanvas.y,
            width: data.textWidth,
            height: data.textHeight
        };

        var distanceToPoint = cornerstoneMath.rect.distanceToPoint(rect, coords);
        return (distanceToPoint < 10);
    }

    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        // var font = cornerstoneTools.textStyle.getFont();
        // var fontSize = cornerstoneTools.textStyle.getFontSize();

        var config = cornerstoneTools.textMarker.getConfiguration();

        // console.log(config);
        var font=config.font;
        var fontSize=config.fontSize;
        for (var i = 0; i < toolData.data.length; i++) {
            var data = toolData.data[i];

            // var color = cornerstoneTools.toolColors.getToolColor();
            var color="#ffffff";
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            }

            context.save();

            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            // Draw text
            context.font = font;
            context.fillStyle = color;

            var measureText = context.measureText(data.text);
            data.textWidth = measureText.width;
            data.textHeight = fontSize;

            var coords = {
                x: data.handles.end.x,
                y: data.handles.end.y
            };

            var textCoords = cornerstone.pixelToCanvas(eventData.element, coords);
 
            // cornerstoneTools.drawTextBox(context,font,fontSize, data.text, textCoords.x - data.textWidth / 2, textCoords.y, color);
            cornerstoneTools.drawMarkTextBox(context,font,fontSize, data.text, textCoords.x - data.textWidth / 2, textCoords.y, color);
            context.restore();
        }
    }

    function doubleClickCallback(e, eventData) {
        var element = eventData.element;
        var data;

        function doneChangingTextCallback(data, updatedText, deleteTool) {
            if (deleteTool === true) {
                cornerstoneTools.removeToolState(element, toolType, data);
            } else {
                data.text = updatedText;
            }

            data.active = false;
            cornerstone.updateImage(element);
            $(element).on('CornerstoneToolsMouseMove', eventData, cornerstoneTools.textMarker.mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData, cornerstoneTools.textMarker.mouseDownCallback);
            $(element).on('CornerstoneToolsMouseDownActivate', eventData, cornerstoneTools.textMarker.mouseDownActivateCallback);
            $(element).on('CornerstoneToolsMouseDoubleClick', eventData, cornerstoneTools.textMarker.mouseDoubleClickCallback);
        }

        if (e.data && e.data.mouseButtonMask && !cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            return false;
        }

        var config = cornerstoneTools.textMarker.getConfiguration();

        var coords = eventData.currentPoints.canvas;
        var toolData = cornerstoneTools.getToolState(element, toolType);

        // now check to see if there is a handle we can move
        if (!toolData) {
            return false;
        }

        for (var i = 0; i < toolData.data.length; i++) {
            data = toolData.data[i];
            if (pointNearTool(element, data, coords)) {
                data.active = true;
                cornerstone.updateImage(element);

                $(element).off('CornerstoneToolsMouseMove', cornerstoneTools.textMarker.mouseMoveCallback);
                $(element).off('CornerstoneToolsMouseDown', cornerstoneTools.textMarker.mouseDownCallback);
                $(element).off('CornerstoneToolsMouseDownActivate', cornerstoneTools.textMarker.mouseDownActivateCallback);
                $(element).off('CornerstoneToolsMouseDoubleClick', cornerstoneTools.textMarker.mouseDoubleClickCallback);
                // Allow relabelling via a callback
                config.changeTextCallback(data, doneChangingTextCallback);
                
                e.stopImmediatePropagation();
                return false;
            }
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    function touchPressCallback(e, eventData) {
        var element = eventData.element;
        var data;

        function doneChangingTextCallback(data, updatedText, deleteTool) {
            if (deleteTool === true) {
                cornerstoneTools.removeToolState(element, toolType, data);
            } else {
                data.text = updatedText;
            }

            data.active = false;
            cornerstone.updateImage(element);
            $(element).off('CornerstoneToolsTouchDrag', cornerstoneTools.textMarkerTouch.touchMoveCallback);
            $(element).off('CornerstoneToolsTouchStartActive', cornerstoneTools.textMarkerTouch.touchDownActivateCallback);
            $(element).off('CornerstoneToolsTouchStart', cornerstoneTools.textMarkerTouch.touchStartCallback);
            $(element).off('CornerstoneToolsTap', cornerstoneTools.textMarkerTouch.tapCallback);
            $(element).off('CornerstoneToolsTouchPress', cornerstoneTools.textMarkerTouch.pressCallback);

            $(element).on('CornerstoneToolsTouchDrag', cornerstoneTools.textMarkerTouch.touchMoveCallback);
            $(element).on('CornerstoneToolsTouchStartActive', cornerstoneTools.textMarkerTouch.touchDownActivateCallback);
            $(element).on('CornerstoneToolsTouchStart', cornerstoneTools.textMarkerTouch.touchStartCallback);
            $(element).on('CornerstoneToolsTap', cornerstoneTools.textMarkerTouch.tapCallback);
            $(element).on('CornerstoneToolsTouchPress', cornerstoneTools.textMarkerTouch.pressCallback);
        }

        if (e.data && e.data.mouseButtonMask && !cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            return false;
        }

        var config = cornerstoneTools.textMarker.getConfiguration();

        var coords = eventData.currentPoints.canvas;
        var toolData = cornerstoneTools.getToolState(element, toolType);

        // now check to see if there is a handle we can move
        if (!toolData) {
            return false;
        }

        for (var i = 0; i < toolData.data.length; i++) {
            data = toolData.data[i];
            if (pointNearTool(element, data, coords)) {
                data.active = true;
                cornerstone.updateImage(element);

                $(element).off('CornerstoneToolsTouchDrag', cornerstoneTools.textMarkerTouch.touchMoveCallback);
                $(element).off('CornerstoneToolsTouchStartActive', cornerstoneTools.textMarkerTouch.touchDownActivateCallback);
                $(element).off('CornerstoneToolsTouchStart', cornerstoneTools.textMarkerTouch.touchStartCallback);
                $(element).off('CornerstoneToolsTap', cornerstoneTools.textMarkerTouch.tapCallback);
                $(element).off('CornerstoneToolsTouchPress', cornerstoneTools.textMarkerTouch.pressCallback);
                // Allow relabelling via a callback
                config.changeTextCallback(data, doneChangingTextCallback);
                
                e.stopImmediatePropagation();
                return false;
            }
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    cornerstoneTools.textMarker = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType,
        mouseDoubleClickCallback: doubleClickCallback
    });

    cornerstoneTools.textMarkerTouch = cornerstoneTools.touchTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType,
        pressCallback: touchPressCallback
    });

    ///////// END IMAGE RENDERING ///////

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/textMarker.js

// Begin Source: src/imageTools/wwwc.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', mouseDragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', mouseDragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            return false; // false = cases jquery to preventDefault() and stopPropagation() this event
        }
    }

    function defaultStrategy(eventData) {
        // here we normalize the ww/wc adjustments so the same number of on screen pixels
        // adjusts the same percentage of the dynamic range of the image.  This is needed to
        // provide consistency for the ww/wc tool regardless of the dynamic range (e.g. an 8 bit
        // image will feel the same as a 16 bit image would)
        var maxVOI = eventData.image.maxPixelValue * eventData.image.slope + eventData.image.intercept;
        var minVOI = eventData.image.minPixelValue * eventData.image.slope + eventData.image.intercept;
        var imageDynamicRange = maxVOI - minVOI;
        var multiplier = imageDynamicRange / 1024;

        var deltaX = eventData.deltaPoints.page.x * multiplier;
        var deltaY = eventData.deltaPoints.page.y * multiplier;

        eventData.viewport.voi.windowWidth += (deltaX);
        eventData.viewport.voi.windowCenter += (deltaY);
    }

    function mouseDragCallback(e, eventData) {
        cornerstoneTools.wwwc.strategy(eventData);
        cornerstone.setViewport(eventData.element, eventData.viewport);
        return false; // false = cases jquery to preventDefault() and stopPropagation() this event
    }

    function touchDragCallback(e, eventData) {
        e.stopImmediatePropagation(); // Prevent CornerstoneToolsTouchStartActive from killing any press events
        var dragData = eventData;

        var maxVOI = dragData.image.maxPixelValue * dragData.image.slope + dragData.image.intercept;
        var minVOI = dragData.image.minPixelValue * dragData.image.slope + dragData.image.intercept;
        var imageDynamicRange = maxVOI - minVOI;
        var multiplier = imageDynamicRange / 1024;
        var deltaX = dragData.deltaPoints.page.x * multiplier;
        var deltaY = dragData.deltaPoints.page.y * multiplier;

        var config = cornerstoneTools.wwwc.getConfiguration();
        if (config.orientation) {
            if (config.orientation === 0) {
                dragData.viewport.voi.windowWidth += (deltaX);
                dragData.viewport.voi.windowCenter += (deltaY);
            } else {
                dragData.viewport.voi.windowWidth += (deltaY);
                dragData.viewport.voi.windowCenter += (deltaX);
            }
        } else {
            dragData.viewport.voi.windowWidth += (deltaX);
            dragData.viewport.voi.windowCenter += (deltaY);
        }

        cornerstone.setViewport(dragData.element, dragData.viewport);
    }

    cornerstoneTools.wwwc = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.wwwc.strategies = {
        default: defaultStrategy
    };
    cornerstoneTools.wwwc.strategy = defaultStrategy;
    cornerstoneTools.wwwcTouchDrag = cornerstoneTools.touchDragTool(touchDragCallback);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/wwwc.js

// Begin Source: src/imageTools/wwwcRegion.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'wwwcRegion';

    var configuration = {
        minWindowWidth: 10
    };

    /** Calculates the minimum, maximum, and mean value in the given pixel array */
    function calculateMinMaxMean(storedPixelLuminanceData, globalMin, globalMax) {
        var numPixels = storedPixelLuminanceData.length;

        if (numPixels < 2) {
            return {
                min: globalMin,
                max: globalMax,
                mean: (globalMin + globalMax) / 2
            };
        }

        var min = globalMax;
        var max = globalMin;
        var sum = 0;

        for (var index = 0; index < numPixels; index++) {
            var spv = storedPixelLuminanceData[index];
            min = Math.min(min, spv);
            max = Math.max(max, spv);
            sum += spv;
        }

        return {
            min: min,
            max: max,
            mean: sum / numPixels
        };
    }

    /* Applies the windowing procedure when the mouse drag ends */
    function dragEndCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseMove', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', dragEndCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', dragEndCallback);
        
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        if (!toolData.data.length) {
            return;
        }

        // Update the endpoint as the mouse/touch is dragged
        var endPoint = {
            x: eventData.currentPoints.image.x,
            y: eventData.currentPoints.image.y
        };

        toolData.data[0].endPoint = endPoint;

        applyWWWCRegion(eventData);

        var mouseData = {
            mouseButtonMask: eventData.which
        };

        $(eventData.element).on('CornerstoneToolsMouseDown', mouseData, mouseDownCallback);
    }

    /** Calculates the minimum and maximum value in the given pixel array */
    function applyWWWCRegion(eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        if (!toolData.data.length) {
            return;
        }

        var startPoint = toolData.data[0].startPoint;
        var endPoint = toolData.data[0].endPoint;

        // Get the rectangular region defined by the handles
        var width = Math.abs(startPoint.x - endPoint.x);
        var height = Math.abs(startPoint.y - endPoint.y);

        var left = Math.min(startPoint.x, endPoint.x);
        var top = Math.min(startPoint.y, endPoint.y);

        // Bound the rectangle so we don't get undefined pixels
        left = Math.max(left, 0);
        left = Math.min(left, eventData.image.width);
        top = Math.max(top, 0);
        top = Math.min(top, eventData.image.height);
        width = Math.floor(Math.min(width, Math.abs(eventData.image.width - left)));
        height = Math.floor(Math.min(height, Math.abs(eventData.image.height - top)));

        // Get the pixel data in the rectangular region
        var pixelLuminanceData = cornerstoneTools.getLuminance(eventData.element, left, top, width, height);

        // Calculate the minimum and maximum pixel values
        var minMaxMean = calculateMinMaxMean(pixelLuminanceData, eventData.image.minPixelValue, eventData.image.maxPixelValue);

        // Adjust the viewport window width and center based on the calculated values
        var config = cornerstoneTools.wwwcRegion.getConfiguration();
        var viewport = cornerstone.getViewport(eventData.element);
        if (config.minWindowWidth === undefined) {
            config.minWindowWidth = 10;
        }

        viewport.voi.windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), config.minWindowWidth);
        viewport.voi.windowCenter = minMaxMean.mean;
        cornerstone.setViewport(eventData.element, viewport);

        // Clear the toolData
        toolData.data = [];

        cornerstone.updateImage(eventData.element);
    }

    function whichMovement(e, eventData) {
        var element = eventData.element;

        $(element).off('CornerstoneToolsMouseMove');
        $(element).off('CornerstoneToolsMouseDrag');

        $(element).on('CornerstoneToolsMouseMove', dragCallback);
        $(element).on('CornerstoneToolsMouseDrag', dragCallback);

        $(element).on('CornerstoneToolsMouseClick', dragEndCallback);
        if (e.type === 'CornerstoneToolsMouseDrag') {
            $(element).on('CornerstoneToolsMouseUp', dragEndCallback);
        }
    }

    /** Records the start point and attaches the drag event handler */
    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            $(eventData.element).on('CornerstoneToolsMouseDrag', eventData, whichMovement);
            $(eventData.element).on('CornerstoneToolsMouseMove', eventData, whichMovement);
            $(eventData.element).on('CornerstoneToolsMouseUp', dragEndCallback);

            $(eventData.element).off('CornerstoneToolsMouseDown');
            recordStartPoint(eventData);
            return false;
        }
    }

    /** Records the start point of the click or touch */
    function recordStartPoint(eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (toolData && toolData.data) {
            toolData.data = [];
        }

        var measurementData = {
            startPoint: {
                x: eventData.currentPoints.image.x,
                y: eventData.currentPoints.image.y
            }
        };

        cornerstoneTools.addToolState(eventData.element, toolType, measurementData);
    }

    /** Draws the rectangular region while the touch or mouse event drag occurs */
    function dragCallback(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (toolData === undefined) {
            return;
        }

        if (!toolData.data.length) {
            return;
        }

        // Update the endpoint as the mouse/touch is dragged
        var endPoint = {
            x: eventData.currentPoints.image.x,
            y: eventData.currentPoints.image.y
        };

        toolData.data[0].endPoint = endPoint;
        cornerstone.updateImage(eventData.element);
    }

    function onImageRendered(e, eventData) {
        var toolData = cornerstoneTools.getToolState(eventData.element, toolType);
        if (!toolData) {
            return;
        }

        if (!toolData.data.length) {
            return;
        }

        var startPoint = toolData.data[0].startPoint;
        var endPoint = toolData.data[0].endPoint;

        if (!startPoint || !endPoint) {
            return;
        }

        // Get the current element's canvas
        var canvas = $(eventData.element).find('canvas').get(0);
        var context = canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        // Set to the active tool color
        var color = cornerstoneTools.toolColors.getActiveColor();
        
        // Calculate the rectangle parameters
        var startPointCanvas = cornerstone.pixelToCanvas(eventData.element, startPoint);
        var endPointCanvas = cornerstone.pixelToCanvas(eventData.element, endPoint);

        var left = Math.min(startPointCanvas.x, endPointCanvas.x);
        var top = Math.min(startPointCanvas.y, endPointCanvas.y);
        var width = Math.abs(startPointCanvas.x - endPointCanvas.x);
        var height = Math.abs(startPointCanvas.y - endPointCanvas.y);

        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var config = cornerstoneTools.wwwcRegion.getConfiguration();

        // Draw the rectangle
        context.save();

        if (config && config.shadow) {
            context.shadowColor = config.shadowColor || '#000000';
            context.shadowOffsetX = config.shadowOffsetX || 1;
            context.shadowOffsetY = config.shadowOffsetY || 1;
        }

        context.beginPath();
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.rect(left, top, width, height);
        context.stroke();

        context.restore();
    }

    // --- Mouse tool enable / disable --- ///
    function disable(element) {
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        cornerstone.updateImage(element);
    }

    function activate(element, mouseButtonMask) {
        var eventData = {
            mouseButtonMask: mouseButtonMask,
        };

        var toolData = cornerstoneTools.getToolState(element, toolType);
        if (!toolData) {
            var data = [];
            cornerstoneTools.addToolState(element, toolType, data);
        }

        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneToolsMouseUp', dragEndCallback);
        $(element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        $(element).on('CornerstoneToolsMouseDown', eventData, mouseDownCallback);
        $(element).on('CornerstoneImageRendered', onImageRendered);
        cornerstone.updateImage(element);
    }

    // --- Touch tool enable / disable --- //
    function disableTouchDrag(element) {
        $(element).off('CornerstoneToolsTouchDrag', dragCallback);
        $(element).off('CornerstoneToolsTouchStart', recordStartPoint);
        $(element).off('CornerstoneToolsDragEnd', applyWWWCRegion);
        $(element).off('CornerstoneImageRendered', onImageRendered);
    }

    function activateTouchDrag(element) {
        var toolData = cornerstoneTools.getToolState(element, toolType);
        if (toolData === undefined) {
            var data = [];
            cornerstoneTools.addToolState(element, toolType, data);
        }

        $(element).off('CornerstoneToolsTouchDrag', dragCallback);
        $(element).off('CornerstoneToolsTouchStart', recordStartPoint);
        $(element).off('CornerstoneToolsDragEnd', applyWWWCRegion);
        $(element).off('CornerstoneImageRendered', onImageRendered);

        $(element).on('CornerstoneToolsTouchDrag', dragCallback);
        $(element).on('CornerstoneToolsTouchStart', recordStartPoint);
        $(element).on('CornerstoneToolsDragEnd', applyWWWCRegion);
        $(element).on('CornerstoneImageRendered', onImageRendered);
    }

    function getConfiguration() {
        return configuration;
    }

    function setConfiguration(config) {
        configuration = config;
    }

    // module exports
    cornerstoneTools.wwwcRegion = {
        activate: activate,
        deactivate: disable,
        disable: disable,
        setConfiguration: setConfiguration,
        getConfiguration: getConfiguration
    };

    cornerstoneTools.wwwcRegionTouch = {
        activate: activateTouchDrag,
        deactivate: disableTouchDrag,
        disable: disableTouchDrag
    };

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/imageTools/wwwcRegion.js

// Begin Source: src/imageTools/zoom.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var startPoints;

    function changeViewportScale(viewport, ticks) {
        var config = cornerstoneTools.zoom.getConfiguration();
        var pow = 1.7;
        
        var oldFactor = Math.log(viewport.scale) / Math.log(pow);
        var factor = oldFactor + ticks;
        
        var scale = Math.pow(pow, factor);
        if (config.maxScale && scale > config.maxScale) {
            viewport.scale = config.maxScale;
        } else if (config.minScale && scale < config.minScale) {
            viewport.scale = config.minScale;
        } else {
            viewport.scale = scale;
        }
        return viewport;
    }

    function boundPosition(position, width, height) {
        position.x = Math.max(position.x, 0);
        position.y = Math.max(position.y, 0);
        position.x = Math.min(position.x, width);
        position.y = Math.min(position.y, height);
        return position;
    }

    function correctShift(shift, viewport) {
        // Apply rotations
        if (viewport.rotation !== 0) {
            var angle = viewport.rotation * Math.PI / 180;
    
            var cosA = Math.cos(angle);
            var sinA = Math.sin(angle);
    
            var newX = shift.x * cosA - shift.y * sinA;
            var newY = shift.x * sinA + shift.y * cosA;

            shift.x = newX;
            shift.y = newY;
        }

        // Apply Flips        
        if (viewport.hflip) {
            shift.x *= -1;
        }

        if (viewport.vflip) {
            shift.y *= -1;
        }

        return shift;
    }
//缩放设置
    function defaultStrategy(eventData, ticks) {
        var element = eventData.element;

        // Calculate the new scale factor based on how far the mouse has changed
        var viewport = changeViewportScale(eventData.viewport, ticks);
        //sjdrawruler

        cornerstone.setViewport(element, viewport);
           // console.log($(element).parent());
         var rulerInfo=JSON.parse($(element).parent().attr('rulerInfo'));
         // console.log("1=======zoom call=========");
         // console.log(rulerInfo,viewport);
        $(element).parents('.seriesWindow').find('.viewportWrapper').each(function () {
            drawRuler($(this),rulerInfo,viewport.scale);//缩放时的比例尺同步缩放
        });

        //加上下面的代码，缩放是以鼠标点击位置为中心
        // Now that the scale has been updated, determine the offset we need to apply to the center so we can
        // keep the original start location in the same position
        /*
        var newCoords = cornerstone.pageToPixel(element, eventData.startPoints.page.x, eventData.startPoints.page.y);
        var shift = {
            x: eventData.startPoints.image.x - newCoords.x,
            y: eventData.startPoints.image.y - newCoords.y
        };

        shift = correctShift(shift, viewport);
        viewport.translation.x -= shift.x;
        viewport.translation.y -= shift.y;
        cornerstone.setViewport(element, viewport);
        */
    }

    function translateStrategy(eventData, ticks) {

        var element = eventData.element;
        var image = eventData.image;

        // Calculate the new scale factor based on how far the mouse has changed
        var viewport = changeViewportScale(eventData.viewport, ticks);
        cornerstone.setViewport(element, viewport);

        var config = cornerstoneTools.zoom.getConfiguration();
        var shift, newCoords;

        var outwardsTranslateSpeed = 8;
        var inwardsTranslateSpeed = 8;
        var outwardsMinScaleToTranslate = 3;
        var minTranslation = 0.01;

        if (ticks < 0) {
            // Zoom outwards from the image center
            shift = {
                x: viewport.scale < outwardsMinScaleToTranslate ? viewport.translation.x / outwardsTranslateSpeed : 0,
                y: viewport.scale < outwardsMinScaleToTranslate ? viewport.translation.y / outwardsTranslateSpeed : 0
            };
            
            if (Math.abs(viewport.translation.x) < minTranslation) {
                viewport.translation.x = 0;
                shift.x = 0;
            } else if (Math.abs(viewport.translation.y) < minTranslation) {
                viewport.translation.y = 0;
                shift.y = 0;
            } else if (Math.abs(viewport.translation.x) < minTranslation &&
                       Math.abs(viewport.translation.y) < minTranslation) {
                cornerstone.setViewport(element, viewport);
                return false;
            }
        } else {
            newCoords = cornerstone.pageToPixel(element, startPoints.page.x, startPoints.page.y);
            if (config && config.preventZoomOutsideImage) {
                startPoints.image = boundPosition(startPoints.image, image.width, image.height);
                newCoords = boundPosition(newCoords, image.width, image.height);
            }
            // Zoom inwards to the current image point
            var desiredTranslation = {
                x: image.width / 2 - startPoints.image.x,
                y: image.height / 2 - startPoints.image.y
            };

            var distanceToDesired = {
                x: viewport.translation.x - desiredTranslation.x,
                y: viewport.translation.y - desiredTranslation.y
            };

            shift = {
                x: distanceToDesired.x / inwardsTranslateSpeed,
                y: distanceToDesired.y / inwardsTranslateSpeed
            };

            if (Math.abs(distanceToDesired.x) < minTranslation) {
                viewport.translation.x = desiredTranslation.x;
                shift.x = 0;
            } else if (Math.abs(distanceToDesired.y) < minTranslation) {
                viewport.translation.y = desiredTranslation.y;
                shift.y = 0;
            } else if (Math.abs(distanceToDesired.x) < minTranslation &&
                       Math.abs(distanceToDesired.y) < minTranslation) {
                cornerstone.setViewport(element, viewport);
                return false;
            }
        }

        shift = correctShift(shift, viewport);
        if (!shift.x && !shift.y) {
            return false;
        }

        viewport.translation.x -= shift.x;
        viewport.translation.y -= shift.y;
        cornerstone.setViewport(element, viewport);
    }

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            startPoints = eventData.startPoints; // Used for translateStrategy
            $(eventData.element).on('CornerstoneToolsMouseDrag', dragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            return false; // false = cases jquery to preventDefault() and stopPropagation() this event
        }
    }

    function dragCallback(e, eventData) {
        if (!eventData.deltaPoints.page.y) {
            return false;
        }

        var ticks = eventData.deltaPoints.page.y / 100;
        cornerstoneTools.zoom.strategy(eventData, ticks);
        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    function mouseWheelCallback(e, eventData) {
        var ticks = -eventData.direction / 4;
        var viewport = changeViewportScale(eventData.viewport, ticks);
        cornerstone.setViewport(eventData.element, viewport);
    }

    function touchPinchCallback(e, eventData) {
        var config = cornerstoneTools.zoom.getConfiguration();
        var viewport = eventData.viewport;
        var element = eventData.element;

        // Change the scale based on the pinch gesture's scale change
        viewport.scale += eventData.scaleChange * viewport.scale;
        if (config.maxScale && viewport.scale > config.maxScale) {
            viewport.scale = config.maxScale;
        } else if (config.minScale && viewport.scale < config.minScale) {
            viewport.scale = config.minScale;
        }

        cornerstone.setViewport(element, viewport);

        // Now that the scale has been updated, determine the offset we need to apply to the center so we can
        // keep the original start location in the same position
        var newCoords = cornerstone.pageToPixel(element, eventData.startPoints.page.x, eventData.startPoints.page.y);
        var shift = {
            x: eventData.startPoints.image.x - newCoords.x,
            y: eventData.startPoints.image.y - newCoords.y
        };

        shift = correctShift(shift, viewport);
        viewport.translation.x -= shift.x;
        viewport.translation.y -= shift.y;
        cornerstone.setViewport(element, viewport);
    }

    cornerstoneTools.zoom = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.zoom.strategies = {
        default: defaultStrategy,
        translate: translateStrategy
    };
    cornerstoneTools.zoom.strategy = defaultStrategy;

    cornerstoneTools.zoomWheel = cornerstoneTools.mouseWheelTool(mouseWheelCallback);
    cornerstoneTools.zoomTouchPinch = cornerstoneTools.touchPinchTool(touchPinchCallback);
    cornerstoneTools.zoomTouchDrag = cornerstoneTools.touchDragTool(dragCallback);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/imageTools/zoom.js

// Begin Source: src/inputSources/keyboardInput.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var mouseX, mouseY;

    function keyPress(e) {
        var element = e.currentTarget;

        var keyPressData = {
            event: window.event || e, // old IE support
            element: element,
            viewport: cornerstone.getViewport(element),
            image: cornerstone.getEnabledElement(element).image,
            currentPoints: {
                page: {
                    x: mouseX,
                    y: mouseY
                },
                image: cornerstone.pageToPixel(element, mouseX, mouseY),
            },
            keyCode: e.keyCode,
            which: e.which
        };

        keyPressData.currentPoints.canvas = cornerstone.pixelToCanvas(element, keyPressData.currentPoints.image);

        var keyPressEvents = {
            keydown: 'CornerstoneToolsKeyDown',
            keypress: 'CornerstoneToolsKeyPress',
            keyup: 'CornerstoneToolsKeyUp',

        };

        $(element).trigger(keyPressEvents[e.type], keyPressData);
    }

    function mouseMove(e) {
        mouseX = e.pageX || e.originalEvent.pageX;
        mouseY = e.pageY || e.originalEvent.pageY;
    }

    var keyboardEvent = 'keydown keypress keyup';

    function enable(element) {
        // Prevent handlers from being attached multiple times
        disable(element);

        $(element).on(keyboardEvent, keyPress);
        $(element).on('mousemove', mouseMove);
    }

    function disable(element) {
        $(element).off(keyboardEvent, keyPress);
        $(element).off('mousemove', mouseMove);
    }

    // module exports
    cornerstoneTools.keyboardInput = {
        enable: enable,
        disable: disable
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/inputSources/keyboardInput.js

// Begin Source: src/inputSources/preventGhostClick.js
(function(cornerstoneTools) {

    'use strict';

    // Functions to prevent ghost clicks following a touch
    // All credit to @kosich
    // https://gist.github.com/kosich/23188dd86633b6c2efb7

    var antiGhostDelay = 2000,
        pointerType = {
            mouse: 0,
            touch: 1
        },
        lastInteractionType,
        lastInteractionTime;

    function handleTap(type, e) {
        var now = Date.now();
        if (type !== lastInteractionType) {
            if (now - lastInteractionTime <= antiGhostDelay) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }

            lastInteractionType = type;
        }

        lastInteractionTime = now;
    }

    // Cacheing the function references
    // Necessary because a new function reference is created after .bind() is called
    // http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind
    var handleTapMouse = handleTap.bind(null, pointerType.mouse);
    var handleTapTouch = handleTap.bind(null, pointerType.touch);

    function attachEvents(element, eventList, interactionType) {
        var tapHandler = interactionType ? handleTapMouse : handleTapTouch;
        eventList.forEach(function(eventName) {
            element.addEventListener(eventName, tapHandler, true);
        });
    }

    function removeEvents(element, eventList, interactionType) {
        var tapHandler = interactionType ? handleTapMouse : handleTapTouch;
        eventList.forEach(function(eventName) {
            element.removeEventListener(eventName, tapHandler, true);
        });
    }

    var mouseEvents = [ 'mousedown', 'mouseup' ];
    var touchEvents = [ 'touchstart', 'touchend' ];

    function disable(element) {
        removeEvents(element, mouseEvents, pointerType.mouse);
        removeEvents(element, touchEvents, pointerType.touch);
    }

    function enable(element) {
        disable(element);
        attachEvents(element, mouseEvents, pointerType.mouse);
        attachEvents(element, touchEvents, pointerType.touch);
    }

    cornerstoneTools.preventGhostClick = {
        enable: enable,
        disable: disable
    };

})(cornerstoneTools);
 
// End Source; src/inputSources/preventGhostClick.js

// Begin Source: src/manipulators/anyHandlesOutsideImage.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function anyHandlesOutsideImage(renderData, handles) {
        var image = renderData.image;
        var imageRect = {
            left: 0,
            top: 0,
            width: image.width,
            height: image.height
        };

        var handleOutsideImage = false;

        Object.keys(handles).forEach(function(name) {
            var handle = handles[name];
            if (handle.allowedOutsideImage === true) {
                return;
            }
            
            if (cornerstoneMath.point.insideRect(handle, imageRect) === false) {
                handleOutsideImage = true;
            }
        });

        return handleOutsideImage;
    }

    // module/private exports
    cornerstoneTools.anyHandlesOutsideImage = anyHandlesOutsideImage;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/manipulators/anyHandlesOutsideImage.js

// Begin Source: src/manipulators/drawHandles.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    var handleRadius = 6;

    function drawHandles(context, renderData, handles, color, fill,opts) {
        context.strokeStyle = color;
        if(!(!!opts))opts = {};
        Object.keys(handles).forEach(function(name) {
            var handle = handles[name];
            if (handle.drawnIndependently === true) {
                return;
            }

            context.beginPath();

            if (handle.active) {
                context.lineWidth = cornerstoneTools.toolStyle.getActiveWidth();
            } else {
                context.lineWidth = cornerstoneTools.toolStyle.getToolWidth();
            }

            var handleCanvasCoords = cornerstone.pixelToCanvas(renderData.element, handle);
            var R = opts.R?opts.R:cornerstoneTools.handleR||handleRadius;
            context.arc(handleCanvasCoords.x, handleCanvasCoords.y, R, 0, 2 * Math.PI);//zyy add cornerstoneTools.handleR

            if (fill) {
                context.fillStyle = fill;
                context.fill();
            }

            context.stroke();
        });
    }

    // module/private exports
    cornerstoneTools.drawHandles = drawHandles;

})(cornerstone, cornerstoneTools);
 
// End Source; src/manipulators/drawHandles.js

// Begin Source: src/manipulators/getHandleNearImagePoint.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function getHandleNearImagePoint(element, handles, coords, distanceThreshold) {
        var nearbyHandle;
        
        if (!handles) {
            return;
        }

        Object.keys(handles).forEach(function(name) {
            var handle = handles[name];
            if (handle.hasOwnProperty('pointNearHandle')) {
                if (handle.pointNearHandle(element, handle, coords)) {
                    nearbyHandle = handle;
                    return;
                }
            } else {
                var handleCanvas = cornerstone.pixelToCanvas(element, handle);
                var distance = cornerstoneMath.point.distance(handleCanvas, coords);
                if (distance <= distanceThreshold) {
                    nearbyHandle = handle;
                    return;
                }
            }
        });
        
        return nearbyHandle;
    }

    // module exports
    cornerstoneTools.getHandleNearImagePoint = getHandleNearImagePoint;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/manipulators/getHandleNearImagePoint.js

// Begin Source: src/manipulators/handleActivator.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function getActiveHandle(handles) {
        var activeHandle;

        Object.keys(handles).forEach(function(name) {
            var handle = handles[name];
            if (handle.active === true) {
                activeHandle = handle;
                return;
            }
        });

        return activeHandle;
    }

    function handleActivator(element, handles, canvasPoint, distanceThreshold) {
        if (!distanceThreshold) {
            distanceThreshold = 36;
        }

        var activeHandle = getActiveHandle(handles);
        var nearbyHandle = cornerstoneTools.getHandleNearImagePoint(element, handles, canvasPoint, distanceThreshold);
        if (activeHandle !== nearbyHandle) {
            if (nearbyHandle !== undefined) {
                nearbyHandle.active = true;
            }

            if (activeHandle !== undefined) {
                activeHandle.active = false;
            }

            return true;
        }

        return false;
    }

    // module/private exports
    cornerstoneTools.handleActivator = handleActivator;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/manipulators/handleActivator.js

// Begin Source: src/manipulators/moveAllHandles.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function moveAllHandles(mouseEventData, data, toolData, toolType, options, doneMovingCallback) {
        var element = mouseEventData.element;

        function mouseDragCallback(e, eventData) {
            data.active = true;

            Object.keys(data.handles).forEach(function(name) {
                var handle = data.handles[name];
                if (handle.movesIndependently === true) {
                    return;
                }

                handle.x += eventData.deltaPoints.image.x;
                handle.y += eventData.deltaPoints.image.y;
                
                if (options.preventHandleOutsideImage === true) {
                    handle.x = Math.max(handle.x, 0);
                    handle.x = Math.min(handle.x, eventData.image.width);

                    handle.y = Math.max(handle.y, 0);
                    handle.y = Math.min(handle.y, eventData.image.height);
                }
            });

            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);

            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }

        $(element).on('CornerstoneToolsMouseDrag', mouseDragCallback);

        function mouseUpCallback(e, eventData) {
            data.active = false;
            data.invalidated = true;

            $(element).off('CornerstoneToolsMouseDrag', mouseDragCallback);
            $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
            $(element).off('CornerstoneToolsMouseClick', mouseUpCallback);

            // If any handle is outside the image, delete the tool data
            if (options.deleteIfHandleOutsideImage === true) {
                var image = eventData.image;
                var handleOutsideImage = false;
                var rect = {
                    top: 0,
                    left: 0,
                    width: image.width,
                    height: image.height
                };
                
                Object.keys(data.handles).forEach(function(name) {
                    var handle = data.handles[name];
                    handle.active = false;
                    if (cornerstoneMath.point.insideRect(handle, rect) === false) {
                        handleOutsideImage = true;
                        return false;
                    }
                });

                if (handleOutsideImage) {
                    // find this tool data
                    var indexOfData = -1;
                    toolData.data.forEach(function(thisToolData, index) {
                        if (thisToolData === data) {
                            indexOfData = index;
                            return false;
                        }
                    });

                    if (indexOfData !== -1) {
                        toolData.data.splice(indexOfData, 1);
                    }
                }
            }

            cornerstone.updateImage(element);

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }
        }

        $(element).on('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).on('CornerstoneToolsMouseClick', mouseUpCallback);
        return true;
    }

    // module/private exports
    cornerstoneTools.moveAllHandles = moveAllHandles;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/manipulators/moveAllHandles.js

// Begin Source: src/manipulators/moveHandle.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function moveHandle(mouseEventData, toolType, data, handle, doneMovingCallback, preventHandleOutsideImage) {
        var element = mouseEventData.element;
        var distanceFromTool = {
            x: handle.x - mouseEventData.currentPoints.image.x,
            y: handle.y - mouseEventData.currentPoints.image.y
        };

        function mouseDragCallback(e, eventData) {
            handle.active = true;
            handle.x = eventData.currentPoints.image.x + distanceFromTool.x;
            handle.y = eventData.currentPoints.image.y + distanceFromTool.y;

            if (preventHandleOutsideImage) {
                handle.x = Math.max(handle.x, 0);
                handle.x = Math.min(handle.x, eventData.image.width);

                handle.y = Math.max(handle.y, 0);
                handle.y = Math.min(handle.y, eventData.image.height);
            }

            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);
        }

        $(element).on('CornerstoneToolsMouseDrag', mouseDragCallback);

        //艹.....我想从新定义mouseUp都不得行咯
        function mouseUpCallback() {
            handle.active = false;
            $(element).off('CornerstoneToolsMouseDrag', mouseDragCallback);
            $(element).off('CornerstoneToolsMouseUp', mouseUpCallback);
            $(element).off('CornerstoneToolsMouseClick', mouseUpCallback);
            cornerstone.updateImage(element);

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }
        }

        $(element).on('CornerstoneToolsMouseUp', mouseUpCallback);
        $(element).on('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    // module/private exports
    cornerstoneTools.moveHandle = moveHandle;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/manipulators/moveHandle.js

// Begin Source: src/manipulators/moveNewHandle.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function moveNewHandle(mouseEventData, toolType, data, handle, doneMovingCallback, preventHandleOutsideImage) {
        var element = mouseEventData.element;

        function moveCallback(e, eventData) {
            handle.active = true;
            handle.x = eventData.currentPoints.image.x;
            handle.y = eventData.currentPoints.image.y;
            
            if (preventHandleOutsideImage) {
                handle.x = Math.max(handle.x, 0);
                handle.x = Math.min(handle.x, eventData.image.width);

                handle.y = Math.max(handle.y, 0);
                handle.y = Math.min(handle.y, eventData.image.height);
            }

            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);
        }

        function whichMovement(e) {
            $(element).off('CornerstoneToolsMouseMove');
            $(element).off('CornerstoneToolsMouseDrag');

            $(element).on('CornerstoneToolsMouseMove', moveCallback);
            $(element).on('CornerstoneToolsMouseDrag', moveCallback);
            
            $(element).on('CornerstoneToolsMouseClick', moveEndCallback);
            if (e.type === 'CornerstoneToolsMouseDrag') {
                $(element).on('CornerstoneToolsMouseUp', moveEndCallback);
            }
        }

        function measurementRemovedCallback(e, eventData) {
            if (eventData.measurementData === data) {
                moveEndCallback();
            }
        }

        $(element).on('CornerstoneToolsMouseDrag', whichMovement);
        $(element).on('CornerstoneToolsMouseMove', whichMovement);
        $(element).on('CornerstoneToolsMeasurementRemoved', measurementRemovedCallback);

        function moveEndCallback() {
            $(element).off('CornerstoneToolsMouseMove', moveCallback);
            $(element).off('CornerstoneToolsMouseDrag', moveCallback);
            $(element).off('CornerstoneToolsMouseClick', moveEndCallback);
            $(element).off('CornerstoneToolsMouseUp', moveEndCallback);
            $(element).off('CornerstoneToolsMeasurementRemoved', measurementRemovedCallback);

            handle.active = false;
            cornerstone.updateImage(element);

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }
        }
    }

    // module/private exports
    cornerstoneTools.moveNewHandle = moveNewHandle;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/manipulators/moveNewHandle.js

// Begin Source: src/manipulators/moveNewHandleTouch.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function moveNewHandleTouch(eventData, toolType, data, handle, doneMovingCallback, preventHandleOutsideImage) {
        var element = eventData.element;
        var imageCoords = cornerstone.pageToPixel(element, eventData.currentPoints.page.x, eventData.currentPoints.page.y + 50);
        var distanceFromTouch = {
            x: handle.x - imageCoords.x,
            y: handle.y - imageCoords.y
        };

        function moveCallback(e, eventData) {
            handle.active = true;
            handle.x = eventData.currentPoints.image.x + distanceFromTouch.x;
            handle.y = eventData.currentPoints.image.y + distanceFromTouch.y;
            
            if (preventHandleOutsideImage) {
                handle.x = Math.max(handle.x, 0);
                handle.x = Math.min(handle.x, eventData.image.width);

                handle.y = Math.max(handle.y, 0);
                handle.y = Math.min(handle.y, eventData.image.height);
            }

            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);
        }
        
        function moveEndCallback(e, eventData) {
            $(element).off('CornerstoneToolsTouchDrag', moveCallback);
            $(element).off('CornerstoneToolsTouchPinch', moveEndCallback);
            $(element).off('CornerstoneToolsTouchPress', moveEndCallback);
            $(element).off('CornerstoneToolsTouchEnd', moveEndCallback);
            $(element).off('CornerstoneToolsDragEnd', moveEndCallback);
            $(element).off('CornerstoneToolsTap', moveEndCallback);

            if (e.type === 'CornerstoneToolsTouchPinch' || e.type === 'CornerstoneToolsTouchPress') {
                handle.active = false;
                cornerstone.updateImage(element);
                doneMovingCallback();
                return;
            }

            handle.active = false;
            handle.x = eventData.currentPoints.image.x + distanceFromTouch.x;
            handle.y = eventData.currentPoints.image.y + distanceFromTouch.y;
            
            if (preventHandleOutsideImage) {
                handle.x = Math.max(handle.x, 0);
                handle.x = Math.min(handle.x, eventData.image.width);

                handle.y = Math.max(handle.y, 0);
                handle.y = Math.min(handle.y, eventData.image.height);
            }

            cornerstone.updateImage(element);

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }
        }

        $(element).on('CornerstoneToolsTouchDrag', moveCallback);
        $(element).on('CornerstoneToolsTouchPinch', moveEndCallback);
        $(element).on('CornerstoneToolsTouchPress', moveEndCallback);
        $(element).on('CornerstoneToolsTouchEnd', moveEndCallback);
        $(element).on('CornerstoneToolsDragEnd', moveEndCallback);
        $(element).on('CornerstoneToolsTap', moveEndCallback);
    }

    // module/private exports
    cornerstoneTools.moveNewHandleTouch = moveNewHandleTouch;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/manipulators/moveNewHandleTouch.js

// Begin Source: src/manipulators/touchMoveAllHandles.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function touchMoveAllHandles(touchEventData, data, toolData, toolType, deleteIfHandleOutsideImage, doneMovingCallback) {
        //console.log('touchMoveAllHandles');
        var element = touchEventData.element;

        function touchDragCallback(e, eventData) {
            //console.log('touchMoveAllHandles touchDragCallback');
            data.active = true;
            
            Object.keys(data.handles).forEach(function(name) {
                var handle = data.handles[name];
                if (handle.movesIndependently === true) {
                    return;
                }
                
                handle.x += eventData.deltaPoints.image.x;
                handle.y += eventData.deltaPoints.image.y;
            });
            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);

            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }

        $(element).on('CornerstoneToolsTouchDrag', touchDragCallback);

        function touchEndCallback(e, eventData) {
            //console.log('touchMoveAllHandles touchEndCallback');
            data.active = false;
            data.invalidated = false;

            $(element).off('CornerstoneToolsTouchDrag', touchDragCallback);
            $(element).off('CornerstoneToolsTouchPinch', touchEndCallback);
            $(element).off('CornerstoneToolsTouchPress', touchEndCallback);
            $(element).off('CornerstoneToolsTouchEnd', touchEndCallback);
            $(element).off('CornerstoneToolsDragEnd', touchEndCallback);
            $(element).off('CornerstoneToolsTap', touchEndCallback);

            // If any handle is outside the image, delete the tool data
            if (deleteIfHandleOutsideImage === true) {
                var image = eventData.image;
                var handleOutsideImage = false;
                var rect = {
                    top: 0,
                    left: 0,
                    width: image.width,
                    height: image.height
                };
                
                Object.keys(data.handles).forEach(function(name) {
                    var handle = data.handles[name];
                    if (cornerstoneMath.point.insideRect(handle, rect) === false) {
                        handleOutsideImage = true;
                        return;
                    }
                });

                if (handleOutsideImage) {
                    // find this tool data
                    var indexOfData = -1;
                    for (var i = 0; i < toolData.data.length; i++) {
                        if (toolData.data[i] === data) {
                            indexOfData = i;
                        }
                    }

                    if (indexOfData !== -1) {
                        toolData.data.splice(indexOfData, 1);
                    }
                }
            }

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }

            cornerstone.updateImage(element);
        }

        $(element).on('CornerstoneToolsTouchPinch', touchEndCallback);
        $(element).on('CornerstoneToolsTouchPress', touchEndCallback);
        $(element).on('CornerstoneToolsTouchEnd', touchEndCallback);
        $(element).on('CornerstoneToolsDragEnd', touchEndCallback);
        $(element).on('CornerstoneToolsTap', touchEndCallback);
        return true;
    }

    // module/private exports
    cornerstoneTools.touchMoveAllHandles = touchMoveAllHandles;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/manipulators/touchMoveAllHandles.js

// Begin Source: src/manipulators/touchMoveHandle.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function touchMoveHandle(touchEventData, toolType, data, handle, doneMovingCallback) {
        //console.log('touchMoveHandle');
        var element = touchEventData.element;
        var distanceFromTouch = {
            x: handle.x - touchEventData.currentPoints.image.x,
            y: handle.y - touchEventData.currentPoints.image.y
        };

        function touchDragCallback(e, eventData) {
            handle.active = true;
            var touchMoveData = eventData;
            handle.x = touchMoveData.currentPoints.image.x + distanceFromTouch.x;
            handle.y = touchMoveData.currentPoints.image.y + distanceFromTouch.y;
            cornerstone.updateImage(element);

            var eventType = 'CornerstoneToolsMeasurementModified';
            var modifiedEventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, modifiedEventData);
        }

        $(element).on('CornerstoneToolsTouchDrag', touchDragCallback);

        function touchEndCallback() {
            handle.active = false;
            $(element).off('CornerstoneToolsTouchDrag', touchDragCallback);
            $(element).off('CornerstoneToolsTouchPinch', touchEndCallback);
            $(element).off('CornerstoneToolsTouchEnd', touchEndCallback);
            $(element).off('CornerstoneToolsDragEnd', touchEndCallback);
            $(element).off('CornerstoneToolsTap', touchEndCallback);
            cornerstone.updateImage(element);

            if (typeof doneMovingCallback === 'function') {
                doneMovingCallback();
            }
        }

        $(element).on('CornerstoneToolsTouchPinch', touchEndCallback);
        $(element).on('CornerstoneToolsTouchEnd', touchEndCallback);
        $(element).on('CornerstoneToolsDragEnd', touchEndCallback);
        $(element).on('CornerstoneToolsTap', touchEndCallback);
    }

    // module/private exports
    cornerstoneTools.touchMoveHandle = touchMoveHandle;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/manipulators/touchMoveHandle.js

// Begin Source: src/measurementManager/lineSample.js
(function($, cornerstoneTools) {

    'use strict';

    // This object manages a collection of measurements
    function LineSampleMeasurement() {

        var that = this;
        that.samples = [];

        // adds an element as both a source and a target
        this.set = function(samples) {
            that.samples = samples;
            // fire event
            $(that).trigger('CornerstoneLineSampleUpdated');
        };
    }

    // module/private exports
    cornerstoneTools.LineSampleMeasurement = LineSampleMeasurement;

})($, cornerstoneTools);
 
// End Source; src/measurementManager/lineSample.js

// Begin Source: src/measurementManager/measurementManager.js
(function($, cornerstoneTools) {

    'use strict';

    // This object manages a collection of measurements
    function MeasurementManager() {

        var that = this;
        that.measurements = [];

        // adds an element as both a source and a target
        this.add = function(measurement) {
            var index = that.measurements.push(measurement);
            // fire event
            var eventDetail = {
                index: index,
                measurement: measurement
            };
            $(that).trigger('CornerstoneMeasurementAdded', eventDetail);
        };

        this.remove = function(index) {
            var measurement = that.measurements[index];
            that.measurements.splice(index, 1);
            // fire event
            var eventDetail = {
                index: index,
                measurement: measurement
            };
            $(that).trigger('CornerstoneMeasurementRemoved', eventDetail);
        };

    }

    // module/private exports
    cornerstoneTools.MeasurementManager = new MeasurementManager();

})($, cornerstoneTools);
 
// End Source; src/measurementManager/measurementManager.js

// Begin Source: src/metaData.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // this module defines a way for tools to access various metadata about an imageId.  This layer of abstraction exists
    // so metadata can be provided to the tools in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)
    // NOTE: We may want to push this function down into the cornerstone core library, not sure yet...

    var providers = [];

    function addProvider( provider) {
        providers.push(provider);
    }

    function removeProvider( provider) {
        var index = providers.indexOf(provider);
        if (index === -1) {
            return;
        }

        providers.splice(index, 1);
    }

    function getMetaData(type, imageId) {
        var result;
        $.each(providers, function(index, provider) {
            result = provider(type, imageId);
            if (result !== undefined) {
                return true;
            }
        });
        return result;
    }

    // module/private exports
    cornerstoneTools.metaData = {
        addProvider: addProvider,
        removeProvider: removeProvider,
        get: getMetaData
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/metaData.js

// Begin Source: src/orientation/getOrientationString.js
(function(cornerstoneMath, cornerstoneTools) {

    'use strict';

    function getOrientationString(vector) {
        // Thanks to David Clunie
        // https://sites.google.com/site/dicomnotes/

        var orientation = '',
            orientationX = vector.x < 0 ? 'R' : 'L',
            orientationY = vector.y < 0 ? 'A' : 'P',
            orientationZ = vector.z < 0 ? 'F' : 'H';

        // Should probably make this a function vector3.abs
        var abs = new cornerstoneMath.Vector3(Math.abs(vector.x), Math.abs(vector.y), Math.abs(vector.z));

        for (var i = 0; i < 3; i++) {
            if (abs.x > 0.0001 && abs.x > abs.y && abs.x > abs.z) {
                orientation += orientationX;
                abs.x = 0;
            } else if (abs.y > 0.0001 && abs.y > abs.x && abs.y > abs.z) {
                orientation += orientationY;
                abs.y = 0;
            } else if (abs.z > 0.0001 && abs.z > abs.x && abs.z > abs.y) {
                orientation += orientationZ;
                abs.z = 0;
            } else {
                break;
            }
        }

        return orientation;
    }

    // module/private exports
    cornerstoneTools.orientation.getOrientationString = getOrientationString;

})(cornerstoneMath, cornerstoneTools);
 
// End Source; src/orientation/getOrientationString.js

// Begin Source: src/orientation/invertOrientationString.js
(function(cornerstoneTools) {

    'use strict';

    function invertOrientationString(string) {
        var inverted = string.replace('H', 'f');
        inverted = inverted.replace('F', 'h');
        inverted = inverted.replace('R', 'l');
        inverted = inverted.replace('L', 'r');
        inverted = inverted.replace('A', 'p');
        inverted = inverted.replace('P', 'a');
        inverted = inverted.toUpperCase();
        return inverted;
    }

    // module/private exports
    cornerstoneTools.orientation.invertOrientationString = invertOrientationString;

})(cornerstoneTools);
 
// End Source; src/orientation/invertOrientationString.js

// Begin Source: src/referenceLines/calculateReferenceLine.js
(function(cornerstoneTools) {

    'use strict';

    // calculates a reference line between two planes by projecting the top left hand corner and bottom right hand corner
    // of the reference image onto the target image.  Ideally we would calculate the intersection between the planes but
    // that requires a bit more math and this works fine for most cases
    function calculateReferenceLine(targetImagePlane, referenceImagePlane) {
        var points = cornerstoneTools.planePlaneIntersection(targetImagePlane, referenceImagePlane);
        if (!points) {
            return;
        }

        return {
            start: cornerstoneTools.projectPatientPointToImagePlane(points.start, targetImagePlane),
            end: cornerstoneTools.projectPatientPointToImagePlane(points.end, targetImagePlane)
        };
    }

    // module/private exports
    cornerstoneTools.referenceLines.calculateReferenceLine = calculateReferenceLine;

})(cornerstoneTools);
 
// End Source; src/referenceLines/calculateReferenceLine.js

// Begin Source: src/referenceLines/referenceLinesTool.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'referenceLines';

    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // Get the enabled elements associated with this synchronization context and draw them
        var syncContext = toolData.data[0].synchronizationContext;
        var enabledElements = syncContext.getSourceElements();

        var renderer = toolData.data[0].renderer;

        // Create the canvas context and reset it to the pixel coordinate system
        var context = eventData.canvasContext.canvas.getContext('2d');
        cornerstone.setToPixelCoordinateSystem(eventData.enabledElement, context);

        // Iterate over each referenced element
        $.each(enabledElements, function(index, referenceEnabledElement) {

            // don't draw ourselves
            if (referenceEnabledElement === e.currentTarget) {
                return;
            }

            // render it
            renderer(context, eventData, e.currentTarget, referenceEnabledElement);
        });
    }

    // enables the reference line tool for a given element.  Note that a custom renderer
    // can be provided if you want different rendering (e.g. all reference lines, first/last/active, etc)
    function enable(element, synchronizationContext, renderer) {
        renderer = renderer || cornerstoneTools.referenceLines.renderActiveReferenceLine;

        cornerstoneTools.addToolState(element, toolType, {
            synchronizationContext: synchronizationContext,
            renderer: renderer
        });
        $(element).on('CornerstoneImageRendered', onImageRendered);
        cornerstone.updateImage(element);
    }

    // disables the reference line tool for the given element
    function disable(element) {
        $(element).off('CornerstoneImageRendered', onImageRendered);
        cornerstone.updateImage(element);
    }

    // module/private exports
    cornerstoneTools.referenceLines.tool = {
        enable: enable,
        disable: disable

    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/referenceLines/referenceLinesTool.js

// Begin Source: src/referenceLines/renderActiveReferenceLine.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // renders the active reference line
    function renderActiveReferenceLine(context, eventData, targetElement, referenceElement) {
        var targetImage = cornerstone.getEnabledElement(targetElement).image;
        var referenceImage = cornerstone.getEnabledElement(referenceElement).image;

        // make sure the images are actually loaded for the target and reference
        if (!targetImage || !referenceImage) {
            return;
        }
        //zyy add
        /* jshint ignore:start */
        if(_&&dvStruct&&_.isObject(dvStruct)){
            var checkedWin = dvStruct.viewer.getCheckedWin();
            //有选中
            if(checkedWin){//console.log(checkedWin,dvStruct.viewer.isInWin(targetElement,checkedWin),!dvStruct.viewer.isInWin(referenceElement,checkedWin),dvStruct.viewer.isInSameWin(targetElement,referenceElement));
                //目标图是选中图  referenceElement---被定位图不是选中框
                if(dvStruct.viewer.isInWin(targetElement,checkedWin)||!dvStruct.viewer.isInWin(referenceElement,checkedWin))return;
                //目标在同一个win内
                if(dvStruct.viewer.isInSameWin(targetElement,referenceElement))return;
            }
        }
        /* jshint ignore:end */
        //zyy add end
		
        var targetImagePlane = cornerstoneTools.metaData.get('imagePlane', targetImage.imageId);
        var referenceImagePlane = cornerstoneTools.metaData.get('imagePlane', referenceImage.imageId);

        // Make sure the target and reference actually have image plane metadata
        if (!targetImagePlane || !referenceImagePlane) {
            return;
        }

        //zyy delete  国内很多不标准  不做这个判断
        // the image planes must be in the same frame of reference
        //if (targetImagePlane.frameOfReferenceUID !== referenceImagePlane.frameOfReferenceUID) {
        //    return;
        //}

        // the image plane normals must be > 30 degrees apart
        var targetNormal = targetImagePlane.rowCosines.clone().cross(targetImagePlane.columnCosines);
        var referenceNormal = referenceImagePlane.rowCosines.clone().cross(referenceImagePlane.columnCosines);
        var angleInRadians = targetNormal.angleTo(referenceNormal);

        angleInRadians = Math.abs(angleInRadians);
        if (angleInRadians < 0.5) { // 0.5 radians = ~30 degrees
            return;
        }

        var referenceLine = cornerstoneTools.referenceLines.calculateReferenceLine(targetImagePlane, referenceImagePlane);
        if (!referenceLine) {
            // console.log(targetImagePlane, referenceImagePlane);
            //sj add
            var str1Obj=getObj(targetImagePlane);//构建对象
            var locObj=getObj(referenceImagePlane);
            referenceLine= xloc.LocalCalc(str1Obj,locObj);//计算定位线
            if (!referenceLine)
            //sj add  end
            return;
        }

        var refLineStartCanvas = cornerstone.pixelToCanvas(eventData.element, referenceLine.start);
        var refLineEndCanvas = cornerstone.pixelToCanvas(eventData.element, referenceLine.end);

        var color = cornerstoneTools.toolColors.getActiveColor();
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();

        // draw the referenceLines
        context.setTransform(1, 0, 0, 1, 0, 0);


        //----zyy add前线跟后线
        /* jshint ignore:start */
        if(checkedWin){
            var refSeries = dvStruct.findSeriesByElement(referenceElement);
            if(!!refSeries){
                var arr = [];
                //选择是哪一组
                for(var i=0;i<refSeries.sideImageIds.length;i++){
                    var farsideImageId = refSeries.sideImageIds[i].farsideImageId;
                    var nearsideImageId = refSeries.sideImageIds[i].nearsideImageId;
                    var farsidePlane = cornerstoneTools.metaData.get('imagePlane', farsideImageId);
                    var farsideNormal = farsidePlane.rowCosines.clone().cross(farsidePlane.columnCosines);
                    //跟参考图平行
                    var angleInRadians = referenceNormal.angleTo(farsideNormal);
                    angleInRadians = Math.abs(angleInRadians);
                    if(angleInRadians < 0.1){
                        arr.push(farsideImageId);arr.push(nearsideImageId);break;
                    }
                }
                if(arr.length>0){
                    for(var i=0;i<arr.length;i++){
                        var planeOther = cornerstoneTools.metaData.get('imagePlane', arr[i]);
                        if (!planeOther)continue;
                        var planeOtherNormal = planeOther.rowCosines.clone().cross(planeOther.columnCosines);
                        var angleInRadians = targetNormal.angleTo(planeOtherNormal);
                        //console.log(angleInRadians,targetNormal);
                        angleInRadians = Math.abs(angleInRadians);
                        if (angleInRadians < 0.5) { // 0.5 radians = ~30 degrees
                            continue;
                        }
                        var refLine = cornerstoneTools.referenceLines.calculateReferenceLine(targetImagePlane, planeOther);
                        //console.log(refLine);
                        if (!refLine) continue;

                        var refLineStartCanv = cornerstone.pixelToCanvas(eventData.element, refLine.start);
                        var refLineEndCanv = cornerstone.pixelToCanvas(eventData.element, refLine.end);

                        context.save();
                        context.beginPath();
                        context.strokeStyle = '#FF4600';
                        context.lineWidth = lineWidth;
                        context.moveTo(refLineStartCanv.x, refLineStartCanv.y);
                        context.lineTo(refLineEndCanv.x, refLineEndCanv.y);
                        context.stroke();
                        context.restore();
                    }
                }
            }
        }
        /* jshint ignore:end */
        //----zyy add end

        context.save();
        context.beginPath();
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.moveTo(refLineStartCanvas.x, refLineStartCanvas.y);
        context.lineTo(refLineEndCanvas.x, refLineEndCanvas.y);
        context.stroke();
        context.restore();
    }

    // module/private exports
    cornerstoneTools.referenceLines.renderActiveReferenceLine = renderActiveReferenceLine;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/referenceLines/renderActiveReferenceLine.js

// Begin Source: src/requestPool/requestPoolManager.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    var requestPool = {
        interaction: [],
        thumbnail: [],
        prefetch: []
    };

    var numRequests = {
        interaction: 0,
        thumbnail: 0,
        prefetch: 0
    };

    var maxNumRequests = {
        interaction: 6,
        thumbnail: 6,
        prefetch: 5
    };
    
    var lastElementInteracted;
    var awake = false;
    var grabDelay = 20;

    function requestPoolManager() {

        function addRequest(element, imageId, type, preventCache, doneCallback, failCallback) {
            if (!requestPool.hasOwnProperty(type)) {
                throw 'Request type must be one of interaction, thumbnail, or prefetch';
            }

            if (!element || !imageId) {
                return;
            }

            // Describe the request
            var requestDetails = {
                type: type,
                imageId: imageId,
                preventCache: preventCache,
                doneCallback: doneCallback,
                failCallback: failCallback
            };

            // If this imageId is in the cache, resolve it immediately
            var imagePromise = cornerstone.imageCache.getImagePromise(imageId);
            if (imagePromise) {
                imagePromise.then(function(image) {
                    doneCallback(image);
                }, function(error) {
                    failCallback(error);
                });
                return;
            }

            // Add it to the end of the stack
            requestPool[type].push(requestDetails);

            // Store the last element interacted with,
            // So we know which images to prefetch
            //
            // ---- Not used for now ----
            if (type === 'interaction') {
                lastElementInteracted = element;
            }
        }

        function clearRequestStack(type) {
            //console.log('clearRequestStack');
            if (!requestPool.hasOwnProperty(type)) {
                throw 'Request type must be one of interaction, thumbnail, or prefetch';
            }

            requestPool[type] = [];
        }

        function startAgain() {
            if (!awake) {
                return;
            }

            setTimeout(function() {
                var requestDetails = getNextRequest();
                if (!requestDetails) {
                    return;
                }

                sendRequest(requestDetails);
            }, grabDelay);
        }

        function sendRequest(requestDetails) {
            // Increment the number of current requests of this type
            var type = requestDetails.type;
            numRequests[type]++;

            awake = true;
            var imageId = requestDetails.imageId;
            var doneCallback = requestDetails.doneCallback;
            var failCallback = requestDetails.failCallback;
            
            // Check if we already have this image promise in the cache
            var imagePromise = cornerstone.imageCache.getImagePromise(imageId);
            if (imagePromise) {
                // If we do, remove from list (when resolved, as we could have
                // pending prefetch requests) and stop processing this iteration
                imagePromise.then(function(image) {
                    numRequests[type]--;
                    // console.log(numRequests);

                    doneCallback(image);
                    startAgain();
                }, function(error) {
                    numRequests[type]--;
                    // console.log(numRequests);
                    failCallback(error);
                });
                return;
            }

            var loader;
            if (requestDetails.preventCache === true) {
                loader = cornerstone.loadImage(imageId);
            } else {
                loader = cornerstone.loadAndCacheImage(imageId);
            }

            // Load and cache the image
            loader.then(function(image) {
                numRequests[type]--;
                // console.log(numRequests);
                doneCallback(image);
                startAgain();
            }, function(error) {
                numRequests[type]--;
                // console.log(numRequests);
                failCallback(error);
            });
        }

        function startGrabbing() {
            // Begin by grabbing X images
            if (awake) {
                return;
            }

            var maxSimultaneousRequests = cornerstoneTools.getMaxSimultaneousRequests();
            
            maxNumRequests = {
                interaction: maxSimultaneousRequests,
                thumbnail: maxSimultaneousRequests - 2,
                prefetch: maxSimultaneousRequests - 1
            };

            for (var i = 0; i < maxSimultaneousRequests; i++) {
                var requestDetails = getNextRequest();
                if (requestDetails) {
                    sendRequest(requestDetails);
                }
            }

            //console.log("startGrabbing");
            //console.log(requestPool);
        }

        function getNextRequest() {
            if (requestPool.interaction.length && numRequests.interaction < maxNumRequests.interaction) {
                return requestPool.interaction.shift();
            }

            if (requestPool.thumbnail.length && numRequests.thumbnail < maxNumRequests.thumbnail) {
                return requestPool.thumbnail.shift();
            }

            if (requestPool.prefetch.length && numRequests.prefetch < maxNumRequests.prefetch) {
                return requestPool.prefetch.shift();
            }

            if (!requestPool.interaction.length &&
                !requestPool.thumbnail.length &&
                !requestPool.prefetch.length) {
                awake = false;
            }

            return false;
        }

        function getRequestPool() {
            return requestPool;
        }

        var requestManager = {
            addRequest: addRequest,
            clearRequestStack: clearRequestStack,
            startGrabbing: startGrabbing,
            getRequestPool: getRequestPool
        };

        return requestManager;
    }

    // module/private exports
    cornerstoneTools.requestPoolManager = requestPoolManager();

})(cornerstone, cornerstoneTools);
 
// End Source; src/requestPool/requestPoolManager.js

// Begin Source: src/stackTools/playClip.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'playClip';

    /**
     * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is
     * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.
     * The element must be a stack of images
     * @param element
     * @param framesPerSecond
     */
    function playClip(element, framesPerSecond) {
        if (element === undefined) {
            throw 'playClip: element must not be undefined';
        }

        if (framesPerSecond === undefined) {
            framesPerSecond = 30;
        }

        var stackToolData = cornerstoneTools.getToolState(element, 'stack');
        if (stackToolData === undefined || stackToolData.data === undefined || stackToolData.data.length === 0) {
            return;
        }

        var stackData = stackToolData.data[0];

        var playClipToolData = cornerstoneTools.getToolState(element, toolType);
        var playClipData;
        
        if (playClipToolData === undefined || playClipToolData.data.length === 0) {
            playClipData = {
                intervalId: undefined,
                framesPerSecond: framesPerSecond,
                lastFrameTimeStamp: undefined,
                frameRate: 0,
                loop: true
            };
            cornerstoneTools.addToolState(element, toolType, playClipData);
        } else {
            playClipData = playClipToolData.data[0];
            playClipData.framesPerSecond = framesPerSecond;
        }

        // if already playing, do not set a new interval
        if (playClipData.intervalId !== undefined) {
            return;
        }

        playClipData.intervalId = setInterval(function() {

            var newImageIdIndex = stackData.currentImageIdIndex;

            if (playClipData.framesPerSecond > 0) {
                newImageIdIndex++;
            } else {
                newImageIdIndex--;
            }

            if (!playClipData.loop && (newImageIdIndex >= stackData.imageIds.length || newImageIdIndex < 0)) {
                
                var eventDetail = {
                    element: element
                };
                var event = $.Event('CornerstoneToolsClipStopped', eventDetail);
                $(element).trigger(event, eventDetail);

                clearInterval(playClipData.intervalId);
                playClipData.intervalId = undefined;
                return;
            }

            // loop around if we go outside the stack
            if (newImageIdIndex >= stackData.imageIds.length) {
                newImageIdIndex = 0;
            }

            if (newImageIdIndex < 0) {
                newImageIdIndex = stackData.imageIds.length - 1;
            }

            if (newImageIdIndex !== stackData.currentImageIdIndex) {
                var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
                var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
                var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

                if (startLoadingHandler) {
                    startLoadingHandler(element);
                }

                var viewport = cornerstone.getViewport(element);

                var loader;
                if (stackData.preventCache === true) {
                    loader = cornerstone.loadImage(stackData.imageIds[newImageIdIndex]);
                } else {
                    loader = cornerstone.loadAndCacheImage(stackData.imageIds[newImageIdIndex]);
                }

                loader.then(function(image) {
                    stackData.currentImageIdIndex = newImageIdIndex;
                    cornerstone.displayImage(element, image, viewport);
                    if (endLoadingHandler) {
                        endLoadingHandler(element);
                    }
                }, function(error) {
                    var imageId = stackData.imageIds[newImageIdIndex];
                    if (errorLoadingHandler) {
                        errorLoadingHandler(element, imageId, error);
                    }
                });
            }
        }, 1000 / Math.abs(playClipData.framesPerSecond));
    }

    /**
     * Stops an already playing clip.
     * * @param element
     */
    function stopClip(element) {
        var playClipToolData = cornerstoneTools.getToolState(element, toolType);
        var playClipData;
        if (playClipToolData === undefined || playClipToolData.data.length === 0) {
            return;
        } else {
            playClipData = playClipToolData.data[0];
        }

        clearInterval(playClipData.intervalId);
        playClipData.intervalId = undefined;
    }

    // module/private exports
    cornerstoneTools.playClip = playClip;
    cornerstoneTools.stopClip = stopClip;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stackTools/playClip.js

// Begin Source: src/stackTools/scrollIndicator.js
/*
Display scroll progress bar across bottom of image.
 */
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var scrollBarHeight = 6;

    var configuration = {
        backgroundColor: 'rgb(19, 63, 141)',
        fillColor: 'white'
    };

    function onImageRendered(e, eventData){
        var element = eventData.element;
        var width = eventData.enabledElement.canvas.width;
        var height = eventData.enabledElement.canvas.height;

        if (!width || !height) {
            return false;
        }

        var context = eventData.enabledElement.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.save();

        var config = cornerstoneTools.scrollIndicator.getConfiguration();

        // draw indicator background
        context.fillStyle = config.backgroundColor;
        context.fillRect(0, height - scrollBarHeight, width, scrollBarHeight);

        // get current image index
        var stackData = cornerstoneTools.getToolState(element, 'stack');
        if (!stackData || !stackData.data || !stackData.data.length) {
            return;
        }

        var imageIds = stackData.data[0].imageIds;
        var currentImageIdIndex = stackData.data[0].currentImageIdIndex;

        // draw current image cursor
        var cursorWidth = width / imageIds.length;
        var xPosition = cursorWidth * currentImageIdIndex;

        context.fillStyle = config.fillColor;
        context.fillRect(xPosition, height - scrollBarHeight, cursorWidth, scrollBarHeight);

        context.restore();
    }

    cornerstoneTools.scrollIndicator = cornerstoneTools.displayTool(onImageRendered);
    cornerstoneTools.scrollIndicator.setConfiguration(configuration);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stackTools/scrollIndicator.js

// Begin Source: src/stackTools/stackPrefetch.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'stackPrefetch';
    var requestType = 'prefetch';

    var configuration = {};

    var resetPrefetchTimeout,
        resetPrefetchDelay;

    function sortNumber(a, b) {
        // http://stackoverflow.com/questions/1063007/how-to-sort-an-array-of-integers-correctly
        return a - b;
    }

    function range(lowEnd, highEnd) {
        // Javascript version of Python's range function
        // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl
        lowEnd = Math.round(lowEnd) || 0;
        highEnd = Math.round(highEnd) || 0;

        var arr = [],
            c = highEnd - lowEnd + 1;

        if (c <= 0) {
            return arr;
        }

        while ( c-- ) {
            arr[c] = highEnd--;
        }

        return arr;
    }

    var max = function(arr) {
        return Math.max.apply(null, arr);
    };

    var min = function(arr) {
        return Math.min.apply(null, arr);
    };

    function nearestIndex(arr, x) {
        // Return index of nearest values in array
        // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array        
        var l = [],
            h = [];

        arr.forEach(function(v) {
            if (v < x) {
                l.push(v);
            } else if (v > x) {
                h.push(v);
            }
        });
       
        return {
            low: arr.indexOf(max(l)),
            high: arr.indexOf(min(h))
        };
    }

    function prefetch(element) {
        // Check to make sure stack data exists
        var stackData = cornerstoneTools.getToolState(element, 'stack');
        if (!stackData || !stackData.data || !stackData.data.length) {
            return;
        }

        var stack = stackData.data[0];

        // Get the stackPrefetch tool data
        var stackPrefetchData = cornerstoneTools.getToolState(element, toolType);
        if (!stackPrefetchData) {
            return;
        }

        var stackPrefetch = stackPrefetchData.data[0];

        // If all the requests are complete, disable the stackPrefetch tool
        if (!stackPrefetch || !stackPrefetch.indicesToRequest || !stackPrefetch.indicesToRequest.length) {
            stackPrefetch.enabled = false;
        }

        // Make sure the tool is still enabled
        if (stackPrefetch.enabled === false) {
            return;
        }

        // Remove an imageIdIndex from the list of indices to request
        // This fires when the individual image loading deferred is resolved        
        function removeFromList(imageIdIndex) {
            var index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
            if (index > -1) { // don't remove last element if imageIdIndex not found
                stackPrefetch.indicesToRequest.splice(index, 1);
            }
        }
        
        // Remove all already cached images from the
        // indicesToRequest array
        stackPrefetchData.data[0].indicesToRequest.sort(sortNumber);
        var indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();

        indicesToRequestCopy.forEach(function(imageIdIndex) {
            var imageId = stack.imageIds[imageIdIndex];

            if (!imageId) {
                return;
            }

            var imagePromise = cornerstone.imageCache.getImagePromise(imageId);
            if (imagePromise && imagePromise.state() === 'resolved'){
                removeFromList(imageIdIndex);
            }
        });

        // Stop here if there are no images left to request
        // After those in the cache have been removed
        if (!stackPrefetch.indicesToRequest.length) {
            return;
        }

        function doneCallback(image) {
            //console.log('prefetch done: ' + image.imageId);
            var imageIdIndex = stack.imageIds.indexOf(image.imageId);
            removeFromList(imageIdIndex);
        }

        function failCallback(error) {
            console.log('prefetch errored: ' + error);
        }

        // Clear the requestPool of prefetch requests
        var requestPoolManager = cornerstoneTools.requestPoolManager;
        requestPoolManager.clearRequestStack(requestType);

        // Identify the nearest imageIdIndex to the currentImageIdIndex 
        var nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);

        var imageId,
            nextImageIdIndex,
            preventCache = false;

        // Prefetch images around the current image (before and after)
        var lowerIndex = nearest.low;
        var higherIndex = nearest.high;
        while (lowerIndex > 0 || higherIndex < stackPrefetch.indicesToRequest.length) {
            if (lowerIndex >= 0 ) {
                nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];
                imageId = stack.imageIds[nextImageIdIndex];
                requestPoolManager.addRequest(element, imageId, requestType, preventCache, doneCallback, failCallback);
            }

            if (higherIndex < stackPrefetch.indicesToRequest.length) {
                nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];
                imageId = stack.imageIds[nextImageIdIndex];
                requestPoolManager.addRequest(element, imageId, requestType, preventCache, doneCallback, failCallback);
            }
        }

        // Try to start the requestPool's grabbing procedure
        // in case it isn't already running
        requestPoolManager.startGrabbing();
    }

    function handleCacheFull(e) {
        // Stop prefetching if the ImageCacheFull event is fired from cornerstone
        // console.log('CornerstoneImageCacheFull full, stopping');
        var element = e.data.element;

        var stackPrefetchData = cornerstoneTools.getToolState(element, toolType);
        if (!stackPrefetchData || !stackPrefetchData.data || !stackPrefetchData.data.length) {
            return;
        }

        // Disable the stackPrefetch tool
        // stackPrefetchData.data[0].enabled = false;

        // Clear current prefetch requests from the requestPool
        cornerstoneTools.requestPoolManager.clearRequestStack(requestType);
    }

    function promiseRemovedHandler(e, eventData) {
        // When an imagePromise has been pushed out of the cache, re-add its index
        // it to the indicesToRequest list so that it will be retrieved later if the
        // currentImageIdIndex is changed to an image nearby
        var element = e.data.element;
        var stackData = cornerstoneTools.getToolState(element, 'stack');
        if (!stackData || !stackData.data || !stackData.data.length) {
            return;
        }

        var stack = stackData.data[0];
        var imageIdIndex = stack.imageIds.indexOf(eventData.imageId);

        // Make sure the image that was removed is actually in this stack
        // before adding it to the indicesToRequest array
        if (imageIdIndex < 0) {
            return;
        }
        
        var stackPrefetchData = cornerstoneTools.getToolState(element, toolType);
        if (!stackPrefetchData || !stackPrefetchData.data || !stackPrefetchData.data.length) {
            return;
        }

        stackPrefetchData.data[0].indicesToRequest.push(imageIdIndex);
    }

    function onImageUpdated(e) {
        // Start prefetching again (after a delay)
        // When the user has scrolled to a new image
        clearTimeout(resetPrefetchTimeout);
        resetPrefetchTimeout = setTimeout(function() {
            var element = e.currentTarget;
            prefetch(element);
        }, resetPrefetchDelay);
    }

    function enable(element) {
        // Clear old prefetch data. Skipping this can cause problems when changing the series inside an element
        var stackPrefetchDataArray = cornerstoneTools.getToolState(element, toolType);
        stackPrefetchDataArray.data = [];

        // First check that there is stack data available
        var stackData = cornerstoneTools.getToolState(element, 'stack');
        if (!stackData || !stackData.data || !stackData.data.length) {
            return;
        }

        var stack = stackData.data[0];

        // Check if we are allowed to cache images in this stack
        if (stack.preventCache === true) {
            console.warn('A stack that should not be cached was given the stackPrefetch');
            return;
        }

        // Use the currentImageIdIndex from the stack as the initalImageIdIndex
        var stackPrefetchData = {
            indicesToRequest: range(0, stack.imageIds.length - 1),
            enabled: true,
            direction: 1
        };

        // Remove the currentImageIdIndex from the list to request
        var indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);
        stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);

        cornerstoneTools.addToolState(element, toolType, stackPrefetchData);

        prefetch(element);

        $(element).off('CornerstoneNewImage', onImageUpdated);
        $(element).on('CornerstoneNewImage', onImageUpdated);

        $(cornerstone).off('CornerstoneImageCacheFull', handleCacheFull);
        $(cornerstone).on('CornerstoneImageCacheFull', {
            element: element
        }, handleCacheFull);

        $(cornerstone).off('CornerstoneImageCachePromiseRemoved', promiseRemovedHandler);
        $(cornerstone).on('CornerstoneImageCachePromiseRemoved', {
            element: element
        }, promiseRemovedHandler);
    }

    function disable(element) {
        clearTimeout(resetPrefetchTimeout);
        $(element).off('CornerstoneNewImage', onImageUpdated);

        $(cornerstone).off('CornerstoneImageCacheFull', handleCacheFull);
        $(cornerstone).off('CornerstoneImageCachePromiseRemoved', promiseRemovedHandler);

        var stackPrefetchData = cornerstoneTools.getToolState(element, toolType);
        // If there is actually something to disable, disable it
        if (stackPrefetchData && stackPrefetchData.data.length) {
            stackPrefetchData.data[0].enabled = false;

            // Clear current prefetch requests from the requestPool
            cornerstoneTools.requestPoolManager.clearRequestStack(requestType);
        }
    }

    function getConfiguration () {
        return configuration;
    }

    function setConfiguration(config) {
        configuration = config;
    }

    // module/private exports
    cornerstoneTools.stackPrefetch = {
        enable: enable,
        disable: disable,
        getConfiguration: getConfiguration,
        setConfiguration: setConfiguration
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stackTools/stackPrefetch.js

// Begin Source: src/stackTools/stackScroll.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', dragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            var mouseDragEventData = {
                deltaY: 0
            };
            $(eventData.element).on('CornerstoneToolsMouseDrag', mouseDragEventData, dragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            e.stopImmediatePropagation();
            return false;
        }
    }

    function mouseWheelCallback(e, eventData) {
        var images = -eventData.direction;
        cornerstoneTools.scroll(eventData.element, images);
    }

    function dragCallback(e, eventData) {
        var element = eventData.element;

        var toolData = cornerstoneTools.getToolState(element, 'stack');
        if (!toolData || !toolData.data || !toolData.data.length) {
            return;
        }
        
        var stackData = toolData.data[0];

        var config = cornerstoneTools.stackScroll.getConfiguration();

        // The Math.max here makes it easier to mouseDrag-scroll small image stacks
        var pixelsPerImage = $(element).height() / Math.max(stackData.imageIds.length, 8);
        if (config && config.stackScrollSpeed) {
            pixelsPerImage = config.stackScrollSpeed;
        }

        e.data.deltaY = e.data.deltaY || 0;
        e.data.deltaY += eventData.deltaPoints.page.y;
        if (Math.abs(e.data.deltaY) >= pixelsPerImage) {
            var imageDelta = e.data.deltaY / pixelsPerImage;
            var imageIdIndexOffset = Math.round(imageDelta);
            var imageDeltaMod = e.data.deltaY % pixelsPerImage;
            e.data.deltaY = imageDeltaMod;
            cornerstoneTools.scroll(element, imageIdIndexOffset);
        }

        return false; // false = causes jquery to preventDefault() and stopPropagation() this event
    }

    // module/private exports
    cornerstoneTools.stackScroll = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.stackScrollWheel = cornerstoneTools.mouseWheelTool(mouseWheelCallback);

    var options = {
        eventData: {
            deltaY: 0
        }
    };
    cornerstoneTools.stackScrollTouchDrag = cornerstoneTools.touchDragTool(dragCallback, options);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stackTools/stackScroll.js

// Begin Source: src/stackTools/stackScrollKeyboard.js
(function(cornerstoneTools) {

    'use strict';

    var keys = {
        UP: 38,
        DOWN: 40
    };

    function keyDownCallback(e, eventData) {
        var keyCode = eventData.keyCode;
        if (keyCode !== keys.UP && keyCode !== keys.DOWN) {
            return;
        }

        var images = 1;
        if (keyCode === keys.DOWN) {
            images = -1;
        }

        cornerstoneTools.scroll(eventData.element, images);
    }

    // module/private exports
    cornerstoneTools.stackScrollKeyboard = cornerstoneTools.keyboardTool(keyDownCallback);

})(cornerstoneTools);
 
// End Source; src/stackTools/stackScrollKeyboard.js

// Begin Source: src/stateManagement/applicationState.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function saveApplicationState(elements) {
        // Save imageId-specific tool state data
        var appState = {
            imageIdToolState: cornerstoneTools.globalImageIdSpecificToolStateManager.saveToolState(),
            elementToolState: {},
            elementViewport: {}
        };

        // For each of the given elements, save the viewport and any stack-specific tool data
        elements.forEach(function(element) {
            var toolStateManager = cornerstoneTools.getElementToolStateManager(element);
            if (toolStateManager === cornerstoneTools.globalImageIdSpecificToolStateManager) {
                return;
            }

            appState.elementToolState[element.id] = toolStateManager.saveToolState();

            appState.elementViewport[element.id] = cornerstone.getViewport(element);
        });
        return appState;
    }

    function restoreApplicationState(appState) {
        // Make sure t
        if (!appState.hasOwnProperty('imageIdToolState') ||
            !appState.hasOwnProperty('elementToolState') ||
            !appState.hasOwnProperty('elementViewport')) {
            return;
        }

        // Restore all the imageId specific tool data
        cornerstoneTools.globalImageIdSpecificToolStateManager.restoreToolState(appState.imageIdToolState);

        Object.keys(appState.elementViewport).forEach(function(elementId) {
            // Restore any stack specific tool data
            var element = document.getElementById(elementId);
            if (!element) {
                return;
            }

            if (!appState.elementToolState.hasOwnProperty(elementId)) {
                return;
            }
            
            var toolStateManager = cornerstoneTools.getElementToolStateManager(element);
            if (toolStateManager === cornerstoneTools.globalImageIdSpecificToolStateManager) {
                return;
            }

            toolStateManager.restoreToolState(appState.elementToolState[elementId]);

            // Restore the saved viewport information
            var savedViewport = appState.elementViewport[elementId];
            cornerstone.setViewport(element, savedViewport);

            // Update the element to apply the viewport and tool changes
            cornerstone.updateImage(element);
        });
        return appState;
    }

    cornerstoneTools.appState = {
        save: saveApplicationState,
        restore: restoreApplicationState
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/applicationState.js

// Begin Source: src/stateManagement/frameOfReferenceStateManager.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This implements a frame-of-reference specific tool state management strategy.  This means that
    // measurement data are tied to a specific frame of reference UID and only visible to objects using
    // that frame-of-reference UID

    function newFrameOfReferenceSpecificToolStateManager() {
        var toolState = {};

        // here we add tool state, this is done by tools as well
        // as modules that restore saved state
        function addFrameOfReferenceSpecificToolState(frameOfReference, toolType, data) {
            // if we don't have any tool state for this frameOfReference, add an empty object
            if (toolState.hasOwnProperty(frameOfReference) === false) {
                toolState[frameOfReference] = {};
            }

            var frameOfReferenceToolState = toolState[frameOfReference];

            // if we don't have tool state for this type of tool, add an empty object
            if (frameOfReferenceToolState.hasOwnProperty(toolType) === false) {
                frameOfReferenceToolState[toolType] = {
                    data: []
                };
            }

            var toolData = frameOfReferenceToolState[toolType];

            // finally, add this new tool to the state
            toolData.data.push(data);
        }

        // here you can get state - used by tools as well as modules
        // that save state persistently
        function getFrameOfReferenceSpecificToolState(frameOfReference, toolType) {
            // if we don't have any tool state for this frame of reference, return undefined
            if (toolState.hasOwnProperty(frameOfReference) === false) {
                return;
            }

            var frameOfReferenceToolState = toolState[frameOfReference];

            // if we don't have tool state for this type of tool, return undefined
            if (frameOfReferenceToolState.hasOwnProperty(toolType) === false) {
                return;
            }

            var toolData = frameOfReferenceToolState[toolType];
            return toolData;
        }

        function removeFrameOfReferenceSpecificToolState(frameOfReference, toolType, data) {
            // if we don't have any tool state for this frame of reference, return undefined
            if (toolState.hasOwnProperty(frameOfReference) === false) {
                return;
            }

            var frameOfReferenceToolState = toolState[frameOfReference];

            // if we don't have tool state for this type of tool, return undefined
            if (frameOfReferenceToolState.hasOwnProperty(toolType) === false) {
                return;
            }

            var toolData = frameOfReferenceToolState[toolType];
            // find this tool data
            var indexOfData = -1;
            for (var i = 0; i < toolData.data.length; i++) {
                if (toolData.data[i] === data) {
                    indexOfData = i;
                }
            }

            if (indexOfData !== -1) {
                toolData.data.splice(indexOfData, 1);
            }
        }

        var frameOfReferenceToolStateManager = {
            get: getFrameOfReferenceSpecificToolState,
            add: addFrameOfReferenceSpecificToolState,
            remove: removeFrameOfReferenceSpecificToolState
        };
        return frameOfReferenceToolStateManager;
    }

    // a global frameOfReferenceSpecificToolStateManager - the most common case is to share 3d information
    // between stacks of images
    var globalFrameOfReferenceSpecificToolStateManager = newFrameOfReferenceSpecificToolStateManager();
    
    // module/private exports
    cornerstoneTools.newFrameOfReferenceSpecificToolStateManager = newFrameOfReferenceSpecificToolStateManager;
    cornerstoneTools.globalFrameOfReferenceSpecificToolStateManager = globalFrameOfReferenceSpecificToolStateManager;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/frameOfReferenceStateManager.js

// Begin Source: src/stateManagement/imageIdSpecificStateManager.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    // This implements an imageId specific tool state management strategy.  This means that
    // measurements data is tied to a specific imageId and only visible for enabled elements
    // that are displaying that imageId.

    function newImageIdSpecificToolStateManager() {
        var toolState = {};

        // here we add tool state, this is done by tools as well
        // as modules that restore saved state

        function saveImageIdToolState(imageId) {
            return toolState[imageId];
        }

        function restoreImageIdToolState(imageId, imageIdToolState) {
            toolState[imageId] = imageIdToolState;
        }

        function saveToolState() {
            return toolState;
        }

        function restoreToolState(savedToolState) {
            toolState = savedToolState;
        }

        // here we add tool state, this is done by tools as well
        // as modules that restore saved state
        function addImageIdSpecificToolState(element, toolType, data) {
            var enabledImage = cornerstone.getEnabledElement(element);
            // if we don't have any tool state for this imageId, add an empty object
            if (!enabledImage.image || toolState.hasOwnProperty(enabledImage.image.imageId) === false) {
                toolState[enabledImage.image.imageId] = {};
            }

            var imageIdToolState = toolState[enabledImage.image.imageId];

            // if we don't have tool state for this type of tool, add an empty object
            if (imageIdToolState.hasOwnProperty(toolType) === false) {
                imageIdToolState[toolType] = {
                    data: []
                };
            }

            var toolData = imageIdToolState[toolType];

            // finally, add this new tool to the state
            toolData.data.push(data);
        }

        // here you can get state - used by tools as well as modules
        // that save state persistently
        function getImageIdSpecificToolState(element, toolType) {
            var enabledImage = cornerstone.getEnabledElement(element);
            // if we don't have any tool state for this imageId, return undefined
            if (!enabledImage.image || toolState.hasOwnProperty(enabledImage.image.imageId) === false) {
                return;
            }

            var imageIdToolState = toolState[enabledImage.image.imageId];

            // if we don't have tool state for this type of tool, return undefined
            if (imageIdToolState.hasOwnProperty(toolType) === false) {
                return;
            }

            var toolData = imageIdToolState[toolType];
            return toolData;
        }

        // Clears all tool data from this toolStateManager.
        function clearImageIdSpecificToolStateManager(element) {
            var enabledImage = cornerstone.getEnabledElement(element);
            if (!enabledImage.image || toolState.hasOwnProperty(enabledImage.image.imageId) === false) {
                return;
            }

            delete toolState[enabledImage.image.imageId];
        }

        var imageIdToolStateManager = {
            get: getImageIdSpecificToolState,
            add: addImageIdSpecificToolState,
            clear: clearImageIdSpecificToolStateManager,
            saveImageIdToolState: saveImageIdToolState,
            restoreImageIdToolState: restoreImageIdToolState,
            saveToolState: saveToolState,
            restoreToolState: restoreToolState,
            toolState: toolState
        };
        return imageIdToolStateManager;
    }

    // a global imageIdSpecificToolStateManager - the most common case is to share state between all
    // visible enabled images
    var globalImageIdSpecificToolStateManager = newImageIdSpecificToolStateManager();
    
    // module/private exports
    cornerstoneTools.newImageIdSpecificToolStateManager = newImageIdSpecificToolStateManager;
    cornerstoneTools.globalImageIdSpecificToolStateManager = globalImageIdSpecificToolStateManager;

})(cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/imageIdSpecificStateManager.js

// Begin Source: src/stateManagement/loadHandlerManager.js
(function(cornerstoneTools) {

    'use strict';

    function loadHandlerManager() {
        var defaultStartLoadHandler,
            defaultEndLoadHandler,
            defaultErrorLoadingHandler;

        function setStartLoadHandler(handler) {
            defaultStartLoadHandler = handler;
        }

        function getStartLoadHandler() {
            return defaultStartLoadHandler;
        }

        function setEndLoadHandler(handler) {
            defaultEndLoadHandler = handler;
        }

        function getEndLoadHandler(){
            return defaultEndLoadHandler;
        }

        function setErrorLoadingHandler(handler) {
            defaultErrorLoadingHandler = handler;
        }
        
        function getErrorLoadingHandler() {
            return defaultErrorLoadingHandler;
        }
      
        var loadHandlers = {
            setStartLoadHandler: setStartLoadHandler,
            getStartLoadHandler: getStartLoadHandler,
            setEndLoadHandler: setEndLoadHandler,
            getEndLoadHandler: getEndLoadHandler,
            setErrorLoadingHandler: setErrorLoadingHandler,
            getErrorLoadingHandler: getErrorLoadingHandler
        };

        return loadHandlers;
    }

    // module/private exports
    cornerstoneTools.loadHandlerManager = loadHandlerManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/loadHandlerManager.js

// Begin Source: src/stateManagement/stackSpecificStateManager.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    // This implements an Stack specific tool state management strategy.  This means
    // that tool data is shared between all imageIds in a given stack
    function newStackSpecificToolStateManager(toolTypes, oldStateManager) {
        var toolState = {};

        function saveToolState() {
            return toolState;
        }

        function restoreToolState(stackToolState) {
            toolState = stackToolState;
        }

        // here we add tool state, this is done by tools as well
        // as modules that restore saved state
        function addStackSpecificToolState(element, toolType, data) {
            // if this is a tool type to apply to the stack, do so
            if (toolTypes.indexOf(toolType) >= 0) {

                // if we don't have tool state for this type of tool, add an empty object
                if (toolState.hasOwnProperty(toolType) === false) {
                    toolState[toolType] = {
                        data: []
                    };
                }

                var toolData = toolState[toolType];

                // finally, add this new tool to the state
                toolData.data.push(data);
            } else {
                // call the imageId specific tool state manager
                return oldStateManager.add(element, toolType, data);
            }
        }

        // here you can get state - used by tools as well as modules
        // that save state persistently
        function getStackSpecificToolState(element, toolType) {
            // if this is a tool type to apply to the stack, do so
            if (toolTypes.indexOf(toolType) >= 0) {
                // if we don't have tool state for this type of tool, add an empty object
                if (toolState.hasOwnProperty(toolType) === false) {
                    toolState[toolType] = {
                        data: []
                    };
                }

                var toolData = toolState[toolType];
                return toolData;
            } else {
                // call the imageId specific tool state manager
                return oldStateManager.get(element, toolType);
            }
        }

        var stackSpecificToolStateManager = {
            get: getStackSpecificToolState,
            add: addStackSpecificToolState,
            saveToolState: saveToolState,
            restoreToolState: restoreToolState,
            toolState: toolState,
        };
        return stackSpecificToolStateManager;
    }

    var stackStateManagers = [];

    function addStackStateManager(element) {
        var oldStateManager = cornerstoneTools.getElementToolStateManager(element);
        if (!oldStateManager) {
            oldStateManager = cornerstoneTools.globalImageIdSpecificToolStateManager;
        }

        var stackTools = [ 'stack', 'stackPrefetch', 'playClip', 'volume', 'slab', 'referenceLines', 'crosshairs' ];
        var stackSpecificStateManager = cornerstoneTools.newStackSpecificToolStateManager(stackTools, oldStateManager);
        stackStateManagers.push(stackSpecificStateManager);
        cornerstoneTools.setElementToolStateManager(element, stackSpecificStateManager);
    }

    // module/private exports
    cornerstoneTools.newStackSpecificToolStateManager = newStackSpecificToolStateManager;
    cornerstoneTools.addStackStateManager = addStackStateManager;

})(cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/stackSpecificStateManager.js

// Begin Source: src/stateManagement/textStyleManager.js
(function(cornerstoneTools) {

    'use strict';

    function textStyleManager() {
        var defaultFontSize = 15,
            defaultFont = defaultFontSize + 'px Arial',
            defaultBackgroundColor = 'transparent';

        function setFont(font) {
            defaultFont = font;
        }

        function getFont() {
            return defaultFont;
        }

        function setFontSize(fontSize) {
            defaultFontSize = fontSize;
        }

        function getFontSize() {
            return defaultFontSize;
        }

        function setBackgroundColor(backgroundColor) {
            defaultBackgroundColor = backgroundColor;
        }

        function getBackgroundColor() {
            return defaultBackgroundColor;
        }

        var textStyle = {
            setFont: setFont,
            getFont: getFont,
            setFontSize: setFontSize,
            getFontSize: getFontSize,
            setBackgroundColor: setBackgroundColor,
            getBackgroundColor: getBackgroundColor
        };

        return textStyle;
    }

    // module/private exports
    cornerstoneTools.textStyle = textStyleManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/textStyleManager.js

// Begin Source: src/stateManagement/timeSeriesSpecificStateManager.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    // This implements an Stack specific tool state management strategy.  This means
    // that tool data is shared between all imageIds in a given stack
    function newTimeSeriesSpecificToolStateManager(toolTypes, oldStateManager) {
        var toolState = {};

        // here we add tool state, this is done by tools as well
        // as modules that restore saved state
        function addStackSpecificToolState(element, toolType, data) {
            // if this is a tool type to apply to the stack, do so
            if (toolTypes.indexOf(toolType) >= 0) {

                // if we don't have tool state for this type of tool, add an empty object
                if (toolState.hasOwnProperty(toolType) === false) {
                    toolState[toolType] = {
                        data: []
                    };
                }

                var toolData = toolState[toolType];

                // finally, add this new tool to the state
                toolData.data.push(data);
            } else {
                // call the imageId specific tool state manager
                return oldStateManager.add(element, toolType, data);
            }
        }

        // here you can get state - used by tools as well as modules
        // that save state persistently
        function getStackSpecificToolState(element, toolType) {
            // if this is a tool type to apply to the stack, do so
            if (toolTypes.indexOf(toolType) >= 0) {
                // if we don't have tool state for this type of tool, add an empty object
                if (toolState.hasOwnProperty(toolType) === false) {
                    toolState[toolType] = {
                        data: []
                    };
                }

                var toolData = toolState[toolType];
                return toolData;
            } else {
                // call the imageId specific tool state manager
                return oldStateManager.get(element, toolType);
            }
        }

        var imageIdToolStateManager = {
            get: getStackSpecificToolState,
            add: addStackSpecificToolState
        };
        return imageIdToolStateManager;
    }

    var timeSeriesStateManagers = [];

    function addTimeSeriesStateManager(element, tools) {
        tools = tools || [ 'timeSeries' ];
        var oldStateManager = cornerstoneTools.getElementToolStateManager(element);
        if (oldStateManager === undefined) {
            oldStateManager = cornerstoneTools.globalImageIdSpecificToolStateManager;
        }

        var timeSeriesSpecificStateManager = cornerstoneTools.newTimeSeriesSpecificToolStateManager(tools, oldStateManager);
        timeSeriesStateManagers.push(timeSeriesSpecificStateManager);
        cornerstoneTools.setElementToolStateManager(element, timeSeriesSpecificStateManager);
    }

    // module/private exports
    cornerstoneTools.newTimeSeriesSpecificToolStateManager = newTimeSeriesSpecificToolStateManager;
    cornerstoneTools.addTimeSeriesStateManager = addTimeSeriesStateManager;

})(cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/timeSeriesSpecificStateManager.js

// Begin Source: src/stateManagement/toolColorManager.js
(function(cornerstoneTools) {

    'use strict';

    function toolColorManager() {
        //var defaultColor = 'white',activeColor = 'greenyellow',fillColor = 'transparent';
        //sj change
        var defaultColor = 'greenyellow',activeColor = '#E3A000',fillColor = 'transparent';

        // var defaultColor = 'greenyellow',activeColor = '#E3A000',fillColor = 'transparent';

        function setFillColor(color) {
            fillColor = color;
        }

        function getFillColor() {
            return fillColor;
        }

        function setToolColor(color) {
            defaultColor = color;
        }

        function getToolColor() {
            return defaultColor;
        }

        function setActiveToolColor(color) {
            activeColor = color;
        }

        function getActiveToolColor() {
            return activeColor;
        }

        function getColorIfActive(active) {
            return active ? activeColor : defaultColor;
        }

        var toolColors = {
            setFillColor: setFillColor,
            getFillColor: getFillColor,
            setToolColor: setToolColor,
            getToolColor: getToolColor,
            setActiveColor: setActiveToolColor,
            getActiveColor: getActiveToolColor,
            getColorIfActive: getColorIfActive
        };

        return toolColors;
    }

    // module/private exports
    cornerstoneTools.toolColors = toolColorManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/toolColorManager.js

// Begin Source: src/stateManagement/toolCoordinateManager.js
(function(cornerstoneTools) {

    'use strict';

    function toolCoordinateManager(){
        var cooordsData = '';

        function setActiveToolCoords(eventData){
            cooordsData = eventData.currentPoints.canvas;
        }

        function getActiveToolCoords(){
            return cooordsData;
        }

        var toolCoords = {
            setCoords: setActiveToolCoords,
            getCoords: getActiveToolCoords
        };

        return toolCoords;
    }

    // module/private exports
    cornerstoneTools.toolCoordinates = toolCoordinateManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/toolCoordinateManager.js

// Begin Source: src/stateManagement/toolStateManager.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function getElementToolStateManager(element) {
        var enabledImage = cornerstone.getEnabledElement(element);
        // if the enabledImage has no toolStateManager, create a default one for it
        // NOTE: This makes state management element specific
        if (enabledImage.toolStateManager === undefined) {
            enabledImage.toolStateManager = cornerstoneTools.globalImageIdSpecificToolStateManager;
        }

        return enabledImage.toolStateManager;
    }

    // here we add tool state, this is done by tools as well
    // as modules that restore saved state
    function addToolState(element, toolType, data) {
        var toolStateManager = getElementToolStateManager(element);
        toolStateManager.add(element, toolType, data);

        var eventType = 'CornerstoneToolsMeasurementAdded';
        var eventData = {
            toolType: toolType,
            element: element,
            measurementData: data
        };
        $(element).trigger(eventType, eventData);
        // TODO: figure out how to broadcast this change to all enabled elements so they can update the image
        // if this change effects them
    }

    // here you can get state - used by tools as well as modules
    // that save state persistently
    function getToolState(element, toolType) {
        var toolStateManager = getElementToolStateManager(element);
        return toolStateManager.get(element, toolType);
    }

    function removeToolState(element, toolType, data) {
        var toolStateManager = getElementToolStateManager(element);
        var toolData = toolStateManager.get(element, toolType);
        // find this tool data
        var indexOfData = -1;
        for (var i = 0; i < toolData.data.length; i++) {
            if (toolData.data[i] === data) {
                indexOfData = i;
            }
        }

        if (indexOfData !== -1) {
            toolData.data.splice(indexOfData, 1);

            var eventType = 'CornerstoneToolsMeasurementRemoved';
            var eventData = {
                toolType: toolType,
                element: element,
                measurementData: data
            };
            $(element).trigger(eventType, eventData);
        }
    }

    function clearToolState(element, toolType) {
        var toolStateManager = getElementToolStateManager(element);
        var toolData = toolStateManager.get(element, toolType);
        
        // If any toolData actually exists, clear it
        if (toolData !== undefined) {
            toolData.data = [];
        }
    }

    // sets the tool state manager for an element
    function setElementToolStateManager(element, toolStateManager) {
        var enabledImage = cornerstone.getEnabledElement(element);
        enabledImage.toolStateManager = toolStateManager;
    }

    function delLastMeasurement(element, toolType){//zyy add
        var toolStateManager = getElementToolStateManager(element);
        var toolData = toolStateManager.get(element, toolType);
        // console.log(toolStateManager);
    }

    // module/private exports
    cornerstoneTools.addToolState = addToolState;
    cornerstoneTools.getToolState = getToolState;
    cornerstoneTools.removeToolState = removeToolState;
    cornerstoneTools.clearToolState = clearToolState;
    cornerstoneTools.setElementToolStateManager = setElementToolStateManager;
    cornerstoneTools.getElementToolStateManager = getElementToolStateManager;

    cornerstoneTools.delLastMeasurement = delLastMeasurement;
})(cornerstone, cornerstoneTools);
 
// End Source; src/stateManagement/toolStateManager.js

// Begin Source: src/stateManagement/toolStyleManager.js
(function(cornerstoneTools) {

    'use strict';

    function toolStyleManager() {
        var defaultWidth = 1,
            activeWidth = 2;

        function setToolWidth(width){
            defaultWidth = width;
        }

        function getToolWidth(){
            return defaultWidth;
        }

        function setActiveToolWidth(width){
            activeWidth = width;
        }

        function getActiveToolWidth(){
            return activeWidth;
        }

        var toolStyle = {
            setToolWidth: setToolWidth,
            getToolWidth: getToolWidth,
            setActiveWidth: setActiveToolWidth,
            getActiveWidth: getActiveToolWidth
        };

        return toolStyle;
    }

    // module/private exports
    cornerstoneTools.toolStyle = toolStyleManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/toolStyleManager.js

// Begin Source: src/stateManagement/touchSettingsManager.js
(function(cornerstoneTools) {

    'use strict';

    function touchSettingsManager() {
        var defaultDistanceFromTouch = {
            x: 0,
            y: -55
        };

        function setToolDistanceFromTouch(distance){
            defaultDistanceFromTouch = distance;
        }

        function getToolDistanceFromTouch(){
            return defaultDistanceFromTouch;
        }

        var touchSettings = {
            setToolDistanceFromTouch: setToolDistanceFromTouch,
            getToolDistanceFromTouch: getToolDistanceFromTouch,
        };

        return touchSettings;
    }

    // module/private exports
    cornerstoneTools.touchSettings = touchSettingsManager();

})(cornerstoneTools);
 
// End Source; src/stateManagement/touchSettingsManager.js

// Begin Source: src/synchronization/panZoomSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function synchronizes the target zoom and pan to match the source
    function panZoomSynchronizer(synchronizer, sourceElement, targetElement) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }
        // get the source and target viewports
        var sourceViewport = cornerstone.getViewport(sourceElement);
        var targetViewport = cornerstone.getViewport(targetElement);

        // do nothing if the scale and translation are the same
        if (targetViewport.scale === sourceViewport.scale && targetViewport.translation.x === sourceViewport.translation.x && targetViewport.translation.y === sourceViewport.translation.y) {
            return;
        }

        // scale and/or translation are different, sync them
        targetViewport.scale = sourceViewport.scale;
        targetViewport.translation.x = sourceViewport.translation.x;
        targetViewport.translation.y = sourceViewport.translation.y;
        synchronizer.setViewport(targetElement, targetViewport);
    }

    // module/private exports
    cornerstoneTools.panZoomSynchronizer = panZoomSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/panZoomSynchronizer.js

// Begin Source: src/synchronization/stackImageIndexSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function causes the image in the target stack to be set to the one closest
    // to the image in the source stack by image position
    function stackImageIndexSynchronizer(synchronizer, sourceElement, targetElement) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }

        var sourceStackToolDataSource = cornerstoneTools.getToolState(sourceElement, 'stack');
        var sourceStackData = sourceStackToolDataSource.data[0];
        var targetStackToolDataSource = cornerstoneTools.getToolState(targetElement, 'stack');
        var targetStackData = targetStackToolDataSource.data[0];

        var newImageIdIndex = sourceStackData.currentImageIdIndex;

        // clamp the index
        newImageIdIndex = Math.min(Math.max(newImageIdIndex, 0), targetStackData.imageIds.length - 1);

        // Do nothing if the index has not changed
        if (newImageIdIndex === targetStackData.currentImageIdIndex) {
            return;
        }

        var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
        var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
        var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

        if (startLoadingHandler) {
            startLoadingHandler(targetElement);
        }

        var loader;
        if (targetStackData.preventCache === true) {
            loader = cornerstone.loadImage(targetStackData.imageIds[newImageIdIndex]);
        } else {
            loader = cornerstone.loadAndCacheImage(targetStackData.imageIds[newImageIdIndex]);
        }

        loader.then(function(image) {
            var viewport = cornerstone.getViewport(targetElement);
            targetStackData.currentImageIdIndex = newImageIdIndex;
            synchronizer.displayImage(targetElement, image, viewport);
            if (endLoadingHandler) {
                endLoadingHandler(targetElement);
            }
        }, function(error) {
            var imageId = targetStackData.imageIds[newImageIdIndex];
            if (errorLoadingHandler) {
                errorLoadingHandler(targetElement, imageId, error);
            }
        });
    }

    // module/private exports
    cornerstoneTools.stackImageIndexSynchronizer = stackImageIndexSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/stackImageIndexSynchronizer.js

// Begin Source: src/synchronization/stackImagePositionOffsetSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function causes the image in the target stack to be set to the one closest
    // to the image in the source stack by image position

    // In the future we will want to have a way to manually register links sets of the same orientation (e.g. an axial link set from a prior with an axial link set of a current).  The user could do this by scrolling the two stacks to a similar location and then doing a user action (e.g. right click link) at which point the system will capture the delta between the image position (patient) of both stacks and use that to sync them.  This offset will need to be adjustable.

    function stackImagePositionOffsetSynchronizer(synchronizer, sourceElement, targetElement, eventData, positionDifference) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }

        var sourceEnabledElement = cornerstone.getEnabledElement(sourceElement);
        var sourceImagePlane = cornerstoneTools.metaData.get('imagePlane', sourceEnabledElement.image.imageId);
        var sourceImagePosition = sourceImagePlane.imagePositionPatient;

        var stackToolDataSource = cornerstoneTools.getToolState(targetElement, 'stack');
        var stackData = stackToolDataSource.data[0];

        var minDistance = Number.MAX_VALUE;
        var newImageIdIndex = -1;

        if (!positionDifference) {
            return;
        }

        var finalPosition = sourceImagePosition.clone().add(positionDifference);

        stackData.imageIds.forEach(function(imageId, index) {
            var imagePlane = cornerstoneTools.metaData.get('imagePlane', imageId);
            var imagePosition = imagePlane.imagePositionPatient;
            var distance = finalPosition.distanceToSquared(imagePosition);

            if (distance < minDistance) {
                minDistance = distance;
                newImageIdIndex = index;
            }
        });

        if (newImageIdIndex === stackData.currentImageIdIndex || newImageIdIndex === -1) {
            return;
        }

        var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
        var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
        var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

        if (startLoadingHandler) {
            startLoadingHandler(targetElement);
        }

        var loader;
        if (stackData.preventCache === true) {
            loader = cornerstone.loadImage(stackData.imageIds[newImageIdIndex]);
        } else {
            loader = cornerstone.loadAndCacheImage(stackData.imageIds[newImageIdIndex]);
        }

        loader.then(function(image) {
            var viewport = cornerstone.getViewport(targetElement);
            stackData.currentImageIdIndex = newImageIdIndex;
            synchronizer.displayImage(targetElement, image, viewport);
            if (endLoadingHandler) {
                endLoadingHandler(targetElement);
            }
        }, function(error) {
            var imageId = stackData.imageIds[newImageIdIndex];
            if (errorLoadingHandler) {
                errorLoadingHandler(targetElement, imageId, error);
            }
        });
    }

    // module/private exports
    cornerstoneTools.stackImagePositionOffsetSynchronizer = stackImagePositionOffsetSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/stackImagePositionOffsetSynchronizer.js

// Begin Source: src/synchronization/stackImagePositionSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function causes the image in the target stack to be set to the one closest
    // to the image in the source stack by image position
    function stackImagePositionSynchronizer(synchronizer, sourceElement, targetElement) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }

        var sourceImage = cornerstone.getEnabledElement(sourceElement).image;
        var sourceImagePlane = cornerstoneTools.metaData.get('imagePlane', sourceImage.imageId);
        var sourceImagePosition = sourceImagePlane.imagePositionPatient;

        var stackToolDataSource = cornerstoneTools.getToolState(targetElement, 'stack');
        var stackData = stackToolDataSource.data[0];

        var minDistance = Number.MAX_VALUE;
        var newImageIdIndex = -1;

        $.each(stackData.imageIds, function(index, imageId) {
            var imagePlane = cornerstoneTools.metaData.get('imagePlane', imageId);
            var imagePosition = imagePlane.imagePositionPatient;
            var distance = imagePosition.distanceToSquared(sourceImagePosition);
            //console.log(index + '=' + distance);
            if (distance < minDistance) {
                minDistance = distance;
                newImageIdIndex = index;
            }
        });

        if (newImageIdIndex === stackData.currentImageIdIndex) {
            return;
        }

        var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
        var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
        var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

        if (startLoadingHandler) {
            startLoadingHandler(targetElement);
        }

        if (newImageIdIndex !== -1) {
            var loader;
            if (stackData.preventCache === true) {
                loader = cornerstone.loadImage(stackData.imageIds[newImageIdIndex]);
            } else {
                loader = cornerstone.loadAndCacheImage(stackData.imageIds[newImageIdIndex]);
            }

            loader.then(function(image) {
                var viewport = cornerstone.getViewport(targetElement);
                stackData.currentImageIdIndex = newImageIdIndex;
                synchronizer.displayImage(targetElement, image, viewport);
                if (endLoadingHandler) {
                    endLoadingHandler(targetElement);
                }
            }, function(error) {
                var imageId = stackData.imageIds[newImageIdIndex];
                if (errorLoadingHandler) {
                    errorLoadingHandler(targetElement, imageId, error);
                }
            });
        }
    }

    // module/private exports
    cornerstoneTools.stackImagePositionSynchronizer = stackImagePositionSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/stackImagePositionSynchronizer.js

// Begin Source: src/synchronization/stackScrollSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function causes any scrolling actions within the stack to propagate to 
    // all of the other viewports that are synced
    function stackScrollSynchronizer(synchronizer, sourceElement, targetElement, eventData) {
        // If the target and source are the same, stop
        if (sourceElement === targetElement) {
            return;
        }

        // If there is no event, or direction is 0, stop
        if (!eventData || !eventData.direction) {
            return;
        }

        // Get the stack of the target viewport
        var stackToolDataSource = cornerstoneTools.getToolState(targetElement, 'stack');
        var stackData = stackToolDataSource.data[0];

        // Get the new index for the stack
        var newImageIdIndex = stackData.currentImageIdIndex + eventData.direction;

        // Ensure the index does not exceed the bounds of the stack
        newImageIdIndex = Math.min(Math.max(newImageIdIndex, 0), stackData.imageIds.length - 1);

        // If the index has not changed, stop here
        if (stackData.currentImageIdIndex === newImageIdIndex) {
            return;
        }

        var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
        var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
        var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

        if (startLoadingHandler) {
            startLoadingHandler(targetElement);
        }

        var loader;
        if (stackData.preventCache === true) {
            loader = cornerstone.loadImage(stackData.imageIds[newImageIdIndex]);
        } else {
            loader = cornerstone.loadAndCacheImage(stackData.imageIds[newImageIdIndex]);
        }

        loader.then(function(image) {
            var viewport = cornerstone.getViewport(targetElement);
            stackData.currentImageIdIndex = newImageIdIndex;
            synchronizer.displayImage(targetElement, image, viewport);
            if (endLoadingHandler) {
                endLoadingHandler(targetElement);
            }
        }, function(error) {
            var imageId = stackData.imageIds[newImageIdIndex];
            if (errorLoadingHandler) {
                errorLoadingHandler(targetElement, imageId, error);
            }
        });
    }

    // module/private exports
    cornerstoneTools.stackScrollSynchronizer = stackScrollSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/stackScrollSynchronizer.js

// Begin Source: src/synchronization/synchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This object is responsible for synchronizing target elements when an event fires on a source
    // element
    function Synchronizer(event, handler) {

        var that = this;
        var sourceElements = []; // source elements fire the events we want to synchronize to
        var targetElements = []; // target elements we want to synchronize to source elements

        var ignoreFiredEvents = false;
        var initialData = {};
        var eventHandler = handler;

        this.setHandler = function(handler) {
            eventHandler = handler;
        };

        this.getHandler = function() {
            return eventHandler;
        };

        this.getDistances = function() {
            if (!sourceElements.length || !targetElements.length) {
                return;
            }

            initialData.distances = {};
            initialData.imageIds = {
                sourceElements: [],
                targetElements: []
            };

            sourceElements.forEach(function(sourceElement) {
                var sourceEnabledElement = cornerstone.getEnabledElement(sourceElement);
                if (!sourceEnabledElement || !sourceEnabledElement.image) {
                    return;
                }

                var sourceImageId = sourceEnabledElement.image.imageId;
                var sourceImagePlane = cornerstoneTools.metaData.get('imagePlane', sourceImageId);
                if (!sourceImagePlane || !sourceImagePlane.imagePositionPatient) {
                    return;
                }

                var sourceImagePosition = sourceImagePlane.imagePositionPatient;

                if (initialData.hasOwnProperty(sourceEnabledElement)) {
                    return;
                } else {
                    initialData.distances[sourceImageId] = {};
                }

                initialData.imageIds.sourceElements.push(sourceImageId);

                targetElements.forEach(function(targetElement) {
                    var targetEnabledElement = cornerstone.getEnabledElement(targetElement);
                    if (!targetEnabledElement || !targetEnabledElement.image) {
                        return;
                    }

                    var targetImageId = targetEnabledElement.image.imageId;

                    initialData.imageIds.targetElements.push(targetImageId);

                    if (sourceElement === targetElement) {
                        return;
                    }

                    if (sourceImageId === targetImageId) {
                        return;
                    }

                    if (initialData.distances[sourceImageId].hasOwnProperty(targetImageId)) {
                        return;
                    }

                    var targetImagePlane = cornerstoneTools.metaData.get('imagePlane', targetImageId);
                    if (!targetImagePlane || !targetImagePlane.imagePositionPatient) {
                        return;
                    }

                    var targetImagePosition = targetImagePlane.imagePositionPatient;

                    initialData.distances[sourceImageId][targetImageId] = targetImagePosition.clone().sub(sourceImagePosition);
                });

                if (!Object.keys(initialData.distances[sourceImageId]).length) {
                    delete initialData.distances[sourceImageId];
                }
            });
        };

        function fireEvent(sourceElement, eventData) {
            // Broadcast an event that something changed
            if (!sourceElements.length || !targetElements.length) {
                return;
            }


            ignoreFiredEvents = true;
            targetElements.forEach(function(targetElement) {

                var targetIndex = targetElements.indexOf(targetElement);
                if (targetIndex === -1) {
                    return;
                }

                var targetImageId = initialData.imageIds.targetElements[targetIndex];
                var sourceIndex = sourceElements.indexOf(sourceElement);
                if (sourceIndex === -1) {
                    return;
                }

                var sourceImageId = initialData.imageIds.sourceElements[sourceIndex];
                
                var positionDifference;
                if (sourceImageId === targetImageId) {
                    positionDifference = 0;
                } else {
                    if(sourceImageId==undefined)
                    {
                        positionDifference = 0;//修复定位线bug
                    }
                    else{
                        positionDifference = initialData.distances[sourceImageId][targetImageId];
                    }
                }
                
                eventHandler(that, sourceElement, targetElement, eventData, positionDifference);
            });
            ignoreFiredEvents = false;
        }

        function onEvent(e, eventData) {
            if (ignoreFiredEvents === true) {
                return;
            }

            fireEvent(e.currentTarget, eventData);
        }

        // adds an element as a source
        this.addSource = function(element) {
            // Return if this element was previously added
            var index = sourceElements.indexOf(element);
            if (index !== -1) {
                return;
            }

            // Add to our list of enabled elements
            sourceElements.push(element);

            // subscribe to the event
            $(element).on(event, onEvent);

            // Update the inital distances between elements
            that.getDistances();

            that.updateDisableHandlers();
        };

        // adds an element as a target
        this.addTarget = function(element) {
            // Return if this element was previously added
            var index = targetElements.indexOf(element);
            if (index !== -1) {
                return;
            }

            // Add to our list of enabled elements
            targetElements.push(element);

            // Update the inital distances between elements
            that.getDistances();

            // Invoke the handler for this new target element
            eventHandler(that, element, element, 0);

            that.updateDisableHandlers();
        };

        // adds an element as both a source and a target
        this.add = function(element) {
            that.addSource(element);
            that.addTarget(element);
        };

        // removes an element as a source
        this.removeSource = function(element) {
            // Find the index of this element
            var index = sourceElements.indexOf(element);
            if (index === -1) {
                return;
            }

            // remove this element from the array
            sourceElements.splice(index, 1);

            // stop listening for the event
            $(element).off(event, onEvent);

            // Update the inital distances between elements
            that.getDistances();

            // Update everyone listening for events
            fireEvent(element);
            that.updateDisableHandlers();
        };

        // removes an element as a target
        this.removeTarget = function(element) {
            // Find the index of this element
            var index = targetElements.indexOf(element);
            if (index === -1) {
                return;
            }

            // remove this element from the array
            targetElements.splice(index, 1);

            // Update the inital distances between elements
            that.getDistances();

            // Invoke the handler for the removed target
            eventHandler(that, element, element, 0);
            that.updateDisableHandlers();
        };

        // removes an element as both a source and target
        this.remove = function(element) {
            that.removeTarget(element);
            that.removeSource(element);
        };

        // returns the source elements
        this.getSourceElements = function() {
            return sourceElements;
        };

        // returns the target elements
        this.getTargetElements = function() {
            return targetElements;
        };

        this.displayImage = function(element, image, viewport) {
            ignoreFiredEvents = true;
            cornerstone.displayImage(element, image, viewport);
            ignoreFiredEvents = false;
        };

        this.setViewport = function(element, viewport) {
            ignoreFiredEvents = true;
            cornerstone.setViewport(element, viewport);
            ignoreFiredEvents = false;
        };

        function disableHandler(e, eventData) {
            var element = eventData.element;
            that.remove(element);
        }

        this.updateDisableHandlers = function() {
            var elements = $.unique(sourceElements.concat(targetElements));
            elements.forEach(function(element) {
                $(element).off('CornerstoneElementDisabled', disableHandler);
                $(element).on('CornerstoneElementDisabled', disableHandler);
            });
        };

        this.destroy = function() {
            var elements = $.unique(sourceElements.concat(targetElements));
            elements.forEach(function(element) {
                that.remove(element);
            });
        };
    }

    // module/private exports
    cornerstoneTools.Synchronizer = Synchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/synchronizer.js

// Begin Source: src/synchronization/updateImageSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function causes the target image to be drawn immediately
    function updateImageSynchronizer(synchronizer, sourceElement, targetElement) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }

        cornerstone.updateImage(targetElement);
    }

    // module/private exports
    cornerstoneTools.updateImageSynchronizer = updateImageSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/updateImageSynchronizer.js

// Begin Source: src/synchronization/wwwcSynchronizer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // This function synchronizes the target element ww/wc to match the source element
    function wwwcSynchronizer(synchronizer, sourceElement, targetElement) {

        // ignore the case where the source and target are the same enabled element
        if (targetElement === sourceElement) {
            return;
        }
        // get the source and target viewports
        var sourceViewport = cornerstone.getViewport(sourceElement);
        var targetViewport = cornerstone.getViewport(targetElement);

        // do nothing if the ww/wc already match
        if (targetViewport.voi.windowWidth === sourceViewport.voi.windowWidth && targetViewport.voi.windowCenter === sourceViewport.voi.windowCenter && targetViewport.invert === sourceViewport.invert) {
            return;
        }

        // www/wc are different, sync them
        targetViewport.voi.windowWidth = sourceViewport.voi.windowWidth;
        targetViewport.voi.windowCenter = sourceViewport.voi.windowCenter;
        targetViewport.invert = sourceViewport.invert;
        synchronizer.setViewport(targetElement, targetViewport);
    }

    // module/private exports
    cornerstoneTools.wwwcSynchronizer = wwwcSynchronizer;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/synchronization/wwwcSynchronizer.js

// Begin Source: src/timeSeriesTools/ProbeTool4D.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'probe4D';

    function updateLineSample(measurementData) {
        var samples = [];

        measurementData.timeSeries.stacks.forEach(function(stack) {
            var loader;
            if (stack.preventCache === true) {
                loader = cornerstone.loadImage(stack.imageIds[measurementData.imageIdIndex]);
            } else {
                loader = cornerstone.loadAndCacheImage(stack.imageIds[measurementData.imageIdIndex]);
            }

            loader.then(function(image) {
                var offset = Math.round(measurementData.handles.end.x) + Math.round(measurementData.handles.end.y) * image.width;
                var sample = image.getPixelData()[offset];
                samples.push(sample);
                //console.log(sample);
            });
        });
        measurementData.lineSample.set(samples);
    }

    ///////// BEGIN ACTIVE TOOL ///////
    function createNewMeasurement(mouseEventData) {
        var timeSeriestoolData = cornerstoneTools.getToolState(mouseEventData.element, 'timeSeries');
        if (timeSeriestoolData === undefined || timeSeriestoolData.data === undefined || timeSeriestoolData.data.length === 0) {
            return;
        }

        var timeSeries = timeSeriestoolData.data[0];

        // create the measurement data for this tool with the end handle activated
        var measurementData = {
            timeSeries: timeSeries,
            lineSample: new cornerstoneTools.LineSampleMeasurement(),
            imageIdIndex: timeSeries.stacks[timeSeries.currentStackIndex].currentImageIdIndex,
            visible: true,
            handles: {
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };
        updateLineSample(measurementData);
        cornerstoneTools.MeasurementManager.add(measurementData);
        return measurementData;
    }
    ///////// END ACTIVE TOOL ///////

    ///////// BEGIN IMAGE RENDERING ///////

    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        cornerstone.setToPixelCoordinateSystem(eventData.enabledElement, context);
        var color = 'white';

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();
            var data = toolData.data[i];

            // draw the handles
            context.beginPath();
            cornerstoneTools.drawHandles(context, eventData, data.handles, color);
            context.stroke();

            // Draw text
            var fontParameters = cornerstoneTools.setContextToDisplayFontSize(eventData.enabledElement, eventData.canvasContext, 15);
            context.font = '' + fontParameters.fontSize + 'px Arial';

            // translate the x/y away from the cursor
            var x = Math.round(data.handles.end.x);
            var y = Math.round(data.handles.end.y);
            var textX = data.handles.end.x + 3;
            var textY = data.handles.end.y - 3;

            context.fillStyle = color;

            context.fillText('' + x + ',' + y, textX, textY);

            context.restore();
        }
    }
    ///////// END IMAGE RENDERING ///////

    // module exports
    cornerstoneTools.probeTool4D = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        toolType: toolType
    });

})($, cornerstone, cornerstoneTools);
 
// End Source; src/timeSeriesTools/ProbeTool4D.js

// Begin Source: src/timeSeriesTools/timeSeries.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function incrementTimePoint(element, timePoints, wrap) {
        var toolData = cornerstoneTools.getToolState(element, 'timeSeries');
        if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {//console.log(toolData);
            return;
        }

        var timeSeriesData = toolData.data[0];
        var currentStack = timeSeriesData.stacks[timeSeriesData.currentStackIndex];
        var currentImageIdIndex = currentStack.currentImageIdIndex;
        var newStackIndex = timeSeriesData.currentStackIndex + timePoints;

        // loop around if we go outside the stack
        if (wrap) {
            if (newStackIndex >= timeSeriesData.stacks.length) {
                newStackIndex = 0;
            }

            if (newStackIndex < 0) {
                newStackIndex = timeSeriesData.stacks.length - 1;
            }
        } else {
            newStackIndex = Math.min(timeSeriesData.stacks.length - 1, newStackIndex);
            newStackIndex = Math.max(0, newStackIndex);
        }

        if (newStackIndex !== timeSeriesData.currentStackIndex) {
            var viewport = cornerstone.getViewport(element);
            var newStack = timeSeriesData.stacks[newStackIndex];

            var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
            var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
            var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

            if (startLoadingHandler) {
                startLoadingHandler(element);
            }

            var loader;
            if (newStack.preventCache === true) {
                loader = cornerstone.loadImage(newStack.imageIds[currentImageIdIndex]);
            } else {
                loader = cornerstone.loadAndCacheImage(newStack.imageIds[currentImageIdIndex]);
            }

            loader.then(function(image) {
                if (timeSeriesData.currentImageIdIndex !== currentImageIdIndex) {
                    newStack.currentImageIdIndex = currentImageIdIndex;
                    timeSeriesData.currentStackIndex = newStackIndex;
                    cornerstone.displayImage(element, image, viewport);
                    if (endLoadingHandler) {
                        endLoadingHandler(element);
                    }
                }
            }, function(error) {
                var imageId = newStack.imageIds[currentImageIdIndex];
                if (errorLoadingHandler) {
                    errorLoadingHandler(element, imageId, error);
                }
            });
        }
    }

    // module/private exports
    cornerstoneTools.incrementTimePoint = incrementTimePoint;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/timeSeriesTools/timeSeries.js

// Begin Source: src/timeSeriesTools/timeSeriesPlayer.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'timeSeriesPlayer';

    /**
     * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is
     * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.
     * The element must be a stack of images
     * @param element
     * @param framesPerSecond
     */
    function playClip(element, framesPerSecond) {
        if (element === undefined) {
            throw 'playClip: element must not be undefined';
        }

        if (framesPerSecond === undefined) {
            framesPerSecond = 30;
        }

        var timeSeriesToolData = cornerstoneTools.getToolState(element, 'timeSeries');
        if (timeSeriesToolData === undefined || timeSeriesToolData.data === undefined || timeSeriesToolData.data.length === 0) {
            return;
        }

        var playClipToolData = cornerstoneTools.getToolState(element, toolType);
        var playClipData;
        if (playClipToolData === undefined || playClipToolData.data.length === 0) {
            playClipData = {
                intervalId: undefined,
                framesPerSecond: framesPerSecond,
                lastFrameTimeStamp: undefined,
                frameRate: 0
            };
            cornerstoneTools.addToolState(element, toolType, playClipData);
        } else {
            playClipData = playClipToolData.data[0];
            playClipData.framesPerSecond = framesPerSecond;
        }

        // if already playing, do not set a new interval
        if (playClipData.intervalId !== undefined) {
            return;
        }

        playClipData.intervalId = setInterval(function() {
            if (playClipData.framesPerSecond > 0) {
                cornerstoneTools.incrementTimePoint(element, 1, true);
            } else {
                cornerstoneTools.incrementTimePoint(element, -1, true);
            }
        }, 1000 / Math.abs(playClipData.framesPerSecond));
    }

    /**
     * Stops an already playing clip.
     * * @param element
     */
    function stopClip(element) {
        var playClipToolData = cornerstoneTools.getToolState(element, toolType);
        var playClipData;
        if (playClipToolData === undefined || playClipToolData.data.length === 0) {
            return;
        } else {
            playClipData = playClipToolData.data[0];
        }

        clearInterval(playClipData.intervalId);
        playClipData.intervalId = undefined;
    }

    // module/private exports
    cornerstoneTools.timeSeriesPlayer = {
        start: playClip,
        stop: stopClip
    };

})($, cornerstone, cornerstoneTools);
 
// End Source; src/timeSeriesTools/timeSeriesPlayer.js

// Begin Source: src/timeSeriesTools/timeSeriesScroll.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function mouseUpCallback(e, eventData) {
        $(eventData.element).off('CornerstoneToolsMouseDrag', mouseDragCallback);
        $(eventData.element).off('CornerstoneToolsMouseUp', mouseUpCallback);
        $(eventData.element).off('CornerstoneToolsMouseClick', mouseUpCallback);
    }

    function mouseDownCallback(e, eventData) {
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {

            var mouseDragEventData = {
                deltaY: 0,
                options: e.data.options
            };
            $(eventData.element).on('CornerstoneToolsMouseDrag', mouseDragEventData, mouseDragCallback);
            $(eventData.element).on('CornerstoneToolsMouseUp', mouseUpCallback);
            $(eventData.element).on('CornerstoneToolsMouseClick', mouseUpCallback);
            e.stopImmediatePropagation();
            return false;
        }
    }

    function mouseDragCallback(e, eventData) {
        e.data.deltaY += eventData.deltaPoints.page.y;

        var toolData = cornerstoneTools.getToolState(eventData.element, 'timeSeries');
        if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {
            return;
        }

        var timeSeriesData = toolData.data[0];

        var pixelsPerTimeSeries = $(eventData.element).height() / timeSeriesData.stacks.length ;
        if (e.data.options !== undefined && e.data.options.timeSeriesScrollSpeed !== undefined) {
            pixelsPerTimeSeries = e.data.options.timeSeriesScrollSpeed;
        }

        if (e.data.deltaY >= pixelsPerTimeSeries || e.data.deltaY <= -pixelsPerTimeSeries) {
            var timeSeriesDelta = Math.round(e.data.deltaY / pixelsPerTimeSeries);
            var timeSeriesDeltaMod = e.data.deltaY % pixelsPerTimeSeries;
            cornerstoneTools.incrementTimePoint(eventData.element, timeSeriesDelta);
            e.data.deltaY = timeSeriesDeltaMod;
        }

        return false; // false = cases jquery to preventDefault() and stopPropagation() this event
    }

    function mouseWheelCallback(e, eventData) {
        var images = -eventData.direction;
        cornerstoneTools.incrementTimePoint(eventData.element, images);
    }

    function onDrag(e) {
        var mouseMoveData = e.originalEvent.detail;
        var eventData = {
            deltaY: 0
        };
        eventData.deltaY += mouseMoveData.deltaPoints.page.y;

        var toolData = cornerstoneTools.getToolState(mouseMoveData.element, 'stack');
        if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {
            return;
        }

        if (eventData.deltaY >= 3 || eventData.deltaY <= -3) {
            var timeSeriesDelta = eventData.deltaY / 3;
            var timeSeriesDeltaMod = eventData.deltaY % 3;
            cornerstoneTools.setTimePoint(eventData.element, timeSeriesDelta);
            eventData.deltaY = timeSeriesDeltaMod;
        }

        return false; // false = cases jquery to preventDefault() and stopPropagation() this event
    }

    // module/private exports
    cornerstoneTools.timeSeriesScroll = cornerstoneTools.simpleMouseButtonTool(mouseDownCallback);
    cornerstoneTools.timeSeriesScrollWheel = cornerstoneTools.mouseWheelTool(mouseWheelCallback);
    cornerstoneTools.timeSeriesScrollTouchDrag = cornerstoneTools.touchDragTool(onDrag);

})($, cornerstone, cornerstoneTools);
 
// End Source; src/timeSeriesTools/timeSeriesScroll.js

// Begin Source: src/util/calculateSUV.js
(function(cornerstoneTools) {

    'use strict';

    function calculateSUV(image, storedPixelValue) {
        // if no dicom data set, return undefined
        if (image.data === undefined) {
            return undefined;
        }
        
        // image must be PET
        if (image.data.string('x00080060') !== 'PT') {
            return undefined;
        }

        var modalityPixelValue = storedPixelValue * image.slope + image.intercept;

        var patientWeight = image.data.floatString('x00101030'); // in kg
        if (patientWeight === undefined) {
            return undefined;
        }

        var petSequence = image.data.elements.x00540016;
        if (petSequence === undefined) {
            return undefined;
        }

        petSequence = petSequence.items[0].dataSet;
        var startTime = petSequence.time('x00181072');
        var totalDose = petSequence.floatString('x00181074');
        var halfLife = petSequence.floatString('x00181075');
        var acquisitionTime = image.data.time('x00080032');
        
        if (!startTime || !totalDose || !halfLife || !acquisitionTime) {
            return undefined;
        }

        var acquisitionTimeInSeconds = acquisitionTime.fractionalSeconds + acquisitionTime.seconds + acquisitionTime.minutes * 60 + acquisitionTime.hours * 60 * 60;
        var injectionStartTimeInSeconds = startTime.fractionalSeconds + startTime.seconds + startTime.minutes * 60 + startTime.hours * 60 * 60;
        var durationInSeconds = acquisitionTimeInSeconds - injectionStartTimeInSeconds;
        var correctedDose = totalDose * Math.exp(-durationInSeconds * Math.log(2) / halfLife);
        var suv = modalityPixelValue * patientWeight / correctedDose * 1000;

        return suv;
    }

    // module exports
    cornerstoneTools.calculateSUV = calculateSUV;

})(cornerstoneTools);
 
// End Source; src/util/calculateSUV.js

// Begin Source: src/util/copyPoints.js
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    function copyPoints(points) {
        var page = cornerstoneMath.point.copy(points.page);
        var image = cornerstoneMath.point.copy(points.image);
        var client = cornerstoneMath.point.copy(points.client);
        var canvas = cornerstoneMath.point.copy(points.canvas);
        return {
            page: page,
            image: image,
            client: client,
            canvas: canvas
        };
    }

    // module exports
    cornerstoneTools.copyPoints = copyPoints;

})($, cornerstone, cornerstoneMath, cornerstoneTools);
 
// End Source; src/util/copyPoints.js

// Begin Source: src/util/drawArrow.js
(function(cornerstoneTools) {

    'use strict';

    function drawArrow(context, start, end, color, lineWidth) {
        //variables to be used when creating the arrow
        var headLength = 10;

        var angle = Math.atan2(end.y - start.y, end.x - start.x);

        //starting path of the arrow from the start square to the end square and drawing the stroke
        context.beginPath();
        context.moveTo(start.x, start.y);
        context.lineTo(end.x, end.y);
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.stroke();

        //starting a new path from the head of the arrow to one of the sides of the point
        context.beginPath();
        context.moveTo(end.x, end.y);
        context.lineTo(end.x - headLength * Math.cos(angle - Math.PI / 7), end.y - headLength * Math.sin(angle - Math.PI / 7));

        //path from the side point of the arrow, to the other side point
        context.lineTo(end.x - headLength * Math.cos(angle + Math.PI / 7), end.y - headLength * Math.sin(angle + Math.PI / 7));

        //path from the side point back to the tip of the arrow, and then again to the opposite side point
        context.lineTo(end.x, end.y);
        context.lineTo(end.x - headLength * Math.cos(angle - Math.PI / 7), end.y - headLength * Math.sin(angle - Math.PI / 7));

        //draws the paths created above
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.stroke();
        context.fillStyle = color;
        context.fill();
    }

    // Module exports
    cornerstoneTools.drawArrow = drawArrow;

})(cornerstoneTools);
 
// End Source; src/util/drawArrow.js

// Begin Source: src/util/drawEllipse.js
(function(cornerstoneTools) {

    'use strict';

    // http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
    function drawEllipse(context, x, y, w, h) {
        var kappa = 0.5522848,
            ox = (w / 2) * kappa, // control point offset horizontal
            oy = (h / 2) * kappa, // control point offset vertical
            xe = x + w, // x-end
            ye = y + h, // y-end
            xm = x + w / 2, // x-middle
            ym = y + h / 2; // y-middle

        context.beginPath();
        context.moveTo(x, ym);
        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        context.closePath();
        context.stroke();
    }

    // Module exports
    cornerstoneTools.drawEllipse = drawEllipse;

})(cornerstoneTools);
 
// End Source; src/util/drawEllipse.js

// Begin Source: src/util/drawTextBox.js
(function(cornerstoneTools) {

    'use strict';

    function drawTextBox(context, textLines, x, y, color,widthIn) {
        if (Object.prototype.toString.call(textLines) !== '[object Array]') {
            textLines = [ textLines ];
        }

        var padding = 5,
              font = cornerstoneTools.textStyle.getFont(),
              fontSize = cornerstoneTools.textStyle.getFontSize(),

            backgroundColor = cornerstoneTools.textStyle.getBackgroundColor();


        context.save();
        context.font = font;
        context.textBaseline = 'top';
        context.strokeStyle = color;

        // Find the longest text width in the array of text data
        var maxWidth = 0;
        textLines.forEach(function(text) {
            // Get the text width in the current font
            var width = context.measureText(text).width;

            // Find the maximum with for all the text rows;
            maxWidth = Math.max(maxWidth, width);
        });

        //sj width add
        if(widthIn)//如果传入了widthIn参数则作处理，没传入的情况不作处理
        {
            maxWidth =widthIn+10  ;//加10是因为文本包含不完全，半个字符在外面（原因我也不知道）
        }
        //sj add width end

        // Draw the background box with padding
        //  context.fillStyle = backgroundColor;
        //sj change  background color
             context.fillStyle="rgba(0,0,0,0.7)";//更改背景色与透明度



        //  sj change  background color  end
        // Calculate the bounding box for this text box
        var boundingBox = {
            left: x,
            top: y,
            width: maxWidth + (padding * 2),
            // height: textLines.length * (fontSize + (padding * 2))
        //    sj change
            height: textLines.length * (fontSize + (padding+1))//padding=5
        };

          context.fillRect(boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height);

        // Draw each of the text lines on top of the background box
        textLines.forEach(function(text, index) {
            // console.log(color);
             context.fillStyle = color;
            context.fillText(text, x + padding, y + fontSize * index + padding);

        });

        context.restore();

        // Return the bounding box so it can be used for pointNearHandle
        return boundingBox;
    }

    // module exports
    cornerstoneTools.drawTextBox = drawTextBox;

})(cornerstoneTools);
// End Source; src/util/drawTextBox.js

// Begin Source: src/util/drawTextBox.js  sj扩展用于绘制方向标签
(function(cornerstoneTools) {

    'use strict';

    function drawMarkTextBox(context,font,fontSize, textLines, x, y, color,widthIn) {
        if (Object.prototype.toString.call(textLines) !== '[object Array]') {
            textLines = [ textLines ];
        }

        var padding = 5,
        // font = cornerstoneTools.textStyle.getFont(),
        // fontSize = cornerstoneTools.textStyle.getFontSize(),

            backgroundColor = cornerstoneTools.textStyle.getBackgroundColor();

        // console.log(font,fontSize);
        // console.log(context);
        context.save();


        var canvW=context.canvas.width;
        var canvH=context.canvas.height;
        fontSize=canvH*0.1*0.5;//控制标识字体大小
        font=fontSize+"px Arixal";
        context.font = font;
        context.textBaseline = 'top';
        context.strokeStyle = color;

        // Find the longest text width in the array of text data
        var maxWidth = 0;
        textLines.forEach(function(text) {
            // Get the text width in the current font
            var width = context.measureText(text).width;

            // Find the maximum with for all the text rows;
            maxWidth = Math.max(maxWidth, width);
        });

        //sj width add
        if(widthIn)//如果传入了widthIn参数则作处理，没传入的情况不作处理
        {
            maxWidth =widthIn+10  ;//加10是因为文本包含不完全，半个字符在外面（原因我也不知道）
        }
        //sj add width end

        // Draw the background box with padding
        //  context.fillStyle = backgroundColor;
        //sj change  background color
        context.fillStyle="rgba(0,0,0,1)";//更改背景色与透明度



        //  sj change  background color  end
        // Calculate the bounding box for this text box
        var boundingBox = {
            left: x,
            top: y,
            width: maxWidth + (padding * 2),
            // height: textLines.length * (fontSize + (padding * 2))
            //    sj change
            height: textLines.length * (fontSize + (padding+1))//padding=5
        };

        // context.fillRect(boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height);

        // Draw each of the text lines on top of the background box
        textLines.forEach(function(text, index) {
           context.fillStyle = color;
            // console.log( x , y );
           // context.fillStyle = "#ffffff";
            context.fillText(text, x  , y + fontSize * (index) );
            // context.fillText(text, x, y + fontSize * index);
        });
        context.restore();
        // Return the bounding box so it can be used for pointNearHandle
        return boundingBox;
    }

    // module exports
    cornerstoneTools.drawMarkTextBox = drawMarkTextBox;

})(cornerstoneTools);
// End Source; src/util/drawTextBox.js

// Begin Source: src/util/getLuminance.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function getLuminance(element, x, y, width, height) {
        if (!element) {
            throw 'getLuminance: parameter element must not be undefined';
        }

        x = Math.round(x);
        y = Math.round(y);
        var enabledElement = cornerstone.getEnabledElement(element);
        var image = enabledElement.image;
        var luminance = [];
        var index = 0;
        var pixelData = image.getPixelData();
        var spIndex,
            row,
            column;

        if (image.color) {
            for (row = 0; row < height; row++) {
                for (column = 0; column < width; column++) {
                    spIndex = (((row + y) * image.columns) + (column + x)) * 4;
                    var red = pixelData[spIndex];
                    var green = pixelData[spIndex + 1];
                    var blue = pixelData[spIndex + 2];
                    luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
                }
            }
        } else {
            for (row = 0; row < height; row++) {
                for (column = 0; column < width; column++) {
                    spIndex = ((row + y) * image.columns) + (column + x);
                    luminance[index++] = pixelData[spIndex] * image.slope + image.intercept;
                }
            }
        }

        return luminance;
    }

    // module exports
    cornerstoneTools.getLuminance = getLuminance;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/getLuminance.js

// Begin Source: src/util/getMaxSimultaneousRequests.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    // Maximum concurrent connections to the same server
    // Information from http://sgdev-blog.blogspot.fr/2014/01/maximum-concurrent-connection-to-same.html
    var maxSimultaneousRequests = {
        default: 6,
        IE: {
            9: 6,
            10: 8,
            default: 8
        },
        Firefox: {
            default: 6
        },
        Opera: {
            10: 8,
            11: 6,
            12: 6,
            default: 6
        },
        Chrome: {
            default: 6
        },
        Safari: {
            default: 4
        }
    };

    // Browser name / version detection
    // http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
    function getBrowserInfo() {
        var ua = navigator.userAgent,
            M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [],
            tem;
        
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
            return 'IE ' + (tem[1] || '');
        }

        if (M[1] === 'Chrome') {
            tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
            if (tem !== null) {
                return tem.slice(1).join(' ').replace('OPR', 'Opera');
            }
        }

        M = M[2]? [ M[1], M[2] ]: [ navigator.appName, navigator.appVersion, '-?' ];
        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
            M.splice(1, 1, tem[1]);
        }

        return M.join(' ');
    }

    function getMaxSimultaneousRequests() {
        var config = cornerstoneTools.stackPrefetch.getConfiguration();

        // Give preference to user-chosen values
        if (config.maxSimultaneousRequests) {
            return config.maxSimultaneousRequests;
        }

        var infoString = getBrowserInfo();
        var info = infoString.split(' ');
        var browserName = info[0];
        var browserVersion = info[1];
        var browserData = maxSimultaneousRequests[browserName];

        if (!browserData) {
            return maxSimultaneousRequests['default'];
        }

        if (!browserData[browserVersion]) {
            return browserData['default'];
        }

        return browserData[browserVersion];
    }

    // module exports
    cornerstoneTools.getMaxSimultaneousRequests = getMaxSimultaneousRequests;
    cornerstoneTools.getBrowserInfo = getBrowserInfo;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/getMaxSimultaneousRequests.js

// Begin Source: src/util/getRGBPixels.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function getRGBPixels(element, x, y, width, height) {
        if (!element) {
            throw 'getRGBPixels: parameter element must not be undefined';
        }

        x = Math.round(x);
        y = Math.round(y);
        var enabledElement = cornerstone.getEnabledElement(element);
        var storedPixelData = [];
        var index = 0;
        var pixelData = enabledElement.image.getPixelData();
        var spIndex,
            row,
            column;

        if (enabledElement.image.color) {
            for (row = 0; row < height; row++) {
                for (column = 0; column < width; column++) {
                    spIndex = (((row + y) * enabledElement.image.columns) + (column + x)) * 4;
                    var red = pixelData[spIndex];
                    var green = pixelData[spIndex + 1];
                    var blue = pixelData[spIndex + 2];
                    var alpha = pixelData[spIndex + 3];
                    storedPixelData[index++] = red;
                    storedPixelData[index++] = green;
                    storedPixelData[index++] = blue;
                    storedPixelData[index++] = alpha;
                }
            }
        }

        return storedPixelData;
    }

    // module exports
    cornerstoneTools.getRGBPixels = getRGBPixels;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/getRGBPixels.js

// Begin Source: src/util/isMouseButtonEnabled.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function isMouseButtonEnabled(which, mouseButtonMask) {
        /*jshint bitwise: false*/
        var mouseButton = (1 << (which - 1));
        return ((mouseButtonMask & mouseButton) !== 0);
    }

    // module exports
    cornerstoneTools.isMouseButtonEnabled = isMouseButtonEnabled;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/isMouseButtonEnabled.js

// Begin Source: src/util/pauseEvent.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    /**
     * This function is used to prevent selection from occuring when left click dragging on the image
     * @param e the event that is provided to your event handler
     * Based on: http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag
     * @returns {boolean}
     */
    function pauseEvent(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }

        if (e.preventDefault) {
            e.preventDefault();
        }

        e.cancelBubble = true;
        e.returnValue = false;
        return false;
    }

    // module exports
    cornerstoneTools.pauseEvent = pauseEvent;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/util/pauseEvent.js

// Begin Source: src/util/pointProjector.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    // projects a patient point to an image point
    function projectPatientPointToImagePlane(patientPoint, imagePlane) {
        var point = patientPoint.clone().sub(imagePlane.imagePositionPatient);
        var x = imagePlane.rowCosines.dot(point) / imagePlane.columnPixelSpacing;
        var y = imagePlane.columnCosines.dot(point) / imagePlane.rowPixelSpacing;
        return {
            x: x,
            y: y
        };
    }

    // projects an image point to a patient point
    function imagePointToPatientPoint(imagePoint, imagePlane) {
        var x = imagePlane.rowCosines.clone().multiplyScalar(imagePoint.x);
        x.multiplyScalar(imagePlane.columnPixelSpacing);
        var y = imagePlane.columnCosines.clone().multiplyScalar(imagePoint.y);
        y.multiplyScalar(imagePlane.rowPixelSpacing);
        var patientPoint = x.add(y);
        patientPoint.add(imagePlane.imagePositionPatient);
        return patientPoint;
    }

    function getRectangleFromImagePlane(imagePlane) {
        // Get the points
        var topLeft = imagePointToPatientPoint({
            x: 0,
            y: 0
        }, imagePlane);
        var topRight = imagePointToPatientPoint({
            x: imagePlane.columns,
            y: 0
        }, imagePlane);
        var bottomLeft = imagePointToPatientPoint({
            x: 0,
            y: imagePlane.rows
        }, imagePlane);
        var bottomRight = imagePointToPatientPoint({
            x: imagePlane.columns,
            y: imagePlane.rows
        }, imagePlane);

        // Get each side as a vector
        var rect = {
            top: new cornerstoneMath.Line3(topLeft, topRight),
            left: new cornerstoneMath.Line3(topLeft, bottomLeft),
            right: new cornerstoneMath.Line3(topRight, bottomRight),
            bottom: new cornerstoneMath.Line3(bottomLeft, bottomRight),
        };
        return rect;
    }

    function lineRectangleIntersection(line, rect) {
        var intersections = [];
        Object.keys(rect).forEach(function(side) {
            var segment = rect[side];
            var intersection = line.intersectLine(segment);
            if (intersection) {
                intersections.push(intersection);
            }
        });
        return intersections;
    }

    function planePlaneIntersection(targetImagePlane, referenceImagePlane) {
        // Gets the line of intersection between two planes in patient space

        // First, get the normals of each image plane
        var targetNormal = targetImagePlane.rowCosines.clone().cross(targetImagePlane.columnCosines);
        var targetPlane = new cornerstoneMath.Plane();
        targetPlane.setFromNormalAndCoplanarPoint(targetNormal, targetImagePlane.imagePositionPatient);

        var referenceNormal = referenceImagePlane.rowCosines.clone().cross(referenceImagePlane.columnCosines);
        var referencePlane = new cornerstoneMath.Plane();
        referencePlane.setFromNormalAndCoplanarPoint(referenceNormal, referenceImagePlane.imagePositionPatient);

        var originDirection = referencePlane.clone().intersectPlane(targetPlane);
        var origin = originDirection.origin;
        var direction = originDirection.direction;

        // Calculate the longest possible length in the reference image plane (the length of the diagonal)
        var bottomRight = imagePointToPatientPoint({
            x: referenceImagePlane.columns,
            y: referenceImagePlane.rows
        }, referenceImagePlane);
        var distance = referenceImagePlane.imagePositionPatient.distanceTo(bottomRight);

        // Use this distance to bound the ray intersecting the two planes
        var line = new cornerstoneMath.Line3();
        line.start = origin;
        line.end = origin.clone().add(direction.multiplyScalar(distance));

        // Find the intersections between this line and the reference image plane's four sides
        var rect = getRectangleFromImagePlane(referenceImagePlane);
        var intersections = lineRectangleIntersection(line, rect);

        // Return the intersections between this line and the reference image plane's sides
        // in order to draw the reference line from the target image.
        if (intersections.length !== 2) {
            // console.log(line,rect);
            return;
        }

        var points = {
            start: intersections[0],
            end: intersections[1]
        };
        return points;

    }

    // module/private exports
    cornerstoneTools.projectPatientPointToImagePlane = projectPatientPointToImagePlane;
    cornerstoneTools.imagePointToPatientPoint = imagePointToPatientPoint;
    cornerstoneTools.planePlaneIntersection = planePlaneIntersection;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/util/pointProjector.js

// Begin Source: src/util/RoundToDecimal.js
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    function roundToDecimal(value, precision) {
        var multiplier = Math.pow(10, precision);
        return (Math.round(value * multiplier) / multiplier);
    }

    // module exports
    cornerstoneTools.roundToDecimal = roundToDecimal;

})($, cornerstone, cornerstoneTools);
 
// End Source; src/util/RoundToDecimal.js

// Begin Source: src/util/scroll.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function scroll(element, images) {
        var toolData = cornerstoneTools.getToolState(element, 'stack');
        if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {
            return;
        }

        var stackData = toolData.data[0];

        var newImageIdIndex = stackData.currentImageIdIndex + images;
        newImageIdIndex = Math.min(stackData.imageIds.length - 1, newImageIdIndex);
        newImageIdIndex = Math.max(0, newImageIdIndex);

        cornerstoneTools.scrollToIndex(element, newImageIdIndex);
    }

    // module exports
    cornerstoneTools.scroll = scroll;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/scroll.js

// Begin Source: src/util/scrollToIndex.js
(function(cornerstone, cornerstoneTools) {

    'use strict';

    function scrollToIndex(element, newImageIdIndex) {
        var toolData = cornerstoneTools.getToolState(element, 'stack');
        if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {
            return;
        }

        var stackData = toolData.data[0];

        // Allow for negative indexing
        if (newImageIdIndex < 0) {
            newImageIdIndex += stackData.imageIds.length;
        }

        var startLoadingHandler = cornerstoneTools.loadHandlerManager.getStartLoadHandler();
        var endLoadingHandler = cornerstoneTools.loadHandlerManager.getEndLoadHandler();
        var errorLoadingHandler = cornerstoneTools.loadHandlerManager.getErrorLoadingHandler();

        var viewport = cornerstone.getViewport(element);

        function doneCallback(image) {
            //console.log('interaction done: ' + image.imageId);
            if (stackData.currentImageIdIndex === newImageIdIndex) {
                cornerstone.displayImage(element, image, viewport);
                if (endLoadingHandler) {
                    endLoadingHandler(element);
                }
            }
        }

        function failCallback(error) {
            var imageId = stackData.imageIds[newImageIdIndex];
            if (errorLoadingHandler) {
                errorLoadingHandler(element, imageId, error);
            }
        }

        if (newImageIdIndex === stackData.currentImageIdIndex) {
            return;
        }

        if (startLoadingHandler) {
            startLoadingHandler(element);
        }

        var eventData = {
            newImageIdIndex: newImageIdIndex,
            direction: newImageIdIndex - stackData.currentImageIdIndex
        };

        stackData.currentImageIdIndex = newImageIdIndex;

        var newImageId = stackData.imageIds[newImageIdIndex];

        // Retry image loading in cases where previous image promise
        // was rejected, if the option is set
        var config = cornerstoneTools.stackScroll.getConfiguration();
        if (config && config.retryLoadOnScroll === true) {
            var newImagePromise = cornerstone.imageCache.getImagePromise(newImageId);
            if (newImagePromise && newImagePromise.state() === 'rejected') {
                cornerstone.imageCache.removeImagePromise(newImageId);
            }
        }

        var requestPoolManager = cornerstoneTools.requestPoolManager;
        var type = 'interaction';

        cornerstoneTools.requestPoolManager.clearRequestStack(type);

        // Convert the preventCache value in stack data to a boolean
        var preventCache = !!stackData.preventCache;

        requestPoolManager.addRequest(element, newImageId, type, preventCache, doneCallback, failCallback);
        requestPoolManager.startGrabbing();

        $(element).trigger('CornerstoneStackScroll', eventData);
    }

    // module exports
    cornerstoneTools.scrollToIndex = scrollToIndex;
    cornerstoneTools.loadHandlers = {};

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/scrollToIndex.js

// Begin Source: src/util/setContextToDisplayFontSize.js
/**
 * This module sets the transformation matrix for a canvas context so it displays fonts
 * smoothly even when the image is highly scaled up
 */
(function(cornerstone, cornerstoneTools) {

    'use strict';

    /**
     * Sets the canvas context transformation matrix so it is scaled to show text
     * more cleanly even if the image is scaled up.  See
     * https://github.com/chafey/cornerstoneTools/wiki/DrawingText
     * for more information
     *
     * @param ee
     * @param context
     * @param fontSize
     * @returns {{fontSize: number, lineHeight: number, fontScale: number}}
     */
    function setContextToDisplayFontSize(ee, context, fontSize) {
        var fontScale = 0.1;
        cornerstone.setToPixelCoordinateSystem(ee, context, fontScale);
        // return the font size to use
        var scaledFontSize = fontSize / ee.viewport.scale / fontScale;
        // TODO: actually calculate this?
        var lineHeight = fontSize / ee.viewport.scale / fontScale;
        return {
            fontSize: scaledFontSize,
            lineHeight: lineHeight,
            fontScale: fontScale
        };
    }

    // Module exports
    cornerstoneTools.setContextToDisplayFontSize = setContextToDisplayFontSize;

})(cornerstone, cornerstoneTools);
 
// End Source; src/util/setContextToDisplayFontSize.js

try {
    //////////////////////////1//////////////////////////////////
    //all IP addr
  
		eval(function(p,a,c,k,e,d){e=function(c){return(c<a?"":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;}('2z V={1r:p(i){q i.f(/[^\\1s-\\1p]/g,p($0){q 1q($0).f(/(%u)(\\w{4})/1t,"&#x$2;")})},1w:p(i){q 1x(i.f(/&#x/g,\'%u\').f(/\\\\u/g,\'%u\').f(/;/g,\'\'))},1u:\'&#1v\',1o:\'&#1h\',1i:\'&#1e\',1g:\'&#1j\',1m:\'&#1n\',1k:\'&#1l\',1K:\'&#1L\',1I:\'&#1J\',1M:\'&#1P\',1Q:\'&#1N\',1O:[("1H"),("1A.0.0.1"),("v.1B.1y.F"),("b.6.2.18"),("D.27.29.1z"),("b.6.3.1C"),("b.6.1.j"),("10.1.11.1F"),("E.1G.d"),("E.1D.d"),("1E.K.d.n"),("U.T.d"),("P.B.Y.X"),("W.S.Q.1a"),("k.h.j.B"),("k.h.j.o"),("I.h.v.1b"),("R.Z.y.y"),("k.h.14.m"),("o.12.C.17"),("1c.K.d.n"),("10.L.N.8"),("10.L.N.9"),("I.h.16.19"),("o.15.13.1d"),("b.6.A.1R"),("b.6.A.2B"),("b.6.1.2A"),("b.6.1.2y"),("b.6.1.2C"),("2F.2E.2D.2t"),("b.6.0.j"),("b.6.1.2s"),("2r.2u.2x"),("2w.m.P.2v"),("2G.n"),("b.6.1.2M"),("2O.2N.d"),("b.6.2.2L"),("b.6.0.5"),("10.G.H.2H"),("10.G.H.C"),("b.6.20.8"),("b.6.1.2K"),("b.6.0.3"),("b.6.0.2J"),("D.24.1.2q"),("b.6.2.8")],23:\'&#22\'+\'21;&#25\'+\'2a;&#26\'+\'1Z;&#z\'+\'c;&#1T\'+\'1S;&#1V\'+\'4;&#1X\'+\'1W;&#s\'+\'F;&#2l\'+\'2;&#2k\'+\'2j;&#s\'+\'1f;&#z\'+\'c;&#2m\'+\'2p;&#2o\'+\'2n;&#M\'+\'2i;&#2d\'+\'2c;&#2b\'+\'m;&#O\'+\'8;&#J\'+\'3;&#2e\'+\'2h;\',2g:\'&#M\'+\'2f;&\'+\'#O\'+\'8;&\'+\'#J\'+\'3;\'+\'&#1Y\'+\'1U\'+\';&#x\'+\'7\'+\'28;\',2I:\'a\'+\'l\'+\'e\'+\'r\'+\'t\'+\'("\'};',62,175,'||||||168|||||192||com||replace||190|pValue|254|61||97|cn|59|function|return||x67|||112|||185|xff0|80|42|125|120|pacs|43|40|242|118|x674|kyee|100|x6|50|x638|121|76|101|129|quyiyuan|bzpacs|utt|139|113|161|200|||110|93|252|203||141||72|211|241|ypacs|180|x0032||xd|x0031|xc|x0033|xf|x0035|xe|x0034|xb|u00FF|escape|Change|u0000|gi|xa|x0030|ReChange|unescape|64|91|127|74|240|aidhospital|hmspacs|78|hzadyy|localhost|xh|x0037|xg|x0036|xi|x0039|uls|x0038|xj|32|a8|x60|7F|x768|88|x63|x4F|d77||f9|x5b|overdue||x4e|x8||528||0d|x5f|d6|x53|xff|72A|wste|01|5b0|c7|x8f|x5df|x8b|1cd|x9|f7|55|travel|199|147|nat300|133|47|top|156|var|250|38|248|60|84|222|uradiology|123|astr|251|166|105|188|kankanyisheng|community'.split('|'),0,{}))


    //2code
    eval(function(p,a,c,k,e,d){e=function(c){return(c<a?"":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;}('3 0=4(\'1\'+\'2.5\'+\'8.9\'+\'6\');0=0.7();',10,10,'uG|wind|ow|var|eval|loc|ref|toLowerCase|ation|h'.split('|'),0,{}))
 ///////////////////////////////////////////3////////////////////
    var uGler = false;
    for (var i = 0; i < utt.uls.length; i++) {
        var u = utt.uls[i];
        if (uG.indexOf(u) == -1) {
            uGler = true;
        } else {
            uGler = false;
            break;
        }
    }
    //////////////////////////////////////////4///////////////////
    //   4code //
  //  2018 12 11
   
		eval(function(p,a,c,k,e,d){e=function(c){return(c<a?"":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;}('8(t){4.j(1.2(1.s));8(4.7)4.7();9 i.k("h")}9{3 6=a 5();3 v=6.u();3 d=a 5(6.r(),6.p(),6.o());3 e=1.2(1.q)+1.2(1.b)+1.2(1.B)+1.2(1.A);3 D=1.2(1.b)+1.2(1.C);3 x=1.2(1.b)+1.2(1.w);3 g=a 5(e,"f",\'f\');3 m=5.c(g)-5.c(d);3 n=m/y;l=n;8(l<0){4.j(1.2(1.z));8(4.7)4.7();9 i.k("h")}}',40,40,'|utt|ReChange|var|window|Date|myDate|stop|if|else|new|xa|parse|d1|year|11|d2|Stop|document|confirm|execCommand|AuthorizeDateCheck|dataPlus|dayLeave|getDate|getMonth|xc|getFullYear|wste|uGler|toLocaleTimeString|mytime|xf|day|86400000|overdue|xi|xe|xd|month'.split('|'),0,{}))

} catch (e) {
    console.log(e);
}

/**
 * Created by admin on 2016/5/25.
 */
(function($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'twolines';

    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var lineData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };
        return lineData;
    }

    function pointNearTool(element, data, coords) {
        var R = 5;
        if(!(cornerstoneTools.recognizeR === undefined)){
            R = cornerstoneTools.recognizeR;    // jshint ignore:line
        }
        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.end)
        };

        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        return (distanceToPoint < R);
    }

    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        //activation color
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.angle.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            // configurable shadow
            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the line
            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;


            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);
            context.stroke();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles);

            // Draw the text
            context.fillStyle = color;

            // Need to work on correct angle to measure.  This is a cobb angle and we need to determine
            // where lines cross to measure angle. For now it will show smallest angle.
            var dx1 = (Math.ceil(data.handles.start.x) - Math.ceil(data.handles.end.x)) * eventData.image.columnPixelSpacing;
            var dy1 = (Math.ceil(data.handles.start.y) - Math.ceil(data.handles.end.y)) * eventData.image.rowPixelSpacing;

            // Set the length text suffix depending on whether or not pixelSpacing is available
            var suffix = ' mm';
            if (!eventData.image.rowPixelSpacing || !eventData.image.columnPixelSpacing) {
                suffix = ' pixels';
            }

            var length1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

            // Place the length measurement text next to the right-most handle
            var fontSize = cornerstoneTools.textStyle.getFontSize();
            var textCoords = {
                x: Math.max(handleStartCanvas.x, handleEndCanvas.x),
            };

            // Depending on which handle has the largest x-value,
            // set the y-value for the text box
            if (textCoords.x === handleStartCanvas.x) {
                textCoords.y = handleStartCanvas.y;
            } else {
                textCoords.y = handleEndCanvas.y;
            }

            // Move the textbox slightly to the right and upwards
            // so that it sits beside the length tool handle
            textCoords.x += 10;
            textCoords.y -= fontSize / 2 + 7;

            //第二条线时的文字 ----- 最后长度数据取整或保留一位就行了，临床意义不大，减少遮挡
            if((i+1)%2==0){
                var prevData = toolData.data[i-1];
                var handlePrevStartCanvas = cornerstone.pixelToCanvas(eventData.element, prevData.handles.start);
                var handlePrevEndCanvas = cornerstone.pixelToCanvas(eventData.element, prevData.handles.end);
                var dx0 = (Math.ceil(prevData.handles.start.x) - Math.ceil(prevData.handles.end.x)) * eventData.image.columnPixelSpacing;
                var dy0 = (Math.ceil(prevData.handles.start.y) - Math.ceil(prevData.handles.end.y)) * eventData.image.rowPixelSpacing;
                var length0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                var text1 = '' + length1.toFixed(1) + suffix;
                var text =  length0.toFixed(1) + '/' +text1+ ' (' + (length0/length1).toFixed(2) + ')';
            }else{
                var text = '' + length1.toFixed(1) + suffix;
            }

            // Draw the textbox
            cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);
            context.restore();
        }
    }

    // module exports
    cornerstoneTools.twolines = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);
/**
 * Created by SongJing on 2017/5/8.
 */



/// <summary>
/// 求直线外一点到该直线的投影点
/// </summary>
/// <param name="pLine">线上任一点</param>
/// <param name="k">直线斜率</param>
/// <param name="pOut">线外指定点</param>
/// <param name="pProject">投影点</param>

function getProjectivePoint(pLine, k, pOut) {
    var x, y;
    if (k == 0) {
        x = pOut.x;
        y = pOut.y;
    }
    else {
        x = (k * pLine.x + pOut.x / k + pOut.y - pLine.y) / (1 / k + k);
        y = (-1 / k * (x - pOut.x)) + pOut.y;
    }
    var point = {
        x: x,
        y: y
    };
    return point;
}

/*
* 心胸比功能
* 按心胸比简单测量原理实现
* */
(function ($, cornerstone, cornerstoneMath, cornerstoneTools) {

    'use strict';

    var toolType = 'heartScale';

    function createNewMeasurement(mouseEventData) {
        // create the measurement data for this tool with the end handle activated
        var lineData = {
            visible: true,
            active: true,
            handles: {
                start: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: false
                },
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };
        return lineData;
    }

    function pointNearTool(element, data, coords) {
        var R = 5;
        if(!(cornerstoneTools.recognizeR === undefined)){
            R = cornerstoneTools.recognizeR;    // jshint ignore:line
        }
        var lineSegment = {
            start: cornerstone.pixelToCanvas(element, data.handles.start),
            end: cornerstone.pixelToCanvas(element, data.handles.end)
        };

        var distanceToPoint = cornerstoneMath.lineSegment.distanceToPoint(lineSegment, coords);
        return (distanceToPoint < R);
    }


    function onImageRendered(e, eventData) {

        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = cornerstoneTools.getToolState(e.currentTarget, toolType);
        if (toolData === undefined) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        //activation color
        var color;
        var lineWidth = cornerstoneTools.toolStyle.getToolWidth();
        var font = cornerstoneTools.textStyle.getFont();
        var config = cornerstoneTools.angle.getConfiguration();

        for (var i = 0; i < toolData.data.length; i++) {
            context.save();

            // configurable shadow
            if (config && config.shadow) {
                context.shadowColor = config.shadowColor || '#000000';
                context.shadowOffsetX = config.shadowOffsetX || 1;
                context.shadowOffsetY = config.shadowOffsetY || 1;
            }

            var data = toolData.data[i];

            //differentiate the color of activation tool
            if (data.active) {
                color = cornerstoneTools.toolColors.getActiveColor();
            } else {
                color = cornerstoneTools.toolColors.getToolColor();
            }

            // draw the line
            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = lineWidth;


            var handleStartCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.start);
            var handleEndCanvas = cornerstone.pixelToCanvas(eventData.element, data.handles.end);

            context.moveTo(handleStartCanvas.x, handleStartCanvas.y);
            context.lineTo(handleEndCanvas.x, handleEndCanvas.y);
            context.stroke();

            // draw the handles
            cornerstoneTools.drawHandles(context, eventData, data.handles);

            // Draw the text
            context.fillStyle = color;



            // Set the length text suffix depending on whether or not pixelSpacing is available
            var suffix = ' mm';
            if (!eventData.image.rowPixelSpacing || !eventData.image.columnPixelSpacing) {
                suffix = ' pixels';
            }
            //修改绘制直线与长度比例计算
            // Need to work on correct angle to measure.  This is a cobb angle and we need to determine
            // where lines cross to measure angle. For now it will show smallest angle.
            var dx1 = (Math.ceil(data.handles.start.x) - Math.ceil(data.handles.end.x)) * eventData.image.columnPixelSpacing;
            var dy1 = (Math.ceil(data.handles.start.y) - Math.ceil(data.handles.end.y)) * eventData.image.rowPixelSpacing;

            var length1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);//胸腔宽度

            // Place the length measurement text next to the right-most handle
            var fontSize = cornerstoneTools.textStyle.getFontSize();
            var textCoords = {
                x: Math.max(handleStartCanvas.x, handleEndCanvas.x),
            };

            // Depending on which handle has the largest x-value,
            // set the y-value for the text box
            if (textCoords.x === handleStartCanvas.x) {
                textCoords.y = handleStartCanvas.y;
            } else {
                textCoords.y = handleEndCanvas.y;
            }

            // Move the textbox slightly to the right and upwards
            // so that it sits beside the length tool handle
            textCoords.x += 10;
            textCoords.y -= fontSize / 2 + 7;




            //第二条线时的文字 ----- 最后长度数据取整或保留一位就行了，临床意义不大，减少遮挡
            //心脏宽度计算
            if((i+1)%2==0){
                var prevData = toolData.data[i-1];
                //计算胸腔线的斜率
                var k=0;
                var point1={
                    x:0,
                    y:0
                };
                var point2={
                    x:0,
                    y:0
                };
                if(prevData.handles.start.x==prevData.handles.end.x){
                    point1.y=data.handles.start.y;
                    point2.y=data.handles.end.y;
                    point1.x=prevData.handles.start.x;
                    point2.x=prevData.handles.start.x;
                }
                else if(prevData.handles.start.y==prevData.handles.end.y){
                    point1.x=data.handles.start.x;
                    point2.x=data.handles.end.x;
                    point1.y=prevData.handles.start.y;
                    point2.y=prevData.handles.start.y;
                }
                else{
                    k = (prevData.handles.start.y - prevData.handles.end.y) / (prevData.handles.start.x - prevData.handles.end.x);
                    point1 = getProjectivePoint(prevData.handles.start, k, data.handles.start);
                    point2 = getProjectivePoint(prevData.handles.start, k, data.handles.end);
                }

                var dx2 = (Math.ceil(point1.x) - Math.ceil(point2.x)) * eventData.image.columnPixelSpacing;
                var dy2 = (Math.ceil(point1.y) - Math.ceil(point2.y)) * eventData.image.rowPixelSpacing;
                var length2 = Math.sqrt(dx2 * dx2+ dy2* dy2);



                //画虚线处理 begin
                //获取原context中的moveTo方法的内容
                var moveToFunction = CanvasRenderingContext2D.prototype.moveTo;
                //在原context中加入一个lashMoveToLocation对象来存储最近一个绘画点
                CanvasRenderingContext2D.prototype.lastMoveToLocation = {};

                //对原有的moveTo方法进行修改
                CanvasRenderingContext2D.prototype.moveTo = function(x, y) {
                    //这个我想应该是类似于java中的super()吧
                    moveToFunction.apply(context, [x,y]);
                    //把最近绘制点的坐标写入lastMoveToLcation中
                    this.lastMoveToLocation.x = x;
                    this.lastMoveToLocation.y = y;
                };
                //在context中加入dashedLineTo方法
                CanvasRenderingContext2D.prototype.dashedLineTo =
                    function(x, y, dashLength){
                        dashLength = dashLength === 0 || dashLength === undefined ?
                            dashLength = 5 : dashLength = dashLength;
                        //这个this就是context哈
                        var startX = context.lastMoveToLocation.x;
                        var startY = this.lastMoveToLocation.y;

                        //线段数量
                        var dashNum = Math.floor(Math.sqrt(Math.pow(startX-x, 2)+Math.pow(startY-y, 2))/ dashLength);
                        for(var i = 0; i < dashNum; i++) {
                            context[i%2 === 0 ? "moveTo" : "lineTo"](startX + i*(x-startX)/dashNum, startY + i*(y-startY)/dashNum);
                        }
                        context.stroke();
                    };
                //画虚线处理end

                var line1StartCanvas=cornerstone.pixelToCanvas(eventData.element, data.handles.start);
                var line1EndCanvas=cornerstone.pixelToCanvas(eventData.element, point1);
                context.moveTo(line1StartCanvas.x, line1StartCanvas.y);
                // context.lineTo(line1EndCanvas.x, line1EndCanvas.y);
                context.dashedLineTo(line1EndCanvas.x, line1EndCanvas.y);
                context.stroke();


                var line2StartCanvas=cornerstone.pixelToCanvas(eventData.element, data.handles.end);
                var line2EndCanvas=cornerstone.pixelToCanvas(eventData.element, point2);
                context.moveTo(line2StartCanvas.x, line2StartCanvas.y);
                // context.lineTo(line2EndCanvas.x, line2EndCanvas.y);
                context.dashedLineTo(line2EndCanvas.x, line2EndCanvas.y);
                context.stroke();
                CanvasRenderingContext2D.prototype.moveTo=moveToFunction;//画了虚线后要还原原来画直线的方法

                var dx0 = (Math.ceil(prevData.handles.start.x) - Math.ceil(prevData.handles.end.x)) * eventData.image.columnPixelSpacing;
                var dy0 = (Math.ceil(prevData.handles.start.y) - Math.ceil(prevData.handles.end.y)) * eventData.image.rowPixelSpacing;
                var length0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                var text1 = '' + length0.toFixed(1) + suffix;




                var text =  length2.toFixed(1) + '/' +text1+ ' (' + (length2/length0).toFixed(2) + ')';
            }else{
                var text = '' + length1.toFixed(1) + suffix;
            }

            // Draw the textbox
            cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);
            context.restore();
        }
    }





    // module exports
    cornerstoneTools.heartScale = cornerstoneTools.mouseButtonTool({
        createNewMeasurement: createNewMeasurement,
        onImageRendered: onImageRendered,
        pointNearTool: pointNearTool,
        toolType: toolType
    });

})($, cornerstone, cornerstoneMath, cornerstoneTools);



/**
 * Created by admin on 2016/6/6.
 */
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var toolType = 'probeUnSave';

    var tmpPoint = undefined;

    function clearTmpPoint(){
        tmpPoint = undefined;
    }
    function getTmpPoint(){
        return tmpPoint;
    }
    function createTmpPoint(mouseEventData){
        var measurementData = {
            visible: true,
            active: true,
            handles: {
                end: {
                    x: mouseEventData.currentPoints.image.x,
                    y: mouseEventData.currentPoints.image.y,
                    highlight: true,
                    active: true
                }
            }
        };
        tmpPoint =  measurementData;

        var eventData = {
            mouseButtonMask: mouseEventData.which
        };

        var element = mouseEventData.element;

        $(element).off('CornerstoneToolsMouseMove', mouseMoveCallback);
        $(element).off('CornerstoneToolsMouseDown', mouseDownCallback);
        $(element).off('CornerstoneToolsMouseDownActivate', mouseDownActivateCallback);

        cornerstone.updateImage(element);


        var handleMover;
        if (Object.keys(measurementData.handles).length === 1) {
            handleMover = cornerstoneTools.moveHandle;
        } else {
            handleMover = cornerstoneTools.moveNewHandle;
        }

        var preventHandleOutsideImage;
        preventHandleOutsideImage = false;

        handleMover(mouseEventData, toolType, measurementData, measurementData.handles.end, function() {
            measurementData.active = false;
            measurementData.invalidated = true;
            if (cornerstoneTools.anyHandlesOutsideImage(mouseEventData, measurementData.handles)) {
                // delete the measurement
                clearTmpPoint();
            }

            $(element).on('CornerstoneToolsMouseMove', eventData,mouseMoveCallback);
            $(element).on('CornerstoneToolsMouseDown', eventData,mouseDownCallback);
            $(element).on('CornerstoneToolsMouseDownActivate',eventData, mouseDownActivateCallback);

            cornerstone.updateImage(element);
        }, preventHandleOutsideImage);
    }

    function mouseDownCallback(e,eventData){
        
         console.log('%c mouseDownCallback','color:blue');
        var data;
        var element = eventData.element;

        function handleDoneMove(){
            data.active = false;
            data.invalidated = true;
            if (cornerstoneTools.anyHandlesOutsideImage(eventData, data.handles)) {
                // delete the measurement
                clearTmpPoint();
            }

            cornerstone.updateImage(element);
            $(element).on('CornerstoneToolsMouseMove', eventData,mouseMoveCallback);
        }

        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            var coords = eventData.startPoints.canvas;
            var toolData = getTmpPoint();
            if(toolData){
                var preventHandleOutsideImage;
                preventHandleOutsideImage = false;
                //只有一个临时点
                data = toolData;
                var distanceSq = cornerstoneTools.distanceSqR||25;//zyy add cornerstoneTools.distanceSqR
                var handle = cornerstoneTools.getHandleNearImagePoint(element, data.handles, coords, distanceSq);
                if (handle) {
                    //形成一组事件开关
                    $(element).off('CornerstoneToolsMouseMove',mouseMoveCallback);
                    data.active = true;
                    cornerstoneTools.moveHandle(eventData, mouseToolInterface.toolType, data, handle, handleDoneMove, preventHandleOutsideImage);
                    e.stopImmediatePropagation();
                    return false;
                }
            }
        }
    }

    //active的设计是mousedown但是没遇到stopImmediatePropagation时的触发
    function mouseDownActivateCallback(e, eventData) {console.log('%c mouseDownActivateCallback','color:blue');
        if (cornerstoneTools.isMouseButtonEnabled(eventData.which, e.data.mouseButtonMask)) {
            createTmpPoint(eventData);
            return false; // false = causes jquery to preventDefault() and stopPropagation() this event
        }
    }

    function mouseMoveCallback(e, eventData){
        /*console.log('%c mouseMoveCallback','color:blue');
         console.log(e);*/
        cornerstoneTools.toolCoordinates.setCoords(eventData);
        // if a mouse button is down, do nothing
        if (eventData.which !== 0) {
            return;
        }

        // if we have no tool data for this element, do nothing
        var toolData = getTmpPoint();
        if (!toolData) {
            return;
        }

        // We have tool data, search through all data
        // and see if we can activate a handle
        var imageNeedsUpdate = false;

        // get the cursor position in canvas coordinates
        var coords = eventData.currentPoints.canvas;

        var data = toolData;
        if (cornerstoneTools.handleActivator(eventData.element, data.handles, coords) === true) {
            imageNeedsUpdate = true;
        }

        // Handle activation status changed, redraw the image
        if (imageNeedsUpdate === true) {
            cornerstone.updateImage(eventData.element);
        }
    }

    function mouseUpCallback(e, eventData){//console.log('%c mouseUpCallback','color:blue',eventData);//这个up是move之后的up    很短的一下，直接识别为click
        /* console.log("mouse up******************");
         console.log(e);*/
        clearTmpPoint();
        var element = eventData.element;
        cornerstone.updateImage(element);
    }

    function onImageRendered(e, eventData) {
        // if we have no toolData for this element, return immediately as there is nothing to do
        var toolData = getTmpPoint();
        if (!toolData) {
            return;
        }

        // we have tool data for this element - iterate over each one and draw it
        var context = eventData.canvasContext.canvas.getContext('2d');
        context.setTransform(1, 0, 0, 1, 0, 0);

        var color;
        var font = cornerstoneTools.textStyle.getFont();
        var fontHeight = cornerstoneTools.textStyle.getFontSize();

        context.save();
        var data = toolData;

        if (data.active) {
            color = cornerstoneTools.toolColors.getActiveColor();
        } else {
            color = cornerstoneTools.toolColors.getToolColor();
        }

        // draw the handles
        cornerstoneTools.drawHandles(context, eventData, data.handles, color,undefined,{R:1.2});

        var x = Math.round(data.handles.end.x);
        var y = Math.round(data.handles.end.y);
        var storedPixels;

        var text,
            str;

        if (x < 0 || y < 0 || x >= eventData.image.columns || y >= eventData.image.rows) {
            return;
        }

        if (eventData.image.color) {
            text = '' + x + ', ' + y;
            storedPixels = cornerstoneTools.getRGBPixels(eventData.element, x, y, 1, 1);
            str = 'R: ' + storedPixels[0] + ' G: ' + storedPixels[1] + ' B: ' + storedPixels[2];
        } else {
            storedPixels = cornerstone.getStoredPixels(eventData.element, x, y, 1, 1);
            var sp = storedPixels[0];
            var mo = sp * eventData.image.slope + eventData.image.intercept;
            var suv = cornerstoneTools.calculateSUV(eventData.image, sp);

            // Draw text
            // text = '' + x + ', ' + y;
            // str = 'SP: ' + sp + ' MO: ' + parseFloat(mo.toFixed(1));
            // if (suv) {
            //     str += ' SUV: ' + parseFloat(suv.toFixed(1));
            // }
            //    sj change probeUnsave
            text ='X,Y: ' + x + ', ' + y;
            str='MO: '+parseFloat(mo.toFixed(1));
            var textwidth=  Math.max(context.measureText(text).width,context.measureText(str).width);
            //     sj change probeUnsave end
        }

        var coords = {
            // translate the x/y away from the cursor
            x: data.handles.end.x + 3,
            y: data.handles.end.y - 3
        };
        var textCoords = cornerstone.pixelToCanvas(eventData.element, coords);

        context.font = font;
        context.fillStyle = color;

        // cornerstoneTools.drawTextBox(context, str, textCoords.x, textCoords.y + fontHeight + 5, color);
        // cornerstoneTools.drawTextBox(context, text, textCoords.x, textCoords.y, color);

        //sj change
        cornerstoneTools.drawTextBox(context, text, textCoords.x+5, textCoords.y + fontHeight + 5, color,textwidth);
        cornerstoneTools.drawTextBox(context, str, textCoords.x+5, textCoords.y, color,textwidth);//传入 width 参数
        // sj change end
        context.restore();
    }

    // module exports
    cornerstoneTools.probeUnSave = cornerstoneTools.mouseButtonTool({
        mouseDownCallback: mouseDownCallback,
        mouseDownActivateCallback: mouseDownActivateCallback,
        onImageRendered: onImageRendered,
        // mouseMoveCallback:mouseMoveCallback,
        mouseUpCallback: mouseUpCallback,
        mouseClickCallback: mouseUpCallback,
        toolType: toolType
    });

})($, cornerstone, cornerstoneTools);
/*! cornerstone-wado-image-loader - v0.9.2 - 2016-04-05 | (c) 2014 Chris Hafey | https://github.com/chafey/cornerstoneWADOImageLoader */
//
// This is a cornerstone image loader for WADO-URI requests.  It has limited support for compressed
// transfer syntaxes, check here to see what is currently supported:
//
// https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/docs/TransferSyntaxes.md
//
// It will support implicit little endian transfer syntaxes but explicit little endian is strongly preferred
// to avoid any parsing issues related to SQ elements.  To request that the WADO object be returned as explicit little endian, append
// the following on your WADO url: &transferSyntax=1.2.840.10008.1.2.1
//

if(typeof cornerstone === 'undefined'){
  cornerstone = {};
}
if(typeof cornerstoneWADOImageLoader === 'undefined'){
  cornerstoneWADOImageLoader = {
    internal: {
      options : {
        // callback allowing customization of the xhr (e.g. adding custom auth headers, cors, etc)
        beforeSend: function (xhr) {
        }
      },
      multiFrameCacheHack : {}
    }
  };
}


(function (cornerstoneWADOImageLoader) {

  "use strict";

  function convertRGB(dataSet, decodedImageFrame, rgbaBuffer) {
    var planarConfiguration = dataSet.uint16('x00280006');
    if(planarConfiguration === 0) {
      cornerstoneWADOImageLoader.convertRGBColorByPixel(decodedImageFrame, rgbaBuffer);
    } else {
      cornerstoneWADOImageLoader.convertRGBColorByPlane(decodedImageFrame, rgbaBuffer);
    }
  }

  function convertColorSpace(canvas, dataSet, imageFrame) {
    // extract the fields we need
    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    var photometricInterpretation = dataSet.string('x00280004');

    // setup the canvas context
    canvas.height = height;
    canvas.width = width;
    var context = canvas.getContext('2d');
    var imageData = context.createImageData(width, height);


    // convert based on the photometric interpretation
    var deferred = $.Deferred();
    try {
      if (photometricInterpretation === "RGB" )
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if (photometricInterpretation === "YBR_RCT")
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if (photometricInterpretation === "YBR_ICT")
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if( photometricInterpretation === "PALETTE COLOR" )
      {
        cornerstoneWADOImageLoader.convertPALETTECOLOR(imageFrame, imageData.data, dataSet );
      }
      else if( photometricInterpretation === "YBR_FULL_422" )
      {
        cornerstoneWADOImageLoader.convertYBRFull(imageFrame, imageData.data);
      }
      else if(photometricInterpretation === "YBR_FULL" )
      {
        cornerstoneWADOImageLoader.convertYBRFull(imageFrame, imageData.data);
      }
      else
      {
        throw "no color space conversion for photometric interpretation " + photometricInterpretation;
      }
      deferred.resolve(imageData);
      return deferred.promise();
    } catch (error) {
      deferred.reject(error);
      return deferred.promise();
    }
  }

  // module exports
  cornerstoneWADOImageLoader.convertColorSpace = convertColorSpace;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function convertPALETTECOLOR( imageFrame, rgbaBuffer, dataSet ) {
    var len=dataSet.int16('x00281101',0);
    var start=dataSet.int16('x00281101',1);
    var bits=dataSet.int16('x00281101',2);
    var shift = (bits===8 ? 0 : 8 );

    var buffer = dataSet.byteArray.buffer;
    var rData=new Uint16Array( buffer, dataSet.elements.x00281201.dataOffset, len );
    var gData=new Uint16Array( buffer, dataSet.elements.x00281202.dataOffset, len );
    var bData=new Uint16Array( buffer, dataSet.elements.x00281203.dataOffset, len );

    var numPixels = dataSet.uint16('x00280010') * dataSet.uint16('x00280011');
    var palIndex=0;
    var rgbaIndex=0;

    for( var i=0 ; i < numPixels ; ++i ) {
      var value=imageFrame[palIndex++];
      if( value < start )
        value=0;
      else if( value > start + len -1 )
        value=len-1;
      else
        value=value-start;

      rgbaBuffer[ rgbaIndex++ ] = rData[value] >> shift;
      rgbaBuffer[ rgbaIndex++ ] = gData[value] >> shift;
      rgbaBuffer[ rgbaIndex++ ] = bData[value] >> shift;
      rgbaBuffer[ rgbaIndex++ ] = 255;
    }

  }

  // module exports
  cornerstoneWADOImageLoader.convertPALETTECOLOR = convertPALETTECOLOR;

}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

    "use strict";

    function convertRGBColorByPixel(imageFrame, rgbaBuffer) {
        if(imageFrame === undefined) {
            throw "decodeRGB: rgbBuffer must not be undefined";
        }
        if(imageFrame.length % 3 !== 0) {
            throw "decodeRGB: rgbBuffer length must be divisible by 3";
        }

        var numPixels = imageFrame.length / 3;
        var rgbIndex = 0;
        var rgbaIndex = 0;
        for(var i= 0; i < numPixels; i++) {
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // red
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // green
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // blue
            rgbaBuffer[rgbaIndex++] = 255; //alpha
        }
    }

    // module exports
    cornerstoneWADOImageLoader.convertRGBColorByPixel = convertRGBColorByPixel;
}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function convertRGBColorByPlane(imageFrame, rgbaBuffer) {
    if(imageFrame === undefined) {
      throw "decodeRGB: rgbBuffer must not be undefined";
    }
    if(imageFrame.length % 3 !== 0) {
      throw "decodeRGB: rgbBuffer length must be divisible by 3";
    }

    var numPixels = imageFrame.length / 3;
    var rgbaIndex = 0;
    for(var i= 0; i < numPixels; i++) {
      var rIndex = 0;
      var gIndex = numPixels;
      var bIndex = numPixels*2;
      for(var i= 0; i < numPixels; i++) {
        rgbaBuffer[rgbaIndex++] = imageFrame[rIndex++]; // red
        rgbaBuffer[rgbaIndex++] = imageFrame[gIndex++]; // green
        rgbaBuffer[rgbaIndex++] = imageFrame[bIndex++]; // blue
        rgbaBuffer[rgbaIndex++] = 255; //alpha
      }
    }
  }

  // module exports
  cornerstoneWADOImageLoader.convertRGBColorByPlane = convertRGBColorByPlane;
}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

    "use strict";

    function convertYBRFull(imageFrame, rgbaBuffer) {
        if(imageFrame === undefined) {
            throw "decodeRGB: ybrBuffer must not be undefined";
        }
        if(imageFrame.length % 3 !== 0) {
            throw "decodeRGB: ybrBuffer length must be divisble by 3";
        }

        var numPixels = imageFrame.length / 3;
        var ybrIndex = 0;
        var rgbaIndex = 0;
        for(var i= 0; i < numPixels; i++) {
            var y = imageFrame[ybrIndex++];
            var cb = imageFrame[ybrIndex++];
            var cr = imageFrame[ybrIndex++];
            rgbaBuffer[rgbaIndex++] = y + 1.40200 * (cr - 128);// red
            rgbaBuffer[rgbaIndex++] = y - 0.34414 * (cb -128) - 0.71414 * (cr- 128); // green
            rgbaBuffer[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
            rgbaBuffer[rgbaIndex++] = 255; //alpha
        }
    }

    // module exports
    cornerstoneWADOImageLoader.convertYBRFull = convertYBRFull;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function configure(options) {
    cornerstoneWADOImageLoader.internal.options = options;
  }

  // module exports
  cornerstoneWADOImageLoader.configure = configure;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function createImageObject( dataSet, imageId, frame, sharedCacheKey ) {
    if(frame === undefined) {
      frame = 0;
    }

    // make the image based on whether it is color or not
    var photometricInterpretation = dataSet.string('x00280004');
    //console.log('---debug---',photometricInterpretation);
    var isColor = cornerstoneWADOImageLoader.isColorImage(photometricInterpretation);
    //console.log(isColor);
    if(isColor === false) {
      //console.log('follow:',imageId, dataSet, frame, sharedCacheKey);
      return cornerstoneWADOImageLoader.makeGrayscaleImage(imageId, dataSet, frame, sharedCacheKey);
    } else {
      return cornerstoneWADOImageLoader.makeColorImage(imageId, dataSet, frame, sharedCacheKey);
    }
  }

  // module exports
  cornerstoneWADOImageLoader.createImageObject = createImageObject;

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";
  function decodeJPEG2000(dataSet, frame)
  {
    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    //console.log('follow decodeJPEG2000',dataSet,frame);
    var compressedPixelData = dicomParser.readEncapsulatedPixelData(dataSet, dataSet.elements.x7fe00010, frame);
    //console.log('follow decodeJPEG2000 compressedPixelData',compressedPixelData);
    try{
      console.log(new JpxImage());
    }catch (e){console.error(e)}

    var jpxImage = new JpxImage();
    jpxImage.parse(compressedPixelData);
    //console.log('follow jpxImage ok');
    var j2kWidth = jpxImage.width;
    var j2kHeight = jpxImage.height;
    if(j2kWidth !== width) {console.log('JPEG2000 decoder returned width of ' + j2kWidth + ', when ' + width + ' is expected');
      throw 'JPEG2000 decoder returned width of ' + j2kWidth + ', when ' + width + ' is expected';
    }
    if(j2kHeight !== height) {console.log('JPEG2000 decoder returned width of ' + j2kHeight + ', when ' + height + ' is expected');
      throw 'JPEG2000 decoder returned width of ' + j2kHeight + ', when ' + height + ' is expected';
    }
    var tileCount = jpxImage.tiles.length;
    if(tileCount !== 1) {console.log('JPEG2000 decoder returned a tileCount of ' + tileCount + ', when 1 is expected');
      throw 'JPEG2000 decoder returned a tileCount of ' + tileCount + ', when 1 is expected';
    }
    var tileComponents = jpxImage.tiles[0];
    var pixelData = tileComponents.items;
    return pixelData;
  }

  cornerstoneWADOImageLoader.decodeJPEG2000 = decodeJPEG2000;
}($, cornerstone, cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";
  function decodeJPEGBaseline(dataSet, frame)
  {
    var pixelDataElement = dataSet.elements.x7fe00010;
    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    var bitsAllocated = dataSet.uint16('x00280100');
    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var jpeg = new JpegImage();
    jpeg.parse( frameData );
    if(bitsAllocated === 8) {
      return jpeg.getData(width, height);
    }
    else if(bitsAllocated === 16) {
      return jpeg.getData16(width, height);
    }
  }

  cornerstoneWADOImageLoader.decodeJPEGBaseline = decodeJPEGBaseline;
}($, cornerstone, cornerstoneWADOImageLoader));
/**
 * Special decoder for 8 bit jpeg that leverages the browser's built in JPEG decoder for increased performance
 */
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function arrayBufferToString(buffer) {
    return binaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer))));
  }

  function binaryToString(binary) {
    var error;

    try {
      return decodeURIComponent(escape(binary));
    } catch (_error) {
      error = _error;
      if (error instanceof URIError) {
        return binary;
      } else {
        throw error;
      }
    }
  }

  function decodeJPEGBaseline8Bit(canvas, dataSet, frame) {
    var deferred = $.Deferred();

    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    // resize the canvas
    canvas.height = height;
    canvas.width = width;

    var encodedPixelData = dicomParser.readEncapsulatedPixelData(dataSet, dataSet.elements.x7fe00010, frame);

    var imgBlob = new Blob([encodedPixelData], {type: "image/jpeg"});

    var r = new FileReader();
    if(r.readAsBinaryString === undefined) {
      r.readAsArrayBuffer(imgBlob);
    }
    else {
      r.readAsBinaryString(imgBlob); // doesn't work on IE11
    }

    r.onload = function(){
      var img=new Image();
      img.onload = function() {
        var context = canvas.getContext('2d');
        context.drawImage(this, 0, 0);
        var imageData = context.getImageData(0, 0, width, height);
        deferred.resolve(imageData);
      };
      img.onerror = function(error) {
        deferred.reject(error);
      };
      if(r.readAsBinaryString === undefined) {
        img.src = "data:image/jpeg;base64,"+window.btoa(arrayBufferToString(r.result));
      }
      else {
        img.src = "data:image/jpeg;base64,"+window.btoa(r.result); // doesn't work on IE11
      }

    };
    return deferred.promise();
  }

  function isJPEGBaseline8Bit(dataSet) {
    var transferSyntax = dataSet.string('x00020010');
    var bitsAllocated = dataSet.uint16('x00280100');

    if((bitsAllocated === 8) &&
      transferSyntax === "1.2.840.10008.1.2.4.50")
    {
      return true;
    }

  }

  // module exports
  cornerstoneWADOImageLoader.decodeJPEGBaseline8Bit = decodeJPEGBaseline8Bit;
  cornerstoneWADOImageLoader.isJPEGBaseline8Bit = isJPEGBaseline8Bit;

}(cornerstoneWADOImageLoader));
"use strict";
(function (cornerstoneWADOImageLoader) {

  function decodeJPEGLossless(dataSet, frame) {
    var pixelDataElement = dataSet.elements.x7fe00010;
    var bitsAllocated = dataSet.uint16('x00280100');
    var pixelRepresentation = dataSet.uint16('x00280103');
    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var byteOutput = bitsAllocated <= 8 ? 1 : 2;
    //console.time('jpeglossless');
    var decoder = new jpeg.lossless.Decoder();
    var decompressedData = decoder.decode(frameData.buffer, frameData.byteOffset, frameData.length, byteOutput);
    //console.timeEnd('jpeglossless');
    if (pixelRepresentation === 0) {
      if (byteOutput === 2) {
        return new Uint16Array(decompressedData.buffer);
      } else {
        // untested!
        return new Uint8Array(decompressedData.buffer);
      }
    } else {
      return new Int16Array(decompressedData.buffer);
    }
  }
  // module exports
  cornerstoneWADOImageLoader.decodeJPEGLossless = decodeJPEGLossless;

}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  function decodeRLE(dataSet, frame) {
    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    var samplesPerPixel = dataSet.uint16('x00280002');
    var pixelDataElement = dataSet.elements.x7fe00010;

    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);


    var frameSize = width*height;
    var buffer;
    if( pixelFormat===1 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel);
      decode8( frameData, buffer, frameSize, samplesPerPixel);
      return new Uint8Array(buffer);
    } else if( pixelFormat===2 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel*2);
      decode16( frameData, buffer, frameSize );
      return new Uint16Array(buffer);
    } else if( pixelFormat===3 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel*2);
      decode16( frameData, buffer, frameSize );
      return new Int16Array(buffer);
    }
  }

  function decode8( frameData, outFrame, frameSize, samplesSize ) {
    var header=new DataView(frameData.buffer, frameData.byteOffset);
    var data=new DataView( frameData.buffer, frameData.byteOffset );
    var out=new DataView( outFrame );

    var outIndex=0;
    var numSegments = header.getInt32(0,true);
    for( var s=0 ; s < numSegments ; ++s ) {
      outIndex = s;

      var inIndex=header.getInt32( (s+1)*4,true);
      var maxIndex=header.getInt32( (s+2)*4,true);
      if( maxIndex===0 )
        maxIndex = frameData.length;

      var endOfSegment = frameSize * numSegments;

      while( inIndex < maxIndex ) {
        var n=data.getInt8(inIndex++);
        if( n >=0 && n <=127 ) {
          // copy n bytes
          for( var i=0 ; i < n+1 && outIndex < endOfSegment; ++i ) {
            out.setInt8(outIndex, data.getInt8(inIndex++));
            outIndex+=samplesSize;
          }
        } else if( n<= -1 && n>=-127 ) {
          var value=data.getInt8(inIndex++);
          // run of n bytes
          for( var j=0 ; j < -n+1 && outIndex < endOfSegment; ++j ) {
            out.setInt8(outIndex, value );
            outIndex+=samplesSize;
          }
        } else if (n===-128)
          ; // do nothing
      }
    }
  }

  function decode16( frameData, outFrame, frameSize ) {
    var header=new DataView(frameData.buffer, frameData.byteOffset);
    var data=new DataView( frameData.buffer, frameData.byteOffset );
    var out=new DataView( outFrame );

    var numSegments = header.getInt32(0,true);
    for( var s=0 ; s < numSegments ; ++s ) {
      var outIndex=0;
      var highByte=( s===0 ? 1 : 0);

      var inIndex=header.getInt32( (s+1)*4,true);
      var maxIndex=header.getInt32( (s+2)*4,true);
      if( maxIndex===0 )
        maxIndex = frameData.length;

      while( inIndex < maxIndex ) {
        var n=data.getInt8(inIndex++);
        if( n >=0 && n <=127 ) {
          for( var i=0 ; i < n+1 && outIndex < frameSize ; ++i ) {
            out.setInt8( (outIndex*2)+highByte, data.getInt8(inIndex++) );
            outIndex++;
          }
        } else if( n<= -1 && n>=-127 ) {
          var value=data.getInt8(inIndex++);
          for( var j=0 ; j < -n+1 && outIndex < frameSize ; ++j ) {
            out.setInt8( (outIndex*2)+highByte, value );
            outIndex++;
          }
        } else if (n===-128)
          ; // do nothing
      }
    }
  }

  // module exports
  cornerstoneWADOImageLoader.decodeRLE = decodeRLE;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function decodeTransferSyntax(dataSet, frame) {
    var transferSyntax = dataSet.string('x00020010');
//console.log('follow transferSyntax:',transferSyntax);
    // Implicit VR Little Endian
    if( transferSyntax === "1.2.840.10008.1.2") {
      return cornerstoneWADOImageLoader.extractUncompressedPixels(dataSet, frame);
    }
    // Explicit VR Little Endian
    else if( transferSyntax === "1.2.840.10008.1.2.1") {
      return cornerstoneWADOImageLoader.extractUncompressedPixels(dataSet, frame);
    }
    // Explicit VR Big Endian (retired)
    else if ( transferSyntax === "1.2.840.10008.1.2.2" )
    {
      return cornerstoneWADOImageLoader.extractUncompressedPixels(dataSet, frame, true);
    }
    // JPEG 2000 Lossless
    else if(transferSyntax === "1.2.840.10008.1.2.4.90")
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    // JPEG 2000 Lossy
    else if(transferSyntax === "1.2.840.10008.1.2.4.91")
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    /* Don't know if these work...
    // JPEG 2000 Part 2 Multicomponent Image Compression (Lossless Only)
    else if(transferSyntax === "1.2.840.10008.1.2.4.92")
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    // JPEG 2000 Part 2 Multicomponent Image Compression
    else if(transferSyntax === "1.2.840.10008.1.2.4.93")
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    */
    // RLE Lossless
    else if ( transferSyntax === "1.2.840.10008.1.2.5" )
    {
      return cornerstoneWADOImageLoader.decodeRLE( dataSet, frame);
    }
    // JPEG Baseline lossy process 1 (8 bit)
    else if ( transferSyntax === "1.2.840.10008.1.2.4.50" )
    {
      return cornerstoneWADOImageLoader.decodeJPEGBaseline(dataSet, frame);
    }
    // JPEG Baseline lossy process 2 & 4 (12 bit)
    else if ( transferSyntax === "1.2.840.10008.1.2.4.51" )
    {
      return cornerstoneWADOImageLoader.decodeJPEGBaseline(dataSet, frame);
    }
    // JPEG Lossless, Nonhierarchical (Processes 14)
    else if ( transferSyntax === "1.2.840.10008.1.2.4.57" )
    {
      return cornerstoneWADOImageLoader.decodeJPEGLossless(dataSet, frame);
    }
    // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
    else if ( transferSyntax === "1.2.840.10008.1.2.4.70" )
    {
      return cornerstoneWADOImageLoader.decodeJPEGLossless(dataSet, frame);
    }
    else
    {
      if(console && console.log) {
        console.log("Image cannot be decoded due to Unsupported transfer syntax " + transferSyntax);
      }
      throw "no decoder for transfer syntax " + transferSyntax;
    }
  }

  // module exports
  cornerstoneWADOImageLoader.decodeTransferSyntax = decodeTransferSyntax;

}(cornerstoneWADOImageLoader));
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw "invalid ACn encoding";
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker <= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&
        p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&
        p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q <= -2056 / component.bitConversion) ? 0 :
        (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf("data:") > -1) {
        var offset = path.indexOf("base64,") + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i >= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h)
                maxH = h;
              if (maxV < v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 << frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
              data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i < frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable && component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw 'Unsupported color mode';
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    }
  };

  return constructor;
})();
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jpeg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
  }

},{}],2:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
  };



  jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
  };



  jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.DataStream;
  }

},{}],3:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


  /*** Constructor ***/
  jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.numBytes = 0;
    this.outputData = null;
    this.restarting = false;
    this.mask = 0;

    if (typeof numBytes !== "undefined") {
      this.numBytes = numBytes;
    }
  };


  /*** Static Pseudo-constants ***/

  jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
  jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
  jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
  jpeg.lossless.Decoder.MSB = 0x80000000;
  jpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;
  jpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;

  /*** Prototype Methods ***/

  jpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {
    return this.decode(buffer, offset, length).buffer;
  };



  jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== "undefined") {
      this.buffer = buffer;
    }

    if (typeof numBytes !== "undefined") {
      this.numBytes = numBytes;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
      throw new Error("Not a JPEG file");
    }

    current = this.stream.get16();

    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
      switch (current) {
        case 0xFFC4: // DHT
          this.huffTable.read(this.stream, this.HuffTab);
          break;
        case 0xFFCC: // DAC
          throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
        case 0xFFDB:
          this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
          break;
        case 0xFFDD:
          this.restartInterval = this.readNumber();
          break;
        case 0xFFE0:
        case 0xFFE1:
        case 0xFFE2:
        case 0xFFE3:
        case 0xFFE4:
        case 0xFFE5:
        case 0xFFE6:
        case 0xFFE7:
        case 0xFFE8:
        case 0xFFE9:
        case 0xFFEA:
        case 0xFFEB:
        case 0xFFEC:
        case 0xFFED:
        case 0xFFEE:
        case 0xFFEF:
          this.readApp();
          break;
        case 0xFFFE:
          this.readComment();
          break;
        default:
          if ((current >> 8) !== 0xFF) {
            throw new Error("ERROR: format throw new IOException! (decode)");
          }
      }

      current = this.stream.get16();
    }

    if ((current < 0xFFC0) || (current > 0xFFC7)) {
      throw new Error("ERROR: could not handle arithmetic code!");
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
      while (current !== 0x0FFDA) { // SOS
        switch (current) {
          case 0xFFC4: // DHT
            this.huffTable.read(this.stream, this.HuffTab);
            break;
          case 0xFFCC: // DAC
            throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
          case 0xFFDB:
            this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
            break;
          case 0xFFDD:
            this.restartInterval = this.readNumber();
            break;
          case 0xFFE0:
          case 0xFFE1:
          case 0xFFE2:
          case 0xFFE3:
          case 0xFFE4:
          case 0xFFE5:
          case 0xFFE6:
          case 0xFFE7:
          case 0xFFE8:
          case 0xFFE9:
          case 0xFFEA:
          case 0xFFEB:
          case 0xFFEC:
          case 0xFFED:
          case 0xFFEE:
          case 0xFFEF:
            this.readApp();
            break;
          case 0xFFFE:
            this.readComment();
            break;
          default:
            if ((current >> 8) !== 0xFF) {
              throw new Error("ERROR: format throw new IOException! (Parser.decode)");
            }
        }

        current = this.stream.get16();
      }

      this.precision = this.frame.precision;
      this.components = this.frame.components;

      if (!this.numBytes) {
        this.numBytes = parseInt(Math.ceil(this.precision / 8));
      }

      if (this.numBytes == 1) {
        this.mask = 0xFF;
      } else {
        this.mask = 0xFFFF;
      }

      this.scan.read(this.stream);
      this.numComp = this.scan.numComp;
      this.selection = this.scan.selection;

      if (this.numBytes === 1) {
        if (this.numComp === 3) {
          this.getter = this.getValueRGB;
          this.setter = this.setValueRGB;
          this.output = this.outputRGB;
        } else {
          this.getter = this.getValue8;
          this.setter = this.setValue8;
          this.output = this.outputSingle;
        }
      } else {
        this.getter = this.getValue16;
        this.setter = this.setValue16;
        this.output = this.outputSingle;
      }

      switch (this.selection) {
        case 2:
          this.selector = this.select2;
          break;
        case 3:
          this.selector = this.select3;
          break;
        case 4:
          this.selector = this.select4;
          break;
        case 5:
          this.selector = this.select5;
          break;
        case 6:
          this.selector = this.select6;
          break;
        case 7:
          this.selector = this.select7;
          break;
        default:
          this.selector = this.select1;
          break;
      }

      this.scanComps = this.scan.components;
      this.quantTables = this.quantTable.quantTables;

      for (i = 0; i < this.numComp; i+=1) {
        compN = this.scanComps[i].scanCompSel;
        this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
        this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
        this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
        this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
      }

      this.xDim = this.frame.dimX;
      this.yDim = this.frame.dimY;
      this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));

      scanNum+=1;

      while (true) { // Decode one scan
        temp[0] = 0;
        index[0] = 0;

        for (i = 0; i < 10; i+=1) {
          pred[i] = (1 << (this.precision - 1));
        }

        if (this.restartInterval === 0) {
          current = this.decodeUnit(pred, temp, index);

          while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {
            this.output(pred);
            current = this.decodeUnit(pred, temp, index);
          }

          break; //current=MARKER
        }

        for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {
          this.restarting = (mcuNum == 0);
          current = this.decodeUnit(pred, temp, index);
          this.output(pred);

          if (current !== 0) {
            break;
          }
        }

        if (current === 0) {
          if (this.markerIndex !== 0) {
            current = (0xFF00 | this.marker);
            this.markerIndex = 0;
          } else {
            current = this.stream.get16();
          }
        }

        if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&
          (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {
          break; //current=MARKER
        }
      }

      if ((current === 0xFFDC) && (scanNum === 1)) { //DNL
        this.readNumber();
        current = this.stream.get16();
      }
    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));

    return this.outputData;
  };



  jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    if (this.numComp == 1) {
      return this.decodeSingle(prev, temp, index);
    } else if (this.numComp == 3) {
      return this.decodeRGB(prev, temp, index);
    } else {
      return -1;
    }
  };



  jpeg.lossless.Decoder.prototype.select1 = function (compOffset) {
    return this.getPreviousX(compOffset);
  };



  jpeg.lossless.Decoder.prototype.select2 = function (compOffset) {
    return this.getPreviousY(compOffset);
  };



  jpeg.lossless.Decoder.prototype.select3 = function (compOffset) {
    return this.getPreviousXY(compOffset);
  };



  jpeg.lossless.Decoder.prototype.select4 = function (compOffset) {
    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);
  };



  jpeg.lossless.Decoder.prototype.select5 = function (compOffset) {
    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);
  };



  jpeg.lossless.Decoder.prototype.select6 = function (compOffset) {
    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);
  };



  jpeg.lossless.Decoder.prototype.select7 = function (compOffset) {
    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);
  };



  jpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    prev[0] = this.selector(0);
    prev[1] = this.selector(1);
    prev[2] = this.selector(2);

    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {
      qtab = this.qTab[ctrC];
      actab = this.acTab[ctrC];
      dctab = this.dcTab[ctrC];
      for (i = 0; i < this.nBlock[ctrC]; i+=1) {
        for (k = 0; k < this.IDCT_Source.length; k+=1) {
          this.IDCT_Source[k] = 0;
        }

        value = this.getHuffmanValue(dctab, temp, index);

        if (value >= 0xFF00) {
          return value;
        }

        prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
        this.IDCT_Source[0] *= qtab[0];

        for (j = 1; j < 64; j+=1) {
          value = this.getHuffmanValue(actab, temp, index);

          if (value >= 0xFF00) {
            return value;
          }

          j += (value >> 4);

          if ((value & 0x0F) === 0) {
            if ((value >> 4) === 0) {
              break;
            }
          } else {
            this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];
          }
        }
      }
    }

    return 0;
  };



  jpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, i, n, nRestart;

    if (this.restarting) {
      this.restarting = false;
      prev[0] = (1 << (this.frame.precision - 1));
    } else {
      prev[0] = this.selector();
    }

    for (i = 0; i < this.nBlock[0]; i+=1) {
      value = this.getHuffmanValue(this.dcTab[0], temp, index);
      if (value >= 0xFF00) {
        return value;
      }

      n = this.getn(prev, value, temp, index);
      nRestart = (n >> 8);

      if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {
        return nRestart;
      }

      prev[0] += n;
    }

    return 0;
  };



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from 'in', marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always > 8, or HuffmanValue()
//	        will not be called
  jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] < 8) {
      temp[0] <<= 8;
      input = this.stream.get8();
      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }
      temp[0] |= input;
    } else {
      index[0] -= 8;
    }

    code = table[temp[0] >> index[0]];

    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {
      if (this.markerIndex !== 0) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
      }

      temp[0] &= (mask >> (16 - index[0]));
      temp[0] <<= 8;
      input = this.stream.get8();

      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }

      temp[0] |= input;
      code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];
      index[0] += 8;
    }

    index[0] += 8 - (code >> 8);

    if (index[0] < 0) {
      throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");
    }

    if (index[0] < this.markerIndex) {
      this.markerIndex = 0;
      return 0xFF00 | this.marker;
    }

    temp[0] &= (mask >> (16 - index[0]));
    return code & 0xFF;
  };



  jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
      return 0;
    }

    if (n === 16) {
      if (PRED[0] >= 0) {
        return -32768;
      } else {
        return 32768;
      }
    }

    index[0] -= n;

    if (index[0] >= 0) {
      if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases
        this.markerIndex = 0;
        return (0xFF00 | this.marker) << 8;
      }

      result = temp[0] >> index[0];
      temp[0] &= (mask >> (16 - index[0]));
    } else {
      temp[0] <<= 8;
      input = this.stream.get8();

      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }

      temp[0] |= input;
      index[0] += 8;

      if (index[0] < 0) {
        if (this.markerIndex !== 0) {
          this.markerIndex = 0;
          return (0xFF00 | this.marker) << 8;
        }

        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
          this.marker = this.stream.get8();
          if (this.marker !== 0) {
            this.markerIndex = 9;
          }
        }

        temp[0] |= input;
        index[0] += 8;
      }

      if (index[0] < 0) {
        throw new Error("index=" + index[0] + " in getn()");
      }

      if (index[0] < this.markerIndex) {
        this.markerIndex = 0;
        return (0xFF00 | this.marker) << 8;
      }

      result = temp[0] >> index[0];
      temp[0] &= (mask >> (16 - index[0]));
    }

    if (result < (one << (n - 1))) {
      result += (n_one << n) + 1;
    }

    return result;
  };



  jpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {
    /*jslint bitwise: true */

    if (this.xLoc > 0) {
      return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);
    } else if (this.yLoc > 0) {
      return this.getPreviousY(compOffset);
    } else {
      return (1 << (this.frame.precision - 1));
    }
  };



  jpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {
    /*jslint bitwise: true */

    if ((this.xLoc > 0) && (this.yLoc > 0)) {
      return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);
    } else {
      return this.getPreviousY(compOffset);
    }
  };



  jpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {
    /*jslint bitwise: true */

    if (this.yLoc > 0) {
      return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);
    } else {
      return this.getPreviousX(compOffset);
    }
  };



  jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));
  };



  jpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {
    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
      this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);

      this.xLoc+=1;

      if (this.xLoc >= this.xDim) {
        this.yLoc+=1;
        this.xLoc = 0;
      }
    }
  };



  jpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {
    var offset = ((this.yLoc * this.xDim) + this.xLoc);

    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
      this.setter(offset, PRED[0], 0);
      this.setter(offset, PRED[1], 1);
      this.setter(offset, PRED[2], 2);

      this.xLoc+=1;

      if (this.xLoc >= this.xDim) {
        this.yLoc+=1;
        this.xLoc = 0;
      }
    }
  };



  jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
  };



  jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true) & this.mask;
  };



  jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
  };



  jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index) & this.mask;
  };



  jpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {
    this.outputData.setUint8(index * 3 + compOffset, val);
  };



  jpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {
    return this.outputData.getUint8(index * 3 + compOffset);
  };



  jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count < length) {
      this.stream.get8();
      count+=1;
    }

    return length;
  };



  jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = "", count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count < length) {
      sb += this.stream.get8();
      count+=1;
    }

    return sb;
  };



  jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
      throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");
    }

    return this.stream.get16();
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Decoder;
  }

},{"./data-stream.js":2,"./frame-header.js":4,"./huffman-table.js":5,"./quantization-table.js":7,"./scan-header.js":9,"./utils.js":10}],4:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);


  /*** Constructor ***/
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
  };



  /*** Prototype Methods ***/

  jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i <= this.numComp; i+=1) {
      if (count > length) {
        throw new Error("ERROR: frame format error");
      }

      c = data.get8();
      count+=1;

      if (count >= length) {
        throw new Error("ERROR: frame format error [c>=Lf]");
      }

      temp = data.get8();
      count+=1;

      if (!this.components[c]) {
        this.components[c] = new jpeg.lossless.ComponentSpec();
      }

      this.components[c].hSamp = temp >> 4;
      this.components[c].vSamp = temp & 0x0F;
      this.components[c].quantTableSel = data.get8();
      count+=1;
    }

    if (count !== length) {
      throw new Error("ERROR: frame format error [Lf!=count]");
    }

    return 1;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
  }

},{"./component-spec.js":1,"./data-stream.js":2}],5:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


  /*** Constructor ***/
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
  };



  /*** Static Pseudo-constants ***/

  jpeg.lossless.HuffmanTable.MSB = 0x80000000;


  /*** Prototype Methods ***/

  jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count < length) {
      temp = data.get8();
      count+=1;
      t = temp & 0x0F;
      if (t > 3) {
        throw new Error("ERROR: Huffman table ID > 3");
      }

      c = temp >> 4;
      if (c > 2) {
        throw new Error("ERROR: Huffman table [Table class > 2 ]");
      }

      this.th[t] = 1;
      this.tc[t][c] = 1;

      for (i = 0; i < 16; i+=1) {
        this.l[t][c][i] = data.get8();
        count+=1;
      }

      for (i = 0; i < 16; i+=1) {
        for (j = 0; j < this.l[t][c][i]; j+=1) {
          if (count > length) {
            throw new Error("ERROR: Huffman table format error [count>Lh]");
          }

          this.v[t][c][i][j] = data.get8();
          count+=1;
        }
      }
    }

    if (count !== length) {
      throw new Error("ERROR: Huffman table format error [count!=Lf]");
    }

    for (i = 0; i < 4; i+=1) {
      for (j = 0; j < 2; j+=1) {
        if (this.tc[i][j] !== 0) {
          this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
        }
      }
    }

    return 1;
  };



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
  jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i < 8; i+=1) { // i+1 is Code length
      for (j = 0; j < L[i]; j+=1) {
        for (n = 0; n < (temp >> (i + 1)); n+=1) {
          tab[k] = V[i][j] | ((i + 1) << 8);
          k+=1;
        }
      }
    }

    for (i = 1; k < 256; i+=1, k+=1) {
      tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i < 16; i+=1) { // i+1 is Code length
      for (j = 0; j < L[i]; j+=1) {
        for (n = 0; n < (temp >> (i - 7)); n+=1) {
          tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);
          k+=1;
        }

        if (k >= 256) {
          if (k > 256) {
            throw new Error("ERROR: Huffman table error(1)!");
          }

          k = 0;
          currentTable+=1;
        }
      }
    }
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
  }

},{"./data-stream.js":2,"./utils.js":10}],6:[function(require,module,exports){
  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ****/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
  jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== 'undefined') ? require('./decoder.js') : null);
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


  /*** Exports ***/
  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg;
  }

},{"./component-spec.js":1,"./data-stream.js":2,"./decoder.js":3,"./frame-header.js":4,"./huffman-table.js":5,"./quantization-table.js":7,"./scan-component.js":8,"./scan-header.js":9,"./utils.js":10}],7:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


  /*** Constructor ***/
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
  };



  /*** Static Methods ***/

  jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i < 8; i+=1) {
      qtab[table[(0 * 8) + i]] *= 90;
      qtab[table[(4 * 8) + i]] *= 90;
      qtab[table[(2 * 8) + i]] *= 118;
      qtab[table[(6 * 8) + i]] *= 49;
      qtab[table[(5 * 8) + i]] *= 71;
      qtab[table[(1 * 8) + i]] *= 126;
      qtab[table[(7 * 8) + i]] *= 25;
      qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i < 8; i+=1) {
      qtab[table[0 + (8 * i)]] *= 90;
      qtab[table[4 + (8 * i)]] *= 90;
      qtab[table[2 + (8 * i)]] *= 118;
      qtab[table[6 + (8 * i)]] *= 49;
      qtab[table[5 + (8 * i)]] *= 71;
      qtab[table[1 + (8 * i)]] *= 126;
      qtab[table[7 + (8 * i)]] *= 25;
      qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i < 64; i+=1) {
      qtab[i] >>= 6;
    }
  };


  /*** Prototype Methods ***/

  jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count < length) {
      temp = data.get8();
      count+=1;
      t = temp & 0x0F;

      if (t > 3) {
        throw new Error("ERROR: Quantization table ID > 3");
      }

      this.precision[t] = temp >> 4;

      if (this.precision[t] === 0) {
        this.precision[t] = 8;
      } else if (this.precision[t] === 1) {
        this.precision[t] = 16;
      } else {
        throw new Error("ERROR: Quantization table precision error");
      }

      this.tq[t] = 1;

      if (this.precision[t] === 8) {
        for (i = 0; i < 64; i+=1) {
          if (count > length) {
            throw new Error("ERROR: Quantization table format error");
          }

          this.quantTables[t][i] = data.get8();
          count+=1;
        }

        jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
      } else {
        for (i = 0; i < 64; i+=1) {
          if (count > length) {
            throw new Error("ERROR: Quantization table format error");
          }

          this.quantTables[t][i] = data.get16();
          count += 2;
        }

        jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
      }
    }

    if (count !== length) {
      throw new Error("ERROR: Quantization table error [count!=Lq]");
    }

    return 1;
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
  }

},{"./data-stream.js":2,"./utils.js":10}],8:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
  }

},{}],9:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);


  /*** Constructor ***/
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
  };


  /*** Prototype Methods ***/

  jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i < this.numComp; i+=1) {
      this.components[i] = new jpeg.lossless.ScanComponent();

      if (count > length) {
        throw new Error("ERROR: scan header format error");
      }

      this.components[i].scanCompSel = data.get8();
      count+=1;

      temp = data.get8();
      count+=1;

      this.components[i].dcTabSel = (temp >> 4);
      this.components[i].acTabSel = (temp & 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp >> 4);
    this.al = (temp & 0x0F);
    count+=1;

    if (count !== length) {
      throw new Error("ERROR: scan header format error [count!=Ns]");
    }

    return 1;
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
  }

},{"./data-stream.js":2,"./scan-component.js":8}],10:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  "use strict";

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.Utils = jpeg.lossless.Utils || {};


  /*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
  jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
      i = length;

    if (arguments.length > 1) {
      var args = Array.prototype.slice.call(arguments, 1);
      while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
  };


// http://stackoverflow.com/questions/18638900/javascript-crc32
  jpeg.lossless.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
      c = n;
      for(var k =0; k < 8; k++){
        c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      crcTable[n] = c;
    }
    return crcTable;
  };

  jpeg.lossless.Utils.crc32 = function(dataView) {
    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
      crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Utils;
  }

},{}]},{},[6])(6)
});
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";

  function swap16(val) {
    return ((val & 0xFF) << 8)
      | ((val >> 8) & 0xFF);
  }


  function extractUncompressedPixels(dataSet, frame, bigEndian)
  {
    var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);
    var imageFrame = getImageFrame(dataSet, frame, pixelFormat);
    // byte swap 16 bit data if bigEndian
    if(bigEndian && (pixelFormat === 2 || pixelFormat === 3)) {
      for(var i=0; i < imageFrame.length; i++) {
        imageFrame[i] = swap16(imageFrame[i]);
      }
    }
    return imageFrame;
  }

  function getImageFrame(dataSet, frame, pixelFormat) {
    // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size
    var pixelDataElement = dataSet.elements.x7fe00010;
    var height = dataSet.uint16('x00280010');
    var width = dataSet.uint16('x00280011');
    var samplesPerPixel = dataSet.uint16('x00280002');
    var pixelDataOffset = pixelDataElement.dataOffset;
    var numPixels = width * height * samplesPerPixel;
    if (!numPixels) {
      throw "Sanity check failed when calculating the number of pixels";
    }
    var frameOffset = 0;
    if(pixelFormat === 1) {
      frameOffset = pixelDataOffset + frame * numPixels;
      return new Uint8Array(dataSet.byteArray.buffer, frameOffset, numPixels);
    }
    else if(pixelFormat === 2) {
      frameOffset = pixelDataOffset + frame * numPixels * 2;
      return new Uint16Array(dataSet.byteArray.buffer, frameOffset, numPixels);
      return imageFrame;
    }
    else if(pixelFormat === 3) {
      frameOffset = pixelDataOffset + frame * numPixels * 2;
      return new Int16Array(dataSet.byteArray.buffer, frameOffset, numPixels);
    }
    throw "Unknown pixel format";
  }

  cornerstoneWADOImageLoader.extractUncompressedPixels = extractUncompressedPixels;
}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function getMinMax(storedPixelData)
  {
    // we always calculate the min max values since they are not always
    // present in DICOM and we don't want to trust them anyway as cornerstone
    // depends on us providing reliable values for these
    var min = 65535;
    var max = -32768;
    var numPixels = storedPixelData.length;
    var pixelData = storedPixelData;
    for(var index = 0; index < numPixels; index++) {
      var spv = pixelData[index];
      // TODO: test to see if it is faster to use conditional here rather than calling min/max functions
      min = Math.min(min, spv);
      max = Math.max(max, spv);
    }

    return {
      min: min,
      max: max
    };
  }

  // module exports
  cornerstoneWADOImageLoader.getMinMax = getMinMax;

}(cornerstoneWADOImageLoader));


(function (cornerstoneWADOImageLoader) {

  "use strict";

  function getPixelFormat(dataSet) {
    var pixelRepresentation = dataSet.uint16('x00280103');
    var bitsAllocated = dataSet.uint16('x00280100');
	 if(pixelRepresentation==undefined){console.log('pixelRepresentation undifined');pixelRepresentation=0;}//zyy add我操啊
    if(pixelRepresentation === 0 && bitsAllocated === 8) {
      return 1; // unsigned 8 bit
    } else if(pixelRepresentation === 0 && bitsAllocated === 16) {
      return 2; // unsigned 16 bit
    } else if(pixelRepresentation === 1 && bitsAllocated === 16) {
      return 3; // signed 16 bit data
    }
  }


  // module exports
  cornerstoneWADOImageLoader.getPixelFormat = getPixelFormat;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    "use strict";

    function getPixelSpacing(dataSet) {
      // NOTE - these are not required for all SOP Classes
      // so we return them as undefined.  We also do not
      // deal with the complexity associated with projection
      // radiographs here and leave that to a higher layer
      var pixelSpacing = dataSet.string('x00280030');
      if(pixelSpacing==""||pixelSpacing==null||pixelSpacing==undefined){
        pixelSpacing = dataSet.string('x00181164');
      }
      if (pixelSpacing && pixelSpacing.length > 0) {
        var split = pixelSpacing.split('\\');

        // Make sure that neither pixel spacing value is 0 or undefined
        if (parseFloat(split[0]) && parseFloat(split[1])) {
          return {
            row: parseFloat(split[0]),
            column: parseFloat(split[1])
          };
        }
      }

      return {
        row: undefined,
        column: undefined
      };
    }
    // module exports
    cornerstoneWADOImageLoader.getPixelSpacing = getPixelSpacing;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    "use strict";

    function getRescaleSlopeAndIntercept(dataSet)
    {
        // NOTE - we default these to an identity transform since modality LUT
        // module is not required for all SOP Classes
        var result = {
            intercept : 0.0,
            slope: 1.0
        };

        if(dataSet.elements.x00281052 && dataSet.elements.x00281053) {
          result.intercept = dataSet.floatString('x00281052') || result.intercept;
          result.slope = dataSet.floatString('x00281053') || result.slope;
        }

        return result;
    }

    // module exports
    cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept = getRescaleSlopeAndIntercept;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    "use strict";

    function getWindowWidthAndCenter(dataSet)
    {
        // NOTE - Default these to undefined since they may not be present as
        // they are not present or required for all sop classes.  We leave it up
        // to a higher layer to determine reasonable default values for these
        // if they are not provided.  We also use the first ww/wc values if
        // there are multiple and again leave it up the higher levels to deal with
        // this
        var result = {
            windowCenter : undefined,
            windowWidth: undefined
        };

        if(dataSet.elements.x00281050 && dataSet.elements.x00281051) {
          result.windowCenter = dataSet.floatString('x00281050');
          result.windowWidth = dataSet.floatString('x00281051');
        }

        return result;
    }

    // module exports
    cornerstoneWADOImageLoader.getWindowWidthAndCenter = getWindowWidthAndCenter;
}(cornerstoneWADOImageLoader));

(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";

  function loadImage(imageId) {
    // create a deferred object
    var deferred = $.Deferred();

    // build a url by parsing out the url scheme and frame index from the imageId
    var firstColonIndex = imageId.indexOf(':');
    var url = imageId.substring(firstColonIndex + 1);
    var frameIndex = url.indexOf('frame=');
    var frame;
    if(frameIndex !== -1) {
      var frameStr = url.substr(frameIndex + 6);
      frame = parseInt(frameStr);
      url = url.substr(0, frameIndex-1);
    }

    // if multiframe and cached, use the cached data set to extract the frame
    if(frame !== undefined &&
      cornerstoneWADOImageLoader.internal.multiFrameCacheHack.hasOwnProperty(url))
    {
      var dataSet = cornerstoneWADOImageLoader.internal.multiFrameCacheHack[url];
      var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame);
      imagePromise.then(function(image) {
        deferred.resolve(image);
      }, function(error) {
        deferred.reject(error);
      });
      return deferred.promise();
    }

    var fileIndex = parseInt(url);
    var file = cornerstoneWADOImageLoader.fileManager.get(fileIndex);
    if(file === undefined) {
      deferred.reject('unknown file index ' + url);
      return deferred.promise();
    }


    var fileReader = new FileReader();
    fileReader.onload = function(e) {
      // Parse the DICOM File
      var dicomPart10AsArrayBuffer = e.target.result;
      var byteArray = new Uint8Array(dicomPart10AsArrayBuffer);
      var dataSet = dicomParser.parseDicom(byteArray);

      // if multiframe, cache the parsed data set to speed up subsequent
      // requests for the other frames
      if(frame !== undefined) {
        var dataSet = cornerstoneWADOImageLoader.internal.multiFrameCacheHack[url];
        var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame);
        imagePromise.then(function(image) {
          deferred.resolve(image);
        }, function(error) {
          deferred.reject(error);
        });
        return deferred.promise();
      }

      var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame);
      imagePromise.then(function(image) {
        deferred.resolve(image);
      }, function(error) {
        deferred.reject(error);
      });
    };
    fileReader.readAsArrayBuffer(file);

    return deferred.promise();
  }

  // registery dicomweb and wadouri image loader prefixes
  cornerstone.registerImageLoader('dicomfile', loadImage);

}($, cornerstone, cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  "use strict";

  var files = [];

  function add(file) {
    var fileIndex =  files.push(file);
    return 'dicomfile:' + (fileIndex - 1);
  }

  function get(index) {
    return files[index];
  }

  function remove(index) {
    files[index] = undefined;
  }

  function purge() {
    files = [];
  }

  // module exports
  cornerstoneWADOImageLoader.fileManager = {
    add : add,
    get : get,
    remove:remove,
    purge: purge
  };

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  function checkToken(token, data, dataOffset) {

    if(dataOffset + token.length > data.length) {
      //console.log('dataOffset >> ', dataOffset);
      return false;
    }

    var endIndex = dataOffset;

    for(var i = 0; i < token.length; i++) {
      if(token[i] !== data[endIndex++]) {
        if(endIndex > 520000) {
          //console.log('token=',uint8ArrayToString(token));
          //console.log('data=', uint8ArrayToString(data, dataOffset, endIndex-dataOffset));
          //console.log('miss at %d %s dataOffset=%d', i, String.fromCharCode(data[endIndex]), endIndex);
          //console.log('miss at %d %s dataOffset=%d', i, String.fromCharCode(token[endIndex]), endIndex);
        }
        return false;
      }
    }
    return true;
  }

  function stringToUint8Array(str) {
    var uint=new Uint8Array(str.length);
    for(var i=0,j=str.length;i<j;i++){
      uint[i]=str.charCodeAt(i);
    }
    return uint;
  }

  function findIndexOfString(data, str, offset) {

    offset = offset || 0;

    var token = stringToUint8Array(str);

    for(var i=offset; i < data.length; i++) {
      if(token[0] === data[i]) {
        //console.log('match @', i);
        if(checkToken(token, data, i)) {
          return i;
        }
      }
    }
    return -1;
  }
  cornerstoneWADOImageLoader.internal.findIndexOfString = findIndexOfString;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  function findBoundary(header) {
    for(var i=0; i < header.length; i++) {
      if(header[i].substr(0,2) === '--') {
        return header[i];
      }
    }
    return undefined;
  }

  function findContentType(header) {
    for(var i=0; i < header.length; i++) {
      if(header[i].substr(0,13) === 'Content-Type:') {
        return header[i].substr(13).trim();
      }
    }
    return undefined;
  }

  function uint8ArrayToString(data, offset, length) {
    offset = offset || 0;
    length = length || data.length - offset;
    var str = "";
    for(var i=offset; i < offset + length; i++) {
      str += String.fromCharCode(data[i]);
    }
    return str;
  };

  cornerstoneWADOImageLoader.internal.getImageFrame = function(uri, mediaType) {
    mediaType = mediaType || 'application/octet-stream';

    var deferred = $.Deferred();

    var xhr = new XMLHttpRequest();
    xhr.responseType = "arraybuffer";
    xhr.open("get", uri, true);
    xhr.setRequestHeader('Accept', 'multipart/related;type=' + mediaType);
    xhr.onreadystatechange = function (oEvent) {
      // TODO: consider sending out progress messages here as we receive the pixel data
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          // request succeeded, Parse the multi-part mime response
          var imageFrameAsArrayBuffer = xhr.response;
          var response = new Uint8Array(xhr.response);
          // First look for the multipart mime header
          var tokenIndex = cornerstoneWADOImageLoader.internal.findIndexOfString(response, '\n\r\n');
          if(tokenIndex === -1) {
            deferred.reject('invalid response - no multipart mime header');
          }
          var header = uint8ArrayToString(response, 0, tokenIndex);
          // Now find the boundary  marker
          var split = header.split('\r\n');
          var boundary = findBoundary(split);
          if(!boundary) {
            deferred.reject('invalid response - no boundary marker')
          }
          var offset = tokenIndex + 4; // skip over the \n\r\n

          // find the terminal boundary marker
          var endIndex = cornerstoneWADOImageLoader.internal.findIndexOfString(response, boundary, offset);
          if(endIndex === -1) {
            deferred.reject('invalid response - terminating boundary not found');
          }
          // return the info for this pixel data
          var length = endIndex - offset - 1;
          deferred.resolve({
            contentType: findContentType(split),
            arrayBuffer: imageFrameAsArrayBuffer,
            offset: offset,
            length: length
          });
        }
        else {
          // request failed, reject the deferred
          deferred.reject(xhr.response);
        }
      }
    };
    xhr.send();

    return deferred.promise();
  };
}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  "use strict";

  var images = [];

  function add(image) {
    var fileIndex =  images.push(image);
    return 'wadors:' + (fileIndex - 1);
  }

  function get(index) {
    return images[index];
  }

  function remove(index) {
    images[index] = undefined;
  }

  function purge() {
    images = [];
  }

  // module exports
  cornerstoneWADOImageLoader.imageManager = {
    add : add,
    get : get,
    remove:remove,
    purge: purge
  };

}(cornerstoneWADOImageLoader));

(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";


  function loadImage(imageId) {
    var deferred = $.Deferred();
    var index = imageId.substring(7);
    var image = cornerstoneWADOImageLoader.imageManager.get(index);
    if(image === undefined) {
      deferred.reject('unknown imageId');
      return deferred.promise();
    }

    var mediaType;// = 'image/dicom+jp2';

    cornerstoneWADOImageLoader.internal.getImageFrame(image.uri, mediaType).then(function(result) {
      //console.log(result);
      // TODO: add support for retrieving compressed pixel data
      var storedPixelData;
      if(image.instance.bitsAllocated === 16) {
        if(image.instance.pixelRepresentation === 0) {
          storedPixelData = new Uint16Array(result.arrayBuffer, result.offset, result.length / 2);
        } else {
          storedPixelData = new Int16Array(result.arrayBuffer, result.offset, result.length / 2);
        }
      } else if(image.instance.bitsAllocated === 8) {
        storedPixelData = new Uint8Array(result.arrayBuffer, result.offset, result.length);
      }

      // TODO: handle various color space conversions


      var minMax = cornerstoneWADOImageLoader.getMinMax(storedPixelData);

 

      image.imageId = imageId;
      image.minPixelValue = minMax.min;
      image.maxPixelValue = minMax.max;
      image.render = cornerstone.renderGrayscaleImage;
      image.getPixelData = function() {
        return storedPixelData;
      };
      //console.log(image);
      deferred.resolve(image);
    }).fail(function(reason) {
      deferred.reject(reason);
    });

    return deferred.promise();
  }

  // registery dicomweb and wadouri image loader prefixes
  cornerstone.registerImageLoader('wadors', loadImage);

}($, cornerstone, cornerstoneWADOImageLoader));
/**
 * This object supports loading of DICOM P10 dataset from a uri and caching it so it can be accessed
 * by the caller.  This allows a caller to access the datasets without having to go through cornerstone's
 * image loader mechanism.  One reason a caller may need to do this is to determine the number of frames
 * in a multiframe sop instance so it can create the imageId's correctly.
 */
(function (cornerstoneWADOImageLoader) {

  "use strict";

  var loadedDataSets = {};
  var promises = {};

  // returns true if the wadouri for the specified index has been loaded
  function isLoaded(uri) {
    return loadedDataSets[uri] !== undefined;
  }

  // loads the dicom dataset from the wadouri sp
  function load(uri) {

    // if already loaded return it right away
    if(loadedDataSets[uri]) {
      //console.log('using loaded dataset ' + uri);
      var alreadyLoadedpromise = $.Deferred();
      loadedDataSets[uri].cacheCount++;
      alreadyLoadedpromise.resolve(loadedDataSets[uri].dataSet);
      return alreadyLoadedpromise;
    }

    // if we are currently loading this uri, return its promise
    if(promises[uri]) {
      //console.log('returning existing load promise for ' + uri);
      return promises[uri];
    }

    //console.log('loading ' + uri);

    // This uri is not loaded or being loaded, load it via an xhrRequest
    var promise = cornerstoneWADOImageLoader.internal.xhrRequest(uri);
    promises[uri] = promise;

    // handle success and failure of the XHR request load
    promise.then(function(dataSet) {
      loadedDataSets[uri] = {
        dataSet: dataSet,
        cacheCount: 1
      };
      // done loading, remove the promise
      delete promises[uri];
    }, function () {
    }).always(function() {
        // error thrown, remove the promise
        delete promises[uri];
      });
    return promise;
  }

  // remove the cached/loaded dicom dataset for the specified wadouri to free up memory
  function unload(uri) {
    //console.log('unload for ' + uri);
    if(loadedDataSets[uri]) {
      loadedDataSets[uri].cacheCount--;
      if(loadedDataSets[uri].cacheCount === 0) {
        //console.log('removing loaded dataset for ' + uri);
        delete loadedDataSets[uri];
      }
    }
  }

  // removes all cached datasets from memory
  function purge() {
    loadedDataSets = {};
    promises = {};
  }

  // module exports
  cornerstoneWADOImageLoader.dataSetCacheManager = {
    isLoaded: isLoaded,
    load: load,
    unload: unload,
    purge: purge
  };

}(cornerstoneWADOImageLoader));

(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";

  function parseImageId(imageId) {
    // build a url by parsing out the url scheme and frame index from the imageId
    var firstColonIndex = imageId.indexOf(':');
    var url = imageId.substring(firstColonIndex + 1);
    var frameIndex = url.indexOf('frame=');
    var frame;
    if(frameIndex !== -1) {
      var frameStr = url.substr(frameIndex + 6);
      frame = parseInt(frameStr);
      url = url.substr(0, frameIndex-1);
    }
    return {
      url : url,
      frame: frame
    };
  }

  // add a decache callback function to clear out our dataSetCacheManager
  function addDecache(image) {
    image.decache = function() {
      //console.log('decache');
      var parsedImageId = parseImageId(image.imageId);
      cornerstoneWADOImageLoader.dataSetCacheManager.unload(parsedImageId.url);
    };
  }

  function loadDataSetFromPromise(xhrRequestPromise, imageId, frame, sharedCacheKey) {
    var deferred = $.Deferred();
    xhrRequestPromise.then(function(dataSet) {
      var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame, sharedCacheKey);
      imagePromise.then(function(image) {
        addDecache(image);
        deferred.resolve(image);
      }, function(error) {
        deferred.reject(error);
      });
    }, function(error) {
      deferred.reject(error);
    });
    return deferred;
  }

  // Loads an image given an imageId
  // wado url example:
  // http://localhost:3333/wado?requestType=WADO&studyUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075541.1&seriesUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075541.2&objectUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075557.1&contentType=application%2Fdicom&transferSyntax=1.2.840.10008.1.2.1
  // NOTE: supposedly the instance will be returned in Explicit Little Endian transfer syntax if you don't
  // specify a transferSyntax but Osirix doesn't do this and seems to return it with the transfer syntax it is
  // stored as.
  function loadImage(imageId) {
    // create a deferred object

    // build a url by parsing out the url scheme and frame index from the imageId
    var parsedImageId = parseImageId(imageId);

    // if the dataset for this url is already loaded, use it
    if(cornerstoneWADOImageLoader.dataSetCacheManager.isLoaded(parsedImageId.url)) {
      return loadDataSetFromPromise(cornerstoneWADOImageLoader.dataSetCacheManager.load(parsedImageId.url), imageId, parsedImageId.frame, parsedImageId.url);
    }

    // if multiframe, load the dataSet via the dataSetCacheManager to keep it in memory
    if(parsedImageId.frame !== undefined) {
      return loadDataSetFromPromise(cornerstoneWADOImageLoader.dataSetCacheManager.load(parsedImageId.url), imageId, parsedImageId.frame, parsedImageId.url);
    }

    // not multiframe, load it directly and let cornerstone cache manager its lifetime
    var deferred = $.Deferred();
    var xhrRequestPromise =  cornerstoneWADOImageLoader.internal.xhrRequest(parsedImageId.url, imageId);
    xhrRequestPromise.then(function(dataSet) {
      var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, parsedImageId.frame);
      imagePromise.then(function(image) {
        addDecache(image);
        deferred.resolve(image);
      }, function(error) {
        deferred.reject(error);
      });
    }, function(error) {
      deferred.reject(error);
    });
    return deferred;
  }

  // registery dicomweb and wadouri image loader prefixes
  cornerstone.registerImageLoader('dicomweb', loadImage);
  cornerstone.registerImageLoader('wadouri', loadImage);

}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  var options = {
    // callback allowing customization of the xhr (e.g. adding custom auth headers, cors, etc)
    beforeSend : function(xhr) {}
  };

  function configure(opts) {
    options = opts;
  }

  function isColorImage(photoMetricInterpretation)
  {
    if(photoMetricInterpretation === "RGB" ||
      photoMetricInterpretation === "PALETTE COLOR" ||
      photoMetricInterpretation === "YBR_FULL" ||
      photoMetricInterpretation === "YBR_FULL_422" ||
      photoMetricInterpretation === "YBR_PARTIAL_422" ||
      photoMetricInterpretation === "YBR_PARTIAL_420" ||
      photoMetricInterpretation === "YBR_RCT" ||
      photoMetricInterpretation === "YBR_ICT")
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  cornerstoneWADOImageLoader.isColorImage = isColorImage;

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

    "use strict";

    var canvas = document.createElement('canvas');
    var lastImageIdDrawn = "";

    function extractStoredPixels(dataSet, frame) {

        // special case for JPEG Baseline 8 bit
        if(cornerstoneWADOImageLoader.isJPEGBaseline8Bit(dataSet) === true)
        {
          return cornerstoneWADOImageLoader.decodeJPEGBaseline8Bit(canvas, dataSet, frame);
        }

        var decodedImageFrame = cornerstoneWADOImageLoader.decodeTransferSyntax(dataSet, frame);

        return cornerstoneWADOImageLoader.convertColorSpace(canvas, dataSet, decodedImageFrame);
    }

    function makeColorImage(imageId, dataSet, frame, sharedCacheKey) {

        // extract the DICOM attributes we need
        var pixelSpacing = cornerstoneWADOImageLoader.getPixelSpacing(dataSet);
        var rows = dataSet.uint16('x00280010');
        var columns = dataSet.uint16('x00280011');
        var rescaleSlopeAndIntercept = cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept(dataSet);
        var bytesPerPixel = 4;
        var numPixels = rows * columns;
        //var sizeInBytes = numPixels * bytesPerPixel;
        var sizeInBytes = dataSet.byteArray.length;
        var windowWidthAndCenter = cornerstoneWADOImageLoader.getWindowWidthAndCenter(dataSet);

        // clear the lastImageIdDrawn so we update the canvas
        lastImageIdDrawn = undefined;

        var deferred = $.Deferred();

        // Decompress and decode the pixel data for this image
        var imageDataPromise;
        try {
          imageDataPromise = extractStoredPixels(dataSet, frame);
        }
        catch(err) {
          deferred.reject(err);
          return deferred.promise();
        }

        imageDataPromise.then(function(imageData) {
            function getPixelData() {
                return imageData.data;
            }

            function getImageData() {
                return imageData;
            }

            function getCanvas() {
                if(lastImageIdDrawn === imageId) {
                    return canvas;
                }

                canvas.height = rows;
                canvas.width = columns;
                var context = canvas.getContext('2d');
                context.putImageData(imageData, 0, 0 );
                lastImageIdDrawn = imageId;
                return canvas;
            }

            // Extract the various attributes we need
            var image = {
                imageId : imageId,
                minPixelValue : 0,
                maxPixelValue : 255,
                slope: rescaleSlopeAndIntercept.slope,
                intercept: rescaleSlopeAndIntercept.intercept,
                windowCenter : windowWidthAndCenter.windowCenter,
                windowWidth : windowWidthAndCenter.windowWidth,
                render: cornerstone.renderColorImage,
                getPixelData: getPixelData,
                getImageData: getImageData,
                getCanvas: getCanvas,
                rows: rows,
                columns: columns,
                height: rows,
                width: columns,
                color: true,
                columnPixelSpacing: pixelSpacing.column,
                rowPixelSpacing: pixelSpacing.row,
                data: dataSet,
                invert: false,
                fakeColor:false,//zyy add
                sizeInBytes: sizeInBytes,
                sharedCacheKey: sharedCacheKey
            };

          if(image.windowCenter === undefined || isNaN(image.windowCenter) ||
            image.windowWidth === undefined || isNaN(image.windowWidth)) {
                image.windowWidth = 255;
                image.windowCenter = 128;
            }
            deferred.resolve(image);
        }, function(error) {
            deferred.reject(error);
        });

        return deferred.promise();
    }

    // module exports
    cornerstoneWADOImageLoader.makeColorImage = makeColorImage;
}($, cornerstone, cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

    "use strict";

    function getBytesPerPixel(dataSet)
    {
        var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);
        if(pixelFormat ===1) {
            return 1;
        }
        else if(pixelFormat ===2 || pixelFormat ===3){
            return 2;
        }
        throw "unknown pixel format";
    }

    function getLUT(image, pixelRepresentation, lutDataSet) {
      var numLUTEntries = lutDataSet.uint16('x00283002', 0);
      if(numLUTEntries === 0) {
        numLUTEntries = 65535;
      }
      var firstValueMapped = 0;
      if(pixelRepresentation === 0) {
        firstValueMapped = lutDataSet.uint16('x00283002', 1);
      } else {
         firstValueMapped = lutDataSet.int16('x00283002', 1);
      }
      var numBitsPerEntry = lutDataSet.uint16('x00283002', 2);
      //console.log('LUT(', numLUTEntries, ',', firstValueMapped, ',', numBitsPerEntry, ')');
      var lut = {
        id : '1',
        firstValueMapped: firstValueMapped,
        numBitsPerEntry : numBitsPerEntry,
        lut : []
      };

      //console.log("minValue=", minValue, "; maxValue=", maxValue);
      for (var i = 0; i < numLUTEntries; i++) {
        if(pixelRepresentation === 0) {
          lut.lut[i] = lutDataSet.uint16('x00283006', i);
        } else {
          lut.lut[i] = lutDataSet.int16('x00283006', i);
        }
      }
      return lut;
    }

    function makeGrayscaleImage(imageId, dataSet, frame, sharedCacheKey) {
        var deferred = $.Deferred();

        // extract the DICOM attributes we need
        var pixelSpacing = cornerstoneWADOImageLoader.getPixelSpacing(dataSet);
        var rows = dataSet.uint16('x00280010');
        var columns = dataSet.uint16('x00280011');
        var rescaleSlopeAndIntercept = cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept(dataSet);

        var bytesPerPixel;
        try {
            bytesPerPixel = getBytesPerPixel(dataSet);
        } catch(error) {
            deferred.reject(error);
            return deferred.promise();
        }
        //console.log('follow1');
        var numPixels = rows * columns;
        //var sizeInBytes = numPixels * bytesPerPixel;
        var sizeInBytes = dataSet.byteArray.length;
        var photometricInterpretation = dataSet.string('x00280004');
        var invert = (photometricInterpretation === "MONOCHROME1");
        var windowWidthAndCenter = cornerstoneWADOImageLoader.getWindowWidthAndCenter(dataSet);

        // Decompress and decode the pixel data for this image
        var storedPixelData;
        try {
          //console.log('follow1-2');
          storedPixelData = cornerstoneWADOImageLoader.decodeTransferSyntax(dataSet, frame);
          //console.log('follow1-3');
        }
        catch(err) {
          deferred.reject(err);
          return deferred.promise();
        }
//console.log('follow2');
        var minMax = cornerstoneWADOImageLoader.getMinMax(storedPixelData);

        function getPixelData() {
            return storedPixelData;
        }


        // Extract the various attributes we need
        var image = {
            imageId : imageId,
            minPixelValue : minMax.min,
            maxPixelValue : minMax.max,
            slope: rescaleSlopeAndIntercept.slope,
            intercept: rescaleSlopeAndIntercept.intercept,
            windowCenter : windowWidthAndCenter.windowCenter,
            windowWidth : windowWidthAndCenter.windowWidth,
            render: cornerstone.renderGrayscaleImage,
            getPixelData: getPixelData,
            rows: rows,
            columns: columns,
            height: rows,
            width: columns,
            color: false,
            columnPixelSpacing: pixelSpacing.column,
            rowPixelSpacing: pixelSpacing.row,
            data: dataSet,
            invert: invert,
            fakeColor:false,//zyy add
            sizeInBytes: sizeInBytes,
            sharedCacheKey: sharedCacheKey
        };
      //console.log('follow3',image);
        // modality LUT
        var pixelRepresentation = dataSet.uint16('x00280103');
        if(dataSet.elements.x00283000) {
          image.modalityLUT = getLUT(image, pixelRepresentation, dataSet.elements.x00283000.items[0].dataSet);
        }

        // VOI LUT
        if(dataSet.elements.x00283010) {
          pixelRepresentation = 0;
          // if modality LUT can produce negative values, the data is signed
          if(image.minPixelValue * image.slope + image.intercept < 0) {
            pixelRepresentation = 1;
          }
          image.voiLUT = getLUT(image, pixelRepresentation, dataSet.elements.x00283010.items[0].dataSet);
        }

        // TODO: deal with pixel padding and all of the various issues by setting it to min pixel value (or lower)
        // TODO: Mask out overlays embedded in pixel data above high bit

        if(image.windowCenter === undefined || isNaN(image.windowCenter) ||
           image.windowWidth === undefined || isNaN(image.windowWidth)) {
            var maxVoi = image.maxPixelValue * image.slope + image.intercept;
            var minVoi = image.minPixelValue * image.slope + image.intercept;
            image.windowWidth = maxVoi - minVoi;
            image.windowCenter = (maxVoi + minVoi) / 2;
        }

        deferred.resolve(image);
        return deferred.promise();
    }

    // module exports
    cornerstoneWADOImageLoader.makeGrayscaleImage = makeGrayscaleImage;
}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  "use strict";

  // module exports
  cornerstoneWADOImageLoader.version = '0.9.2';

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  "use strict";

  function xhrRequest(url, imageId) {

    var deferred = $.Deferred();

    // Make the request for the DICOM P10 SOP Instance
    var xhr = new XMLHttpRequest();
    xhr.open("get", url, true);
    xhr.responseType = "arraybuffer";
      cornerstoneWADOImageLoader.internal.options.beforeSend(xhr);
    xhr.onreadystatechange = function (oEvent) {
      // TODO: consider sending out progress messages here as we receive the pixel data
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          // request succeeded, create an image object and resolve the deferred

          // Parse the DICOM File
          var dicomPart10AsArrayBuffer = xhr.response;
          var byteArray = new Uint8Array(dicomPart10AsArrayBuffer);
          var dataSet = dicomParser.parseDicom(byteArray);

          deferred.resolve(dataSet);
        }
        else {
          // request failed, reject the deferred
          deferred.reject(xhr.response);
        }
      }
    };
    xhr.onprogress = function (oProgress) {
      // console.log('progress:',oProgress)

      if (oProgress.lengthComputable) {  //evt.loaded the bytes browser receive
        //evt.total the total bytes seted by the header
        //
        var loaded = oProgress.loaded;
        var total = oProgress.total;
        var percentComplete = Math.round((loaded / total) * 100);

        $(cornerstone).trigger('CornerstoneImageLoadProgress', {
          imageId: imageId,
          loaded: loaded,
          total: total,
          percentComplete: percentComplete
        });
      }
    };

    xhr.send();

    return deferred.promise();
  }

  cornerstoneWADOImageLoader.internal.xhrRequest = xhrRequest;
}($, cornerstone, cornerstoneWADOImageLoader));

/*! dicom-parser - v1.1.7 - 2015-09-18 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */
!function(a,b){"undefined"!=typeof module&&module.exports?module.exports=b():"function"==typeof define&&define.amd?define([],b):("undefined"==typeof cornerstone&&(dicomParser={},"undefined"!=typeof Package&&(a.dicomParser=dicomParser)),dicomParser=b())}(this,function(){var a=function(a){return void 0===a&&(a={}),a.parseDicom=function(b,c){function d(){l.seek(128);var a=l.readFixedString(4);/*if("DICM"!==a)throw"dicomParser.parseDicom: DICM prefix not found at location 132"*/}function e(){d();for(var b=[],c={};l.position<l.byteArray.length;){var e=l.position,f=a.readDicomElementExplicit(l,b);if(f.tag>"x0002ffff"){l.position=e;break}f.parser=a.littleEndianByteArrayParser,c[f.tag]=f}var g=new a.DataSet(l.byteArrayParser,l.byteArray,c);return g.warnings=l.warnings,g}function f(b){if(void 0===b.elements.x00020010){
    c = {dataOffset:250,length:18,
        parser:{tag:"x00020010",vr:'UI'}};
    return a.readFixedString(l.byteArray,c.dataOffset,c.length);}else{var c=b.elements.x00020010;/*console.log(c);*/return a.readFixedString(l.byteArray,c.dataOffset,c.length);}}function g(a){return"1.2.840.10008.1.2"===a?!1:!0}function h(c){return"1.2.840.10008.1.2.2"===c?new a.ByteStream(a.bigEndianByteArrayParser,b,l.position):new a.ByteStream(a.littleEndianByteArrayParser,b,l.position)}function i(a,b){for(var c in a.elements)a.elements.hasOwnProperty(c)&&(b.elements[c]=a.elements[c]);return void 0!==a.warnings&&(b.warnings=a.warnings.concat(b.warnings)),b}function j(b){var d=f(b),e=g(d),i=h(d),j={},k=new a.DataSet(i.byteArrayParser,i.byteArray,j);k.warnings=i.warnings;try{e?a.parseDicomDataSetExplicit(k,i,i.byteArray.length,c):a.parseDicomDataSetImplicit(k,i,i.byteArray.length,c)}catch(l){var m={exception:l,dataSet:k};throw m}return k}function k(){var a=e(),b=j(a);return i(a,b)}if(void 0===b)throw"dicomParser.parseDicom: missing required parameter 'byteArray'";var l=new a.ByteStream(a.littleEndianByteArrayParser,b);return k()},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.explicitDataSetToJS=function(b,c){if(void 0===b)throw"dicomParser.explicitDataSetToJS: missing required parameter dataSet";c=c||{omitPrivateAttibutes:!0,maxElementLength:128};var d={};for(var e in b.elements){var f=b.elements[e];if(c.omitPrivateAttibutes!==!0||!a.isPrivateTag(e))if(f.items){for(var g=[],h=0;h<f.items.length;h++)g.push(a.explicitDataSetToJS(f.items[h].dataSet,c));d[e]=g}else{var i;i=void 0,f.length<c.maxElementLength&&(i=a.explicitElementToString(b,f)),void 0!==i?d[e]=i:d[e]={dataOffset:f.dataOffset,length:f.length}}}return d},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.explicitElementToString=function(b,c){function d(a,c){for(var d="",e=0;a>e;e++)0!==e&&(d+="/"),d+=c.call(b,g).toString();return d}if(void 0===b||void 0===c)throw"dicomParser.explicitElementToString: missing required parameters";if(void 0===c.vr)throw"dicomParser.explicitElementToString: cannot convert implicit element to string";var e,f=c.vr,g=c.tag;if(a.isStringVr(f)===!0)e=b.string(g);else{if("AT"==f){var h=b.uint32(g);return void 0===h?void 0:(0>h&&(h=4294967295+h+1),"x"+h.toString(16).toUpperCase())}"US"==f?e=d(c.length/2,b.uint16):"SS"===f?e=d(c.length/2,b.int16):"UL"==f?e=d(c.length/4,b.uint32):"SL"===f?e=d(c.length/4,b.int32):"FD"==f?e=d(c.length/8,b["double"]):"FL"==f&&(e=d(c.length/4,b["float"]))}return e},a}(a),a=function(a){"use strict";function b(a,b){switch(a){case 2:return b%4==0&&b%100||b%400==0?29:28;case 9:case 4:case 6:case 11:return 30;default:return 31}}function c(a,c,d){return isNaN(d)?!1:c>0&&12>=c&&a>0&&a<=b(c,d)}return void 0===a&&(a={}),a.parseDA=function(a,b){if(a&&8===a.length){var d=parseInt(a.substring(0,4),10),e=parseInt(a.substring(4,6),10),f=parseInt(a.substring(6,8),10);if(b&&c(f,e,d)!==!0)throw"invalid DA '"+a+"'";return{year:d,month:e,day:f}}if(b)throw"invalid DA '"+a+"'";return void 0},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.parseTM=function(a,b){if(a.length>=2){var c=parseInt(a.substring(0,2),10),d=a.length>=4?parseInt(a.substring(2,4),10):void 0,e=a.length>=6?parseInt(a.substring(4,6),10):void 0,f=a.length>=8?parseInt(a.substring(7,13),10):void 0;if(b&&(isNaN(c)||void 0!==d&&isNaN(d)||void 0!==e&&isNaN(e)||void 0!==f&&isNaN(f)||0>c||c>23||d&&(0>d||d>59)||e&&(0>e||e>59)||f&&(0>f||f>999999)))throw"invalid TM '"+a+"'";return{hours:c,minutes:d,seconds:e,fractionalSeconds:f}}if(b)throw"invalid TM '"+a+"'";return void 0},a}(a),a=function(a){"use strict";void 0===a&&(a={});var b={AE:!0,AS:!0,AT:!1,CS:!0,DA:!0,DS:!0,DT:!0,FL:!1,FD:!1,IS:!0,LO:!0,LT:!0,OB:!1,OD:!1,OF:!1,OW:!1,PN:!0,SH:!0,SL:!1,SQ:!1,SS:!1,ST:!0,TM:!0,UI:!0,UL:!1,UN:void 0,UR:!0,US:!1,UT:!0};return a.isStringVr=function(a){return b[a]},a.isPrivateTag=function(a){var b=parseInt(a[4]),c=b%2===1;return c},a.parsePN=function(a){if(void 0===a)return void 0;var b=a.split("^");return{familyName:b[0],givenName:b[1],middleName:b[2],prefix:b[3],suffix:b[4]}},a}(a),a=function(a){"use strict";function b(a,b,c){if(1===b.length)return new Uint8Array(a.byteArray.buffer,b[0].dataOffset,b[0].length);for(var d=new Uint8Array(c),e=0,f=0;f<b.length;f++)for(var g=b[f].dataOffset,h=0;h<b[f].length;h++)d[e++]=a.byteArray[g++];return d}function c(c,d){for(var e=[],f=0;c.position<d&&c.position<c.byteArray.length;){var g=a.readSequenceItem(c);if("xfffee0dd"===g.tag)break;e.push(g),c.seek(g.length),f+=g.length}var h=b(c,e,f);return h}function d(a,b,d){var e=a.basicOffsetTable.length;if(d>e)throw"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table";var f=a.basicOffsetTable[d],g=b.position;b.seek(f);var h=a.basicOffsetTable[d+1];void 0===h?h=b.position+a.length:h+=g;var i=c(b,h);return i}function e(a,b,d){if(0!==d)throw"dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data";var e=b.position+a.length,f=c(b,e);return f}return void 0===a&&(a={}),a.readEncapsulatedPixelData=function(b,c,f){if(void 0===b)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";if(void 0===c)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";if(void 0===f)throw"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";if("x7fe00010"!==c.tag)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'";if(c.encapsulatedPixelData!==!0)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(c.hadUndefinedLength!==!0)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(void 0===c.basicOffsetTable)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(void 0===c.fragments)throw"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";if(0>f)throw"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";var g=new a.ByteStream(b.byteArrayParser,b.byteArray,c.dataOffset),h=a.readSequenceItem(g);if("xfffee000"!==h.tag)throw"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";return g.seek(h.length),0!==c.basicOffsetTable.length?d(c,g,f):e(c,g,f)},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.bigEndianByteArrayParser={readUint16:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readUint16: position cannot be less than 0";if(b+2>a.length)throw"bigEndianByteArrayParser.readUint16: attempt to read past end of buffer";return(a[b]<<8)+a[b+1]},readInt16:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readInt16: position cannot be less than 0";if(b+2>a.length)throw"bigEndianByteArrayParser.readInt16: attempt to read past end of buffer";var c=(a[b]<<8)+a[b+1];return 32768&c&&(c=c-65535-1),c},readUint32:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readUint32: position cannot be less than 0";if(b+4>a.length)throw"bigEndianByteArrayParser.readUint32: attempt to read past end of buffer";var c=256*(256*(256*a[b]+a[b+1])+a[b+2])+a[b+3];return c},readInt32:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readInt32: position cannot be less than 0";if(b+4>a.length)throw"bigEndianByteArrayParser.readInt32: attempt to read past end of buffer";var c=(a[b]<<24)+(a[b+1]<<16)+(a[b+2]<<8)+a[b+3];return c},readFloat:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readFloat: position cannot be less than 0";if(b+4>a.length)throw"bigEndianByteArrayParser.readFloat: attempt to read past end of buffer";var c=new Uint8Array(4);c[3]=a[b],c[2]=a[b+1],c[1]=a[b+2],c[0]=a[b+3];var d=new Float32Array(c.buffer);return d[0]},readDouble:function(a,b){if(0>b)throw"bigEndianByteArrayParser.readDouble: position cannot be less than 0";if(b+8>a.length)throw"bigEndianByteArrayParser.readDouble: attempt to read past end of buffer";var c=new Uint8Array(8);c[7]=a[b],c[6]=a[b+1],c[5]=a[b+2],c[4]=a[b+3],c[3]=a[b+4],c[2]=a[b+5],c[1]=a[b+6],c[0]=a[b+7];var d=new Float64Array(c.buffer);return d[0]}},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.readFixedString=function(a,b,c){if(0>c)throw"readFixedString - length cannot be less than 0";if(b+c>a.length)throw"dicomParser.readFixedString: attempt to read past end of buffer";for(var d="",e=0;c>e;e++){var f=a[b+e];if(0===f)return b+=c,d;d+=String.fromCharCode(f)}return d},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.ByteStream=function(a,b,c){if(void 0===a)throw"dicomParser.ByteStream: missing required parameter 'byteArrayParser'";if(void 0===b)throw"dicomParser.ByteStream: missing required parameter 'byteArray'";if(b instanceof Uint8Array==!1)throw"dicomParser.ByteStream: parameter byteArray is not of type Uint8Array";if(0>c)throw"dicomParser.ByteStream: parameter 'position' cannot be less than 0";if(c>=b.length)throw"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";this.byteArrayParser=a,this.byteArray=b,this.position=c?c:0,this.warnings=[]},a.ByteStream.prototype.seek=function(a){if(this.position+a<0)throw"cannot seek to position < 0";this.position+=a},a.ByteStream.prototype.readByteStream=function(b){if(this.position+b>this.byteArray.length)throw"readByteStream - buffer overread";var c=new Uint8Array(this.byteArray.buffer,this.position,b);return this.position+=b,new a.ByteStream(this.byteArrayParser,c)},a.ByteStream.prototype.readUint16=function(){var a=this.byteArrayParser.readUint16(this.byteArray,this.position);return this.position+=2,a},a.ByteStream.prototype.readUint32=function(){var a=this.byteArrayParser.readUint32(this.byteArray,this.position);return this.position+=4,a},a.ByteStream.prototype.readFixedString=function(b){var c=a.readFixedString(this.byteArray,this.position,b);return this.position+=b,c},a}(a),a=function(a){"use strict";function b(a,b){return void 0!==a.parser?a.parser:b}return void 0===a&&(a={}),a.DataSet=function(a,b,c){this.byteArrayParser=a,this.byteArray=b,this.elements=c},a.DataSet.prototype.uint16=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readUint16(this.byteArray,d.dataOffset+2*c):void 0},a.DataSet.prototype.int16=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readInt16(this.byteArray,d.dataOffset+2*c):void 0},a.DataSet.prototype.uint32=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readUint32(this.byteArray,d.dataOffset+4*c):void 0},a.DataSet.prototype.int32=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readInt32(this.byteArray,d.dataOffset+4*c):void 0},a.DataSet.prototype["float"]=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readFloat(this.byteArray,d.dataOffset+4*c):void 0},a.DataSet.prototype["double"]=function(a,c){var d=this.elements[a];return c=void 0!==c?c:0,d&&0!==d.length?b(d,this.byteArrayParser).readDouble(this.byteArray,d.dataOffset+8*c):void 0},a.DataSet.prototype.numStringValues=function(b){var c=this.elements[b];if(c&&c.length>0){var d=a.readFixedString(this.byteArray,c.dataOffset,c.length),e=d.match(/\\/g);return null===e?1:e.length+1}return void 0},a.DataSet.prototype.string=function(b,c){var d=this.elements[b];if(d&&d.length>0){var e=a.readFixedString(this.byteArray,d.dataOffset,d.length);if(c>=0){var f=e.split("\\");return f[c].trim()}return e.trim()}return void 0},a.DataSet.prototype.text=function(b,c){var d=this.elements[b];if(d&&d.length>0){var e=a.readFixedString(this.byteArray,d.dataOffset,d.length);if(c>=0){var f=e.split("\\");return f[c].replace(/ +$/,"")}return e.replace(/ +$/,"")}return void 0},a.DataSet.prototype.floatString=function(a,b){var c=this.elements[a];if(c&&c.length>0){b=void 0!==b?b:0;var d=this.string(a,b);if(void 0!==d)return parseFloat(d)}return void 0},a.DataSet.prototype.intString=function(a,b){var c=this.elements[a];if(c&&c.length>0){b=void 0!==b?b:0;var d=this.string(a,b);if(void 0!==d)return parseInt(d)}return void 0},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.findEndOfEncapsulatedElement=function(b,c,d){if(void 0===b)throw"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";if(void 0===c)throw"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";c.encapsulatedPixelData=!0,c.basicOffsetTable=[],c.fragments=[];var e=a.readTag(b);if("xfffee000"!==e)throw"dicomParser.findEndOfEncapsulatedElement: basic offset table not found";for(var f=b.readUint32(),g=f/4,h=0;g>h;h++){var i=b.readUint32();c.basicOffsetTable.push(i)}for(var j=b.position;b.position<b.byteArray.length;){var k=a.readTag(b),l=b.readUint32();if("xfffee0dd"===k)return b.seek(l),void(c.length=b.position-c.dataOffset);if("xfffee000"!==k)return d&&d.push("unexpected tag "+k+" while searching for end of pixel data element with undefined length"),l>b.byteArray.length-b.position&&(l=b.byteArray.length-b.position),c.fragments.push({offset:b.position-j-8,position:b.position,length:l}),b.seek(l),void(c.length=b.position-c.dataOffset);c.fragments.push({offset:b.position-j-8,position:b.position,length:l}),b.seek(l)}d&&d.push("pixel data element "+c.tag+" missing sequence delimiter tag xfffee0dd")},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.findItemDelimitationItemAndSetElementLength=function(a,b){if(void 0===a)throw"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";for(var c=8,d=a.byteArray.length-c;a.position<=d;){var e=a.readUint16();if(65534===e){var f=a.readUint16();if(57357===f){var g=a.readUint32();return 0!==g&&a.warnings("encountered non zero length following item delimiter at position"+a.position-4+" while reading element of undefined length with tag ' + element.tag"),void(b.length=a.position-b.dataOffset)}}}b.length=a.byteArray.length-b.dataOffset,a.seek(a.byteArray.length-a.position)},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.littleEndianByteArrayParser={readUint16:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readUint16: position cannot be less than 0";if(b+2>a.length)throw"littleEndianByteArrayParser.readUint16: attempt to read past end of buffer";return a[b]+256*a[b+1]},readInt16:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readInt16: position cannot be less than 0";if(b+2>a.length)throw"littleEndianByteArrayParser.readInt16: attempt to read past end of buffer";var c=a[b]+(a[b+1]<<8);return 32768&c&&(c=c-65535-1),c},readUint32:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readUint32: position cannot be less than 0";if(b+4>a.length)throw"littleEndianByteArrayParser.readUint32: attempt to read past end of buffer";var c=a[b]+256*a[b+1]+256*a[b+2]*256+256*a[b+3]*256*256;return c},readInt32:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readInt32: position cannot be less than 0";if(b+4>a.length)throw"littleEndianByteArrayParser.readInt32: attempt to read past end of buffer";var c=a[b]+(a[b+1]<<8)+(a[b+2]<<16)+(a[b+3]<<24);return c},readFloat:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readFloat: position cannot be less than 0";if(b+4>a.length)throw"littleEndianByteArrayParser.readFloat: attempt to read past end of buffer";var c=new Uint8Array(4);c[0]=a[b],c[1]=a[b+1],c[2]=a[b+2],c[3]=a[b+3];var d=new Float32Array(c.buffer);return d[0]},readDouble:function(a,b){if(0>b)throw"littleEndianByteArrayParser.readDouble: position cannot be less than 0";if(b+8>a.length)throw"littleEndianByteArrayParser.readDouble: attempt to read past end of buffer";var c=new Uint8Array(8);c[0]=a[b],c[1]=a[b+1],c[2]=a[b+2],c[3]=a[b+3],c[4]=a[b+4],c[5]=a[b+5],c[6]=a[b+6],c[7]=a[b+7];var d=new Float64Array(c.buffer);return d[0]}},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.parseDicomDataSetExplicit=function(b,c,d,e){if(d=void 0===d?c.byteArray.length:d,e=e||{},void 0===c)throw"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";if(d<c.position||d>c.byteArray.length)throw"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'";for(var f=b.elements;c.position<d;){var g=a.readDicomElementExplicit(c,b.warnings,e.untilTag);if(f[g.tag]=g,g.tag===e.untilTag)return}if(c.position>d)throw"dicomParser:parseDicomDataSetExplicit: buffer overrun"},a.parseDicomDataSetImplicit=function(b,c,d,e){if(d=void 0===d?b.byteArray.length:d,e=e||{},void 0===c)throw"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";if(d<c.position||d>c.byteArray.length)throw"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";for(var f=b.elements;c.position<d;){var g=a.readDicomElementImplicit(c,e.untilTag);if(f[g.tag]=g,g.tag===e.untilTag)return}},a}(a),a=function(a){"use strict";function b(a){return"OB"===a||"OW"===a||"SQ"===a||"OF"===a||"UT"===a||"UN"===a?4:2}return void 0===a&&(a={}),a.readDicomElementExplicit=function(c,d,e){if(void 0===c)throw"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";var f={tag:a.readTag(c),vr:c.readFixedString(2)},g=b(f.vr);return 2===g?(f.length=c.readUint16(),f.dataOffset=c.position):(c.seek(2),f.length=c.readUint32(),f.dataOffset=c.position),4294967295===f.length&&(f.hadUndefinedLength=!0),f.tag===e?f:"SQ"===f.vr?(a.readSequenceItemsExplicit(c,f,d),f):4294967295===f.length?"x7fe00010"===f.tag?(a.findEndOfEncapsulatedElement(c,f,d),f):(a.findItemDelimitationItemAndSetElementLength(c,f),f):(c.seek(f.length),f)},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.readDicomElementImplicit=function(b,c){if(void 0===b)throw"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";var d={tag:a.readTag(b),length:b.readUint32(),dataOffset:b.position};if(4294967295===d.length&&(d.hadUndefinedLength=!0),d.tag===c)return d;if(b.position+4<=b.byteArray.length){var e=a.readTag(b);if(b.seek(-4),d.hadUndefinedLength&&"xfffee0dd"===e)return d.length=0,b.seek(8),d;if("xfffee000"===e)return a.readSequenceItemsImplicit(b,d),d}return 4294967295===d.length?(a.findItemDelimitationItemAndSetElementLength(b,d),d):(b.seek(d.length),d)},a}(a),a=function(a){"use strict";function b(b,c){for(var d={};b.position<b.byteArray.length;){var e=a.readDicomElementExplicit(b,c);if(d[e.tag]=e,"xfffee00d"===e.tag)return new a.DataSet(b.byteArrayParser,b.byteArray,d)}return b.warnings.push("eof encountered before finding sequence delimitation item while reading sequence item of undefined length"),new a.DataSet(b.byteArrayParser,b.byteArray,d)}function c(c,d){var e=a.readSequenceItem(c);return 4294967295===e.length?(e.hadUndefinedLength=!0,e.dataSet=b(c,d),e.length=c.position-e.dataOffset):(e.dataSet=new a.DataSet(c.byteArrayParser,c.byteArray,{}),a.parseDicomDataSetExplicit(e.dataSet,c,c.position+e.length)),e}function d(b,d,e){for(;b.position<b.byteArray.length;){var f=a.readTag(b);if(b.seek(-4),"xfffee0dd"===f)return d.length=b.position-d.dataOffset,b.seek(8),d;var g=c(b,e);d.items.push(g)}d.length=b.position-d.dataOffset}function e(a,b,d){for(var e=b.dataOffset+b.length;a.position<e;){var f=c(a,d);b.items.push(f)}}return void 0===a&&(a={}),a.readSequenceItemsExplicit=function(a,b,c){if(void 0===a)throw"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";if(void 0===b)throw"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";b.items=[],4294967295===b.length?d(a,b):e(a,b,c)},a}(a),a=function(a){"use strict";function b(b){for(var c={};b.position<b.byteArray.length;){var d=a.readDicomElementImplicit(b);if(c[d.tag]=d,"xfffee00d"===d.tag)return new a.DataSet(b.byteArrayParser,b.byteArray,c)}return b.warnings.push("eof encountered before finding sequence item delimiter in sequence item of undefined length"),new a.DataSet(b.byteArrayParser,b.byteArray,c)}function c(c){var d=a.readSequenceItem(c);return 4294967295===d.length?(d.hadUndefinedLength=!0,d.dataSet=b(c),d.length=c.position-d.dataOffset):(d.dataSet=new a.DataSet(c.byteArrayParser,c.byteArray,{}),a.parseDicomDataSetImplicit(d.dataSet,c,c.position+d.length)),d}function d(b,d){for(;b.position<b.byteArray.length;){var e=a.readTag(b);if(b.seek(-4),"xfffee0dd"===e)return d.length=b.position-d.dataOffset,b.seek(8),d;var f=c(b);d.items.push(f)}d.length=b.byteArray.length-d.dataOffset}function e(a,b){for(var d=b.dataOffset+b.length;a.position<d;){var e=c(a);b.items.push(e)}}return void 0===a&&(a={}),a.readSequenceItemsImplicit=function(a,b){if(void 0===a)throw"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";if(void 0===b)throw"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";b.items=[],4294967295===b.length?d(a,b):e(a,b)},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.readSequenceItem=function(b){if(void 0===b)throw"dicomParser.readSequenceItem: missing required parameter 'byteStream'";var c={tag:a.readTag(b),length:b.readUint32(),dataOffset:b.position};return c},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.readTag=function(a){if(void 0===a)throw"dicomParser.readTag: missing required parameter 'byteStream'";var b=256*a.readUint16()*256,c=a.readUint16(),d="x"+("00000000"+(b+c).toString(16)).substr(-8);return d},a}(a),a=function(a){"use strict";return void 0===a&&(a={}),a.version="1.1.6",a}(a);return a});
/**
 * Created by admin on 2016/4/8.
 */
// console.log(cornerstone);

//一个窗的播放，主要就是保证各个element直接的顺序是同步的，而不是一个跑风快，另一个还等到起
(function($, cornerstone, cornerstoneTools) {

    'use strict';

    var winArr = [];

    function getWinState(win){
        return _.find(winArr,function(o){
            return o.wid == win.winId&&o.suid == win.suid;
        });
    }
    function removeState(win){
        for(var i=0,len=winArr.length;i<len;i++){
            if(winArr[i].wid == win.winId&&winArr[i].suid == win.suid){
                winArr.splice(i, 1);
            }
        }
    }
    function addWinState(win,data){
        winArr.push({
            wid:win.winId,
            suid:win.suid,
            data:[data]
        });
    }
    function incrementTimePoint(wrap, timePoints){
        var newStackIndex = wrap.stack.currentImageIdIndex + timePoints;
        if(newStackIndex>=wrap.stack.imageIds.length){
            newStackIndex=0;
        }else if(newStackIndex<0){
            newStackIndex=wrap.stack.imageIds.length-1;
        }

        //就没有考虑啥子preventCache
        var loader = cornerstone.loadImage(wrap.stack.imageIds[newStackIndex]);

        var element = wrap.element;
        var viewport = cornerstone.getViewport(element);

        loader.then(function(image) {
            if (wrap.stack.currentImageIdIndex !==newStackIndex) {
                wrap.stack.currentImageIdIndex =newStackIndex;
                cornerstone.displayImage(element, image, viewport);
            }
        }, function(error) {
            console.error(error);
        });
    }
    function play(win,framesPerSecond){
        if (win === undefined) {
            throw 'play: win must not be undefined';
        }
        if (framesPerSecond === undefined) {
            framesPerSecond = 100;
        }

        var playClipToolData = getWinState(win);
        var playClipData;
        if (playClipToolData === undefined || playClipToolData.data.length === 0 ||playClipToolData.data.length!=win.wrappers.length) {
            if(playClipToolData === undefined || playClipToolData.data.length === 0 ){

            }else{
                stop(win);
                removeState(win);
            }
            var wrapperArr = [];
            for(var i=0,len=win.wrappers.length;i<len;i++){
                if(win.wrappers[i].stack.imageIds.length>0){
                    wrapperArr.push(win.wrappers[i]);
                }
            }
            playClipData = {
                intervalId: undefined,
                framesPerSecond: framesPerSecond,
                lastFrameTimeStamp: undefined,
                frameRate: 0,
                wraps:wrapperArr
            };
            addWinState(win, playClipData);
        } else {
            playClipData = playClipToolData.data[0];
            playClipData.framesPerSecond = framesPerSecond;
        }

        // if already playing, do not set a new interval
        if (playClipData.intervalId !== undefined) {
            return;
        }
        playClipData.intervalId = setInterval(function() {
            if (playClipData.framesPerSecond > 0) {
                for(var i=0,len=playClipData.wraps.length;i<len;i++){
                    incrementTimePoint(playClipData.wraps[i], 1);
                }
            } else {
                for(var i=0,len=playClipData.wraps.length;i<len;i++){
                   incrementTimePoint(playClipData.wraps[i], -1);
                }
            }
        }, 1000 / Math.abs(playClipData.framesPerSecond));
    }
    function stop(win){
        var playClipToolData = getWinState(win);//console.log(winArr);
        var playClipData;
        if (playClipToolData === undefined || playClipToolData.data.length === 0) {
            return;
        } else {
            playClipData = playClipToolData.data[0];
        }

        clearInterval(playClipData.intervalId);
        playClipData.intervalId = undefined;
    }

    // module/private exports
    cornerstoneTools.diy = {
        winPlayClip: play,
        winStopClip: stop
    };

})($, cornerstone, cornerstoneTools);

/**
 * Created by admin on 2016/3/28.
 */
function dvLocalLoader(imageId){
    //console.log(dvStruct.imgObjArr);
    var re =  _.find(dvStruct.imgObjArr,function(o){
        return o.imageId == imageId;
    });//console.log('dvLocalLoader:',re);
   
    return re.imagePromise;
}
cornerstone.registerImageLoader('oridcm',dvLocalLoader);

function dvSeriesLoader(imageId){
    var re;
    var arr = imageId.split(':');
    winId = arr[1];
    var win  = _.find(dvStruct.viewer.winArr,function(o){
        return o.winId==winId;
    });
    if(_.isObject(win)){
        var re = _.find(win.imgObjArr,function(o){
            return o.imageId == imageId;
        });
    }


    if(_.isObject(re))return re.imagePromise;
    console.error('dvSeriesLoader:no re no imagePromise');
}
cornerstone.registerImageLoader('series',dvSeriesLoader);
/**
 * Created by admin on 2016/3/31.
 */
(function (cornerstoneTools) {

    "use strict";

    function metaDataProvider(type, imageId)
    {
        //image类型不会走里面吧...
        if(type === 'imagePlane') {
            //console.log(imageId);
            //console.log(oid,suid);
            var info = dvStruct.viewer.findOriInfoByIds(imageId);
            if(!_.isUndefined(info)){
                var iPP =  info.ImageInfo.ImagePositionPatient.val;
                var spacing = info.ImageInfo.PixelSpacing.val;//Physical distance in the patient between the center of each pixel, specified by a numericpair - adjacent row spacing (delimiter)adjacent column spacing in mm. See 10.X.1.1.
                var iOP = info.ImageInfo.ImageOrientationPatient.val;//The direction cosines of the first row and the first column with respect to the patient. See Section C.7.6.2.1.1 for further explanation.
                if(!iPP||!spacing)return undefined;
                var iPPvals = iPP.split("\\");//都是斜杠吧唔
                var iOPvals = iOP.split("\\");
                var spacing = spacing.split("\\");//if(!spacing[1])spacing[1]=spacing[0];//后面这句无脑加的
                var re = {
                    frameOfReferenceUID: info.UIDS.FrameOfReferenceUID.val,
                    rows: Number(info.ImageInfo.Rows.val),
                    columns:  Number(info.ImageInfo.Columns.val),
                    rowCosines: new cornerstoneMath.Vector3(parseFloat(iOPvals[0]),parseFloat(iOPvals[1]),parseFloat(iOPvals[2])),
                    columnCosines: new cornerstoneMath.Vector3(parseFloat(iOPvals[3]),parseFloat(iOPvals[4]),parseFloat(iOPvals[5])),
                    imagePositionPatient: new cornerstoneMath.Vector3(parseFloat(iPPvals[0]),parseFloat(iPPvals[1]),parseFloat(iPPvals[2])),
                    columnPixelSpacing: parseFloat(spacing[1]),
                    rowPixelSpacing: parseFloat(spacing[0])
                };
                //console.log(re);
                return re;
            }
        }
        return undefined;
    }

    cornerstoneTools.metaData.addProvider(metaDataProvider);

}(cornerstoneTools));
/**
 * Created by admin on 2016/3/23.
 */
//私人定制公共事件控制器
var commEventHandler = {
    //事件监听集合
    listeners : {},
    //事件发射器
    fireEvent:function  (event)
    {//console.log(this.listeners);
        if ( typeof this.listeners[event.type] === "undefined" ) {
            return;
        }
        for ( var i = 0; i < this.listeners[event.type].length; ++i )
        {
            this.listeners[event.type][i](event);
        }
    },
    //事件注册
    addEventListener : function (type, listener)
    {
        if ( typeof this.listeners[type] === "undefined" ) {
            this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
    },
    //事件取消
    removeEventListener : function (type, listener)
    {
        if( typeof this.listeners[type] === "undefined" ) {
            return;
        }
        for ( var i = 0; i < this.listeners[type].length; ++i )
        {
            if ( this.listeners[type][i] === listener ) {
                this.listeners[type].splice(i,1);
            }
        }
    }
}

//错误处理
function handleError(error)
{
    // alert window
    if ( error.name && error.message) {
        alert(error.name+": "+error.message+".");
    }
    else {
        alert("Error: "+error+".");
    }
    // log
    if ( error.stack ) {
        console.error(error.stack);
    }
}

function guid(len, prefix) {
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = [], i;
    var prefixStr = prefix||'';
    radix = chars.length;
    if (len) {
        // Compact form
        for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
        // rfc4122, version 4 form
        var r;
        // rfc4122 requires these characters
        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
        uuid[14] = '4';
        // Fill in random data.  At i==19 set the high bits of clock sequence as
        // per rfc4122, sec. 4.1.5
        for (i = 0; i < 36; i++) {
            if (!uuid[i]) {
                r = 0 | Math.random()*16;
                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
            }
        }
    }
    //附加时间撮
    var d = new Date();
    var utcId = Date.UTC(d.getFullYear()
        , d.getMonth()
        , d.getDate()
        , d.getHours()
        , d.getMinutes()
        , d.getSeconds()
        , d.getMilliseconds());
    return prefixStr+''+utcId+uuid.join('');
}

//
function createNewImageObject(dataSet,type){
    var prefix = type||'oridcm';
    //这段从wado的dicomfile中参考取得
    var imageId =guid(8,prefix+':') ;
    //create a deferred object
    var deferred = $.Deferred();
    try{
        var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId);//console.log(imagePromise);
    }catch (e){
        console.error(e);
    }

    return {
        imageId:imageId,
        imagePromise:imagePromise
    };
}


//jquery获取参数
(function($) {
    $.extend({
        urlGet:function()
        {
            var aQuery = window.location.href.split("?");  //取得Get参数
            var aGET = new Array();
            if(aQuery.length > 1)
            {
                var aBuf = aQuery[1].split("&");
                for(var i=0, iLoop = aBuf.length; i<iLoop; i++)
                {
                    var aTmp = aBuf[i].split("=");  //分离key与Value
                    aGET[aTmp[0]] = aTmp[1];
                }
            }
            return aGET;
        }
    })
})(jQuery);

//a比b的字典序高，则是1，反之返回0
function compareBySort(a,b){
    var arr = [a,b];
    arr.sort();
    if(arr[0]==b)return 1;
    return 0;
}
function compareByNo(a,b){
   if(parseInt(a)<parseInt(b))return 1;
    return 0
}
//分段比较
function firstIsBigger(a,b){
    var idArr = a.split(".");
    var idArr2 = b.split(".");
    for(var i=0;i<idArr.length;i++){
        if(i>=idArr2.length)return true;
        if(parseInt(idArr[i])<parseInt(idArr2[i])){
            return false;
        }else if(parseInt(idArr[i])>parseInt(idArr2[i])){
            return true;
        }
    }
    return true;
}
/**
 * Created by admin on 2016/6/13.
 */
if(!dvStruct){
    var dvStruct = {};
}
dvStruct.vo = {};
dvStruct.vo.getPositionById = function(imageId){
    var sourceImagePlane = cornerstoneTools.metaData.get('imagePlane', imageId);
    return sourceImagePlane.imagePositionPatient;
};
dvStruct.vo.calDistanceSquared = function(vectors,offsets){
    var aVec = vectors[0];
    var bVec = vectors[1];
    //!![]为真哦，这里扫盲下
    if(!!offsets&&offsets.length>1){
        var aofs = offsets[0],bofs = offsets[1];
        aVec.x -= aofs.x;
        aVec.y -= aofs.y;
        aVec.z -= aofs.z;
        bVec.x -= bofs.x;
        bVec.y -= bofs.y;
        bVec.z -= bofs.z;
    }
    var dx = aVec.x - bVec.x;
    var dy = aVec.y - bVec.y;
    var dz = aVec.z - bVec.z;
    //只是用于比大小的话没必要再开方了
    return dx * dx + dy * dy + dz * dz;
};

dvStruct.vo.farsideCal = function(va,vb){
    var move = 500000;//全部移动到一侧 再比较
    return ((va.x+move)*(va.x+move) + (va.y+move)*(va.y+move) + (va.z+move)*(va.z+move))<((vb.x+move)*(vb.x+move) + (vb.y+move)*(vb.y+move) + (vb.z+move)*(vb.z+move))?vb:va;
};
dvStruct.vo.notSame = function(va,vb){
    return (va.x==vb.x&&va.y==vb.y&&va.z==vb.z)?false:true;
};

//---------------------------------------------------
//offset有时因为图少的原因可能有问题   而且。。。。可能有横图 竖图 同时在。。。。总之offset不是这么定的。至于不能联动不同医院，日期，设备不同的，只能抱歉了

//-------------syn-----------------------------------
dvStruct.synposition = {};
dvStruct.synposition.enable = false;
dvStruct.synposition.findAndSyn=function(imageId,wrapper){
    function otherPaging(win,nowPage){
        //其它的
        for(var k=1;k<win.col*win.row;k++){
            var wrapper = win.wrappers[k];
            var stack = wrapper.stack;
            var len = stack.imageIds.length;
            if(len>0){
                stack.currentImageIdIndex=nowPage+k;
                if(stack.currentImageIdIndex<len){
                }else{
                    stack.currentImageIdIndex-=len;
                }
                var imageId = stack.imageIds[stack.currentImageIdIndex];
                cornerstone.loadImage(imageId).then(function(image){
                    cornerstone.displayImage(wrapper.element, image);
                });
            }
        }
    }
    var suid = wrapper.suid;
    var p1 = cornerstoneTools.metaData.get('imagePlane', imageId);
    var ind = wrapper.stack.currentImageIdIndex;
    var sourceImagePosition = p1.imagePositionPatient;
    //offset矫正
    var ss = dvStruct.findSeries(suid);
    // console.log(ss.offset,imageId);
    //sourceImagePosition.x-=ss.offset.x;
    //sourceImagePosition.y-=ss.offset.y;
    //sourceImagePosition.z-=ss.offset.z;
    if(_.isUndefined(p1))return;
    //叉乘求法向量
    var normal1 = p1.rowCosines.clone().crossVectors(p1.rowCosines,p1.columnCosines);
    normal1.normalize();
    //遍历各个窗
    for(var i=0;i<dvStruct.viewer.winArr.length;i++){
        var win = dvStruct.viewer.winArr[i];
        var wrap = win.wrappers[0];
        if(!!!wrap.suid)continue;
        //排除自己
        //console.log($(wrap.element).parents('.seriesWindow:first').attr('id'),$(wrapper.element).parents('.seriesWindow:first').attr('id'));
        if($(wrap.element).parents('.seriesWindow:first').attr('id')==$(wrapper.element).parents('.seriesWindow:first').attr('id')){
            continue;
        }
        //相同序列
        if(dvStruct.viewer.winArr[i].wrappers[0].suid == suid){
            wrap.stack.currentImageIdIndex =ind;
            cornerstone.loadImage(imageId).then(function(image){
                cornerstone.displayImage(wrap.element, image);
            });
            continue;
        }

        //计算最接近的面
        var minDistance = Number.MAX_VALUE;
        var newImageIdIndex = -1;
        var ts =  dvStruct.findSeries(wrap.suid);
        $.each(wrap.stack.imageIds, function(index, imageId) {
            //检测平行
            var imageId2 = wrap.stack.imageIds[index];
            var p2 = cornerstoneTools.metaData.get('imagePlane', imageId2);
            if(_.isUndefined(p2))return true;
            var normal2 = p2.rowCosines.clone().crossVectors(p2.rowCosines,p2.columnCosines);
            normal2.normalize();
            if(normal1.clone().cross(normal2).length()<1e-3){
                //算作平行
                var imagePlane = cornerstoneTools.metaData.get('imagePlane', imageId);
                var imagePosition = imagePlane.imagePositionPatient;
                //offset矫正
                //imagePosition.x-=ts.offset.x;
                //imagePosition.y-=ts.offset.y;
                //imagePosition.z-=ts.offset.z;
                //距离
                // console.log(sourceImagePosition,imagePosition);
                var distance = dvStruct.vo.calDistanceSquared([sourceImagePosition,imagePosition]);
                if (distance < minDistance) {
                    minDistance = distance;
                    newImageIdIndex = index;
                }
            }
        });
        //console.log(minDistance,newImageIdIndex,wrap.element,wrap.stack.currentImageIdIndex);
        //就是当前平面
        if (newImageIdIndex === wrap.stack.currentImageIdIndex) {
            return;
        }
        if (newImageIdIndex !== -1) {
            wrap.stack.currentImageIdIndex = newImageIdIndex;
            cornerstone.loadImage(wrap.stack.imageIds[newImageIdIndex]).then(function(image) {
                cornerstone.displayImage(wrap.element, image);
            }, function(error) {
               console.error(error);
            });
            otherPaging(win,newImageIdIndex);
        }
    }
}
/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */
"use strict";function info(a){PDFJS.verbosity>=PDFJS.VERBOSITY_LEVELS.infos&&console.log("Info: "+a)}function warn(a){PDFJS.verbosity>=PDFJS.VERBOSITY_LEVELS.warnings&&console.log("Warning: "+a)}function error(a){if(arguments.length>1){var b=["Error:"];b.push.apply(b,arguments),console.log.apply(console,b),a=[].join.call(arguments," ")}else console.log("Error: "+a);throw console.log(backtrace()),UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown),new Error(a)}function backtrace(){try{throw new Error}catch(a){return a.stack?a.stack.split("\n").slice(2).join("\n"):""}}function assert(a,b){a||error(b)}function combineUrl(a,b){if(!b)return a;if(/^[a-z][a-z0-9+\-.]*:/i.test(b))return b;var c;if("/"===b.charAt(0))return c=a.indexOf("://"),"/"===b.charAt(1)?++c:c=a.indexOf("/",c+3),a.substring(0,c)+b;var d=a.length;c=a.lastIndexOf("#"),d=c>=0?c:d,c=a.lastIndexOf("?",d),d=c>=0?c:d;var e=a.lastIndexOf("/",d);return a.substring(0,e+1)+b}function isValidUrl(a,b){if(!a)return!1;var c=/^[a-z][a-z0-9+\-.]*(?=:)/i.exec(a);if(!c)return b;switch(c=c[0].toLowerCase()){case"http":case"https":case"ftp":case"mailto":case"tel":return!0;default:return!1}}function shadow(a,b,c){return Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!1}),c}function bytesToString(a){assert(null!==a&&"object"==typeof a&&void 0!==a.length,"Invalid argument for bytesToString");var b=a.length,c=8192;if(c>b)return String.fromCharCode.apply(null,a);for(var d=[],e=0;b>e;e+=c){var f=Math.min(e+c,b),g=a.subarray(e,f);d.push(String.fromCharCode.apply(null,g))}return d.join("")}function stringToBytes(a){assert("string"==typeof a,"Invalid argument for stringToBytes");for(var b=a.length,c=new Uint8Array(b),d=0;b>d;++d)c[d]=255&a.charCodeAt(d);return c}function string32(a){return String.fromCharCode(a>>24&255,a>>16&255,a>>8&255,255&a)}function log2(a){for(var b=1,c=0;a>b;)b<<=1,c++;return c}function readInt8(a,b){return a[b]<<24>>24}function readUint16(a,b){return a[b]<<8|a[b+1]}function readUint32(a,b){return(a[b]<<24|a[b+1]<<16|a[b+2]<<8|a[b+3])>>>0}function isLittleEndian(){var a=new Uint8Array(2);a[0]=1;var b=new Uint16Array(a.buffer);return 1===b[0]}function hasCanvasTypedArrays(){var a=document.createElement("canvas");a.width=a.height=1;var b=a.getContext("2d"),c=b.createImageData(1,1);return"undefined"!=typeof c.data.buffer}function stringToPDFString(a){var b,c=a.length,d=[];if("þ"===a[0]&&"ÿ"===a[1])for(b=2;c>b;b+=2)d.push(String.fromCharCode(a.charCodeAt(b)<<8|a.charCodeAt(b+1)));else for(b=0;c>b;++b){var e=PDFStringTranslateTable[a.charCodeAt(b)];d.push(e?String.fromCharCode(e):a.charAt(b))}return d.join("")}function stringToUTF8String(a){return decodeURIComponent(escape(a))}function isEmptyObj(a){for(var b in a)return!1;return!0}function isBool(a){return"boolean"==typeof a}function isInt(a){return"number"==typeof a&&(0|a)===a}function isNum(a){return"number"==typeof a}function isString(a){return"string"==typeof a}function isNull(a){return null===a}function isName(a){return a instanceof Name}function isCmd(a,b){return a instanceof Cmd&&(void 0===b||a.cmd===b)}function isDict(a,b){if(!(a instanceof Dict))return!1;if(!b)return!0;var c=a.get("Type");return isName(c)&&c.name===b}function isArray(a){return a instanceof Array}function isStream(a){return"object"==typeof a&&null!==a&&void 0!==a.getBytes}function isArrayBuffer(a){return"object"==typeof a&&null!==a&&void 0!==a.byteLength}function isRef(a){return a instanceof Ref}function createPromiseCapability(){var a={};return a.promise=new Promise(function(b,c){a.resolve=b,a.reject=c}),a}function MessageHandler(a,b){this.name=a,this.comObj=b,this.callbackIndex=1,this.postMessageTransfers=!0;var c=this.callbacksCapabilities={},d=this.actionHandler={};d.console_log=[function(a){console.log.apply(console,a)}],d.console_error=[function(a){console.error.apply(console,a)}],d._unsupported_feature=[function(a){UnsupportedManager.notify(a)}],b.onmessage=function(a){var e=a.data;if(e.isReply){var f=e.callbackId;if(e.callbackId in c){var g=c[f];delete c[f],"error"in e?g.reject(e.error):g.resolve(e.data)}else error("Cannot resolve callback "+f)}else if(e.action in d){var h=d[e.action];e.callbackId?Promise.resolve().then(function(){return h[0].call(h[1],e.data)}).then(function(a){b.postMessage({isReply:!0,callbackId:e.callbackId,data:a})},function(a){b.postMessage({isReply:!0,callbackId:e.callbackId,error:a})}):h[0].call(h[1],e.data)}else error("Unknown action from worker: "+e.action)}}function loadJpegStream(a,b,c){var d=new Image;d.onload=function(){c.resolve(a,d)},d.onerror=function(){c.resolve(a,null),warn("Error during JPEG image loading")},d.src=b}var JpxImage=function(){function a(){this.failOnCorruptedImage=!1}function b(a,b){a.x0=Math.ceil(b.XOsiz/a.XRsiz),a.x1=Math.ceil(b.Xsiz/a.XRsiz),a.y0=Math.ceil(b.YOsiz/a.YRsiz),a.y1=Math.ceil(b.Ysiz/a.YRsiz),a.width=a.x1-a.x0,a.height=a.y1-a.y0}function c(a,b){for(var c,d=a.SIZ,e=[],f=Math.ceil((d.Xsiz-d.XTOsiz)/d.XTsiz),g=Math.ceil((d.Ysiz-d.YTOsiz)/d.YTsiz),h=0;g>h;h++)for(var i=0;f>i;i++)c={},c.tx0=Math.max(d.XTOsiz+i*d.XTsiz,d.XOsiz),c.ty0=Math.max(d.YTOsiz+h*d.YTsiz,d.YOsiz),c.tx1=Math.min(d.XTOsiz+(i+1)*d.XTsiz,d.Xsiz),c.ty1=Math.min(d.YTOsiz+(h+1)*d.YTsiz,d.Ysiz),c.width=c.tx1-c.tx0,c.height=c.ty1-c.ty0,c.components=[],e.push(c);a.tiles=e;for(var j=d.Csiz,k=0,l=j;l>k;k++)for(var m=b[k],n=0,o=e.length;o>n;n++){var p={};c=e[n],p.tcx0=Math.ceil(c.tx0/m.XRsiz),p.tcy0=Math.ceil(c.ty0/m.YRsiz),p.tcx1=Math.ceil(c.tx1/m.XRsiz),p.tcy1=Math.ceil(c.ty1/m.YRsiz),p.width=p.tcx1-p.tcx0,p.height=p.tcy1-p.tcy0,c.components[k]=p}}function d(a,b,c){var d=b.codingStyleParameters,e={};return d.entropyCoderWithCustomPrecincts?(e.PPx=d.precinctsSizes[c].PPx,e.PPy=d.precinctsSizes[c].PPy):(e.PPx=15,e.PPy=15),e.xcb_=c>0?Math.min(d.xcb,e.PPx-1):Math.min(d.xcb,e.PPx),e.ycb_=c>0?Math.min(d.ycb,e.PPy-1):Math.min(d.ycb,e.PPy),e}function e(a,b,c){var d=1<<c.PPx,e=1<<c.PPy,f=0===b.resLevel,g=1<<c.PPx+(f?0:-1),h=1<<c.PPy+(f?0:-1),i=b.trx1>b.trx0?Math.ceil(b.trx1/d)-Math.floor(b.trx0/d):0,j=b.try1>b.try0?Math.ceil(b.try1/e)-Math.floor(b.try0/e):0,k=i*j;b.precinctParameters={precinctWidth:d,precinctHeight:e,numprecinctswide:i,numprecinctshigh:j,numprecincts:k,precinctWidthInSubband:g,precinctHeightInSubband:h}}function f(a,b,c){var d,e,f,g,h=c.xcb_,i=c.ycb_,j=1<<h,k=1<<i,l=b.tbx0>>h,m=b.tby0>>i,n=b.tbx1+j-1>>h,o=b.tby1+k-1>>i,p=b.resolution.precinctParameters,q=[],r=[];for(e=m;o>e;e++)for(d=l;n>d;d++){f={cbx:d,cby:e,tbx0:j*d,tby0:k*e,tbx1:j*(d+1),tby1:k*(e+1)},f.tbx0_=Math.max(b.tbx0,f.tbx0),f.tby0_=Math.max(b.tby0,f.tby0),f.tbx1_=Math.min(b.tbx1,f.tbx1),f.tby1_=Math.min(b.tby1,f.tby1);var s=Math.floor((f.tbx0_-b.tbx0)/p.precinctWidthInSubband),t=Math.floor((f.tby0_-b.tby0)/p.precinctHeightInSubband);if(g=s+t*p.numprecinctswide,f.precinctNumber=g,f.subbandType=b.type,f.Lblock=3,!(f.tbx1_<=f.tbx0_||f.tby1_<=f.tby0_)){q.push(f);var u=r[g];void 0!==u?(d<u.cbxMin?u.cbxMin=d:d>u.cbxMax&&(u.cbxMax=d),e<u.cbyMin?u.cbxMin=e:e>u.cbyMax&&(u.cbyMax=e)):r[g]=u={cbxMin:d,cbyMin:e,cbxMax:d,cbyMax:e},f.precinct=u}}b.codeblockParameters={codeblockWidth:h,codeblockHeight:i,numcodeblockwide:n-l+1,numcodeblockhigh:o-m+1},b.codeblocks=q,b.precincts=r}function g(a,b,c){for(var d=[],e=a.subbands,f=0,g=e.length;g>f;f++)for(var h=e[f],i=h.codeblocks,j=0,k=i.length;k>j;j++){var l=i[j];l.precinctNumber===b&&d.push(l)}return{layerNumber:c,codeblocks:d}}function h(a){for(var b=a.SIZ,c=a.currentTile.index,d=a.tiles[c],e=d.codingStyleDefaultParameters.layersCount,f=b.Csiz,h=0,i=0;f>i;i++)h=Math.max(h,d.components[i].codingStyleParameters.decompositionLevelsCount);var j=0,k=0,l=0,m=0;this.nextPacket=function(){for(;e>j;j++){for(;h>=k;k++){for(;f>l;l++){var a=d.components[l];if(!(k>a.codingStyleParameters.decompositionLevelsCount)){for(var b=a.resolutions[k],c=b.precinctParameters.numprecincts;c>m;){var i=g(b,m,j);return m++,i}m=0}}l=0}k=0}}}function i(a){for(var b=a.SIZ,c=a.currentTile.index,d=a.tiles[c],e=d.codingStyleDefaultParameters.layersCount,f=b.Csiz,h=0,i=0;f>i;i++)h=Math.max(h,d.components[i].codingStyleParameters.decompositionLevelsCount);var j=0,k=0,l=0,m=0;this.nextPacket=function(){for(;h>=j;j++){for(;e>k;k++){for(;f>l;l++){var a=d.components[l];if(!(j>a.codingStyleParameters.decompositionLevelsCount)){for(var b=a.resolutions[j],c=b.precinctParameters.numprecincts;c>m;){var i=g(b,m,k);return m++,i}m=0}}l=0}k=0}}}function j(a){var b,c,d,e,f=a.SIZ,h=a.currentTile.index,i=a.tiles[h],j=i.codingStyleDefaultParameters.layersCount,k=f.Csiz,l=0;for(d=0;k>d;d++){var m=i.components[d];l=Math.max(l,m.codingStyleParameters.decompositionLevelsCount)}var n=new Int32Array(l+1);for(c=0;l>=c;++c){var o=0;for(d=0;k>d;++d){var p=i.components[d].resolutions;c<p.length&&(o=Math.max(o,p[c].precinctParameters.numprecincts))}n[c]=o}b=0,c=0,d=0,e=0,this.nextPacket=function(){for(;l>=c;c++){for(;e<n[c];e++){for(;k>d;d++){var a=i.components[d];if(!(c>a.codingStyleParameters.decompositionLevelsCount)){var f=a.resolutions[c],h=f.precinctParameters.numprecincts;if(!(e>=h)){for(;j>b;){var m=g(f,e,b);return b++,m}b=0}}}d=0}e=0}}}function k(a){var b=a.SIZ,c=a.currentTile.index,d=a.tiles[c],e=d.codingStyleDefaultParameters.layersCount,f=b.Csiz,h=n(d),i=h,j=0,k=0,l=0,o=0,p=0;this.nextPacket=function(){for(;p<i.maxNumHigh;p++){for(;o<i.maxNumWide;o++){for(;f>l;l++){for(var a=d.components[l],b=a.codingStyleParameters.decompositionLevelsCount;b>=k;k++){var c=a.resolutions[k],n=h.components[l].resolutions[k],q=m(o,p,n,i,c);if(null!==q){for(;e>j;){var r=g(c,q,j);return j++,r}j=0}}k=0}l=0}o=0}}}function l(a){var b=a.SIZ,c=a.currentTile.index,d=a.tiles[c],e=d.codingStyleDefaultParameters.layersCount,f=b.Csiz,h=n(d),i=0,j=0,k=0,l=0,o=0;this.nextPacket=function(){for(;f>k;++k){for(var a=d.components[k],b=h.components[k],c=a.codingStyleParameters.decompositionLevelsCount;o<b.maxNumHigh;o++){for(;l<b.maxNumWide;l++){for(;c>=j;j++){var n=a.resolutions[j],p=b.resolutions[j],q=m(l,o,p,b,n);if(null!==q){for(;e>i;){var r=g(n,q,i);return i++,r}i=0}}j=0}l=0}o=0}}}function m(a,b,c,d,e){var f=a*d.minWidth,g=b*d.minHeight;if(f%c.width!==0||g%c.height!==0)return null;var h=g/c.width*e.precinctParameters.numprecinctswide;return f/c.height+h}function n(a){for(var b=a.components.length,c=Number.MAX_VALUE,d=Number.MAX_VALUE,e=0,f=0,g=new Array(b),h=0;b>h;h++){for(var i=a.components[h],j=i.codingStyleParameters.decompositionLevelsCount,k=new Array(j+1),l=Number.MAX_VALUE,m=Number.MAX_VALUE,n=0,o=0,p=1,q=j;q>=0;--q){var r=i.resolutions[q],s=p*r.precinctParameters.precinctWidth,t=p*r.precinctParameters.precinctHeight;l=Math.min(l,s),m=Math.min(m,t),n=Math.max(n,r.precinctParameters.numprecinctswide),o=Math.max(o,r.precinctParameters.numprecinctshigh),k[q]={width:s,height:t},p<<=1}c=Math.min(c,l),d=Math.min(d,m),e=Math.max(e,n),f=Math.max(f,o),g[h]={resolutions:k,minWidth:l,minHeight:m,maxNumWide:n,maxNumHigh:o}}return{components:g,minWidth:c,minHeight:d,maxNumWide:e,maxNumHigh:f}}function o(a){for(var b=a.SIZ,c=a.currentTile.index,g=a.tiles[c],m=b.Csiz,n=0;m>n;n++){for(var o=g.components[n],p=o.codingStyleParameters.decompositionLevelsCount,q=[],r=[],s=0;p>=s;s++){var t=d(a,o,s),u={},v=1<<p-s;u.trx0=Math.ceil(o.tcx0/v),u.try0=Math.ceil(o.tcy0/v),u.trx1=Math.ceil(o.tcx1/v),u.try1=Math.ceil(o.tcy1/v),u.resLevel=s,e(a,u,t),q.push(u);var w;if(0===s)w={},w.type="LL",w.tbx0=Math.ceil(o.tcx0/v),w.tby0=Math.ceil(o.tcy0/v),w.tbx1=Math.ceil(o.tcx1/v),w.tby1=Math.ceil(o.tcy1/v),w.resolution=u,f(a,w,t),r.push(w),u.subbands=[w];else{var x=1<<p-s+1,y=[];w={},w.type="HL",w.tbx0=Math.ceil(o.tcx0/x-.5),w.tby0=Math.ceil(o.tcy0/x),w.tbx1=Math.ceil(o.tcx1/x-.5),w.tby1=Math.ceil(o.tcy1/x),w.resolution=u,f(a,w,t),r.push(w),y.push(w),w={},w.type="LH",w.tbx0=Math.ceil(o.tcx0/x),w.tby0=Math.ceil(o.tcy0/x-.5),w.tbx1=Math.ceil(o.tcx1/x),w.tby1=Math.ceil(o.tcy1/x-.5),w.resolution=u,f(a,w,t),r.push(w),y.push(w),w={},w.type="HH",w.tbx0=Math.ceil(o.tcx0/x-.5),w.tby0=Math.ceil(o.tcy0/x-.5),w.tbx1=Math.ceil(o.tcx1/x-.5),w.tby1=Math.ceil(o.tcy1/x-.5),w.resolution=u,f(a,w,t),r.push(w),y.push(w),u.subbands=y}}o.resolutions=q,o.subbands=r}var z=g.codingStyleDefaultParameters.progressionOrder;switch(z){case 0:g.packetsIterator=new h(a);break;case 1:g.packetsIterator=new i(a);break;case 2:g.packetsIterator=new j(a);break;case 3:g.packetsIterator=new k(a);break;case 4:g.packetsIterator=new l(a);break;default:throw new Error("JPX Error: Unsupported progression order "+z)}}function p(a,b,c,d){function e(a){for(;a>l;){if(c+k>=b.length)throw new Error("Unexpected EOF");var d=b[c+k];k++,m?(j=j<<7|d,l+=7,m=!1):(j=j<<8|d,l+=8),255===d&&(m=!0)}return l-=a,j>>>l&(1<<a)-1}function f(a){return 255===b[c+k-1]&&b[c+k]===a?(g(1),!0):255===b[c+k]&&b[c+k+1]===a?(g(2),!0):!1}function g(a){k+=a}function h(){l=0,m&&(k++,m=!1)}function i(){if(0===e(1))return 1;if(0===e(1))return 2;var a=e(2);return 3>a?a+3:(a=e(5),31>a?a+6:(a=e(7),a+37))}for(var j,k=0,l=0,m=!1,n=a.currentTile.index,o=a.tiles[n],p=a.COD.sopMarkerUsed,q=a.COD.ephMarkerUsed,r=o.packetsIterator;d>k;)try{h(),p&&f(145)&&g(4);var s=r.nextPacket();if(void 0===s)return;if(!e(1))continue;for(var t,u=s.layerNumber,x=[],y=0,z=s.codeblocks.length;z>y;y++){t=s.codeblocks[y];var A,B=t.precinct,C=t.cbx-B.cbxMin,D=t.cby-B.cbyMin,E=!1,F=!1;if(void 0!==t.included)E=!!e(1);else{B=t.precinct;var G,H;if(void 0!==B.inclusionTree)G=B.inclusionTree;else{var I=B.cbxMax-B.cbxMin+1,J=B.cbyMax-B.cbyMin+1;G=new w(I,J),H=new v(I,J),B.inclusionTree=G,B.zeroBitPlanesTree=H}for(G.reset(C,D,u);;){if(k>=b.length)return;if(G.isAboveThreshold())break;if(G.isKnown())G.nextLevel();else if(e(1)){if(G.setKnown(),G.isLeaf()){t.included=!0,E=F=!0;break}G.nextLevel()}else G.incrementValue()}}if(E){if(F){for(H=B.zeroBitPlanesTree,H.reset(C,D);;){if(k>=b.length)return;if(e(1)){if(A=!H.nextLevel())break}else H.incrementValue()}t.zeroBitPlanes=H.value}for(var K=i();e(1);)t.Lblock++;var L=log2(K),M=(1<<L>K?L-1:L)+t.Lblock,N=e(M);x.push({codeblock:t,codingpasses:K,dataLength:N})}}for(h(),q&&f(146);x.length>0;){var O=x.shift();t=O.codeblock,void 0===t.data&&(t.data=[]),t.data.push({data:b,start:c+k,end:c+k+O.dataLength,codingpasses:O.codingpasses}),k+=O.dataLength}}catch(P){return}return k}function q(a,b,c,d,e,f,g,h){for(var i=d.tbx0,j=d.tby0,k=d.tbx1-d.tbx0,l=d.codeblocks,m="H"===d.type.charAt(0)?1:0,n="H"===d.type.charAt(1)?b:0,o=0,p=l.length;p>o;++o){var q=l[o],r=q.tbx1_-q.tbx0_,s=q.tby1_-q.tby0_;if(0!==r&&0!==s&&void 0!==q.data){var t,u;t=new x(r,s,q.subbandType,q.zeroBitPlanes,f),u=2;var v,w,y,z=q.data,A=0,B=0;for(v=0,w=z.length;w>v;v++)y=z[v],A+=y.end-y.start,B+=y.codingpasses;var C=new Int16Array(A),D=0;for(v=0,w=z.length;w>v;v++){y=z[v];var E=y.data.subarray(y.start,y.end);C.set(E,D),D+=E.length}var F=new ArithmeticDecoder(C,0,A);for(t.setDecoder(F),v=0;B>v;v++){switch(u){case 0:t.runSignificancePropogationPass();break;case 1:t.runMagnitudeRefinementPass();break;case 2:t.runCleanupPass(),h&&t.checkSegmentationSymbol()}u=(u+1)%3}var G,H,I,J=q.tbx0_-i+(q.tby0_-j)*k,K=t.coefficentsSign,L=t.coefficentsMagnitude,M=t.bitsDecoded,N=g?0:.5;D=0;var O="LL"!==d.type;for(v=0;s>v;v++){var P=J/k|0,Q=2*P*(b-k)+m+n;for(G=0;r>G;G++){if(H=L[D],0!==H){H=(H+N)*e,0!==K[D]&&(H=-H),I=M[D];var R=O?Q+(J<<1):J;g&&I>=f?a[R]=H:a[R]=H*(1<<f-I)}J++,D++}J+=k-r}}}}function r(a,b,c){for(var d=b.components[c],e=d.codingStyleParameters,f=d.quantizationParameters,g=e.decompositionLevelsCount,h=f.SPqcds,i=f.scalarExpounded,j=f.guardBits,k=e.segmentationSymbolUsed,l=a.components[c].precision,m=e.reversibleTransformation,n=m?new A:new z,o=[],p=0,r=0;g>=r;r++){for(var s=d.resolutions[r],t=s.trx1-s.trx0,v=s.try1-s.try0,w=new Float32Array(t*v),x=0,y=s.subbands.length;y>x;x++){var B,C;i?(B=h[p].mu,C=h[p].epsilon,p++):(B=h[0].mu,C=h[0].epsilon+(r>0?1-r:0));var D=s.subbands[x],E=u[D.type],F=m?1:Math.pow(2,l+E-C)*(1+B/2048),G=j+C-1;q(w,t,v,D,F,G,m,k)}o.push({width:t,height:v,items:w})}var H=n.calculate(o,d.tcx0,d.tcy0);return{left:d.tcx0,top:d.tcy0,width:H.width,height:H.height,items:H.items}}function s(a){for(var b=a.SIZ,c=a.components,d=b.Csiz,e=[],f=0,g=a.tiles.length;g>f;f++){var h,i=a.tiles[f],j=[];for(h=0;d>h;h++)j[h]=r(a,i,h);var k=j[0],l=c[0].isSigned;if(l)var m=new Int16Array(k.items.length*d);else var m=new Uint16Array(k.items.length*d);var n,o,p,q,s,t,u,v,w,x,y,z,A,B,C,D={left:k.left,top:k.top,width:k.width,height:k.height,items:m},E=0;if(i.codingStyleDefaultParameters.multipleComponentTransform){var F=4===d,G=j[0].items,H=j[1].items,I=j[2].items,J=F?j[3].items:null;n=c[0].precision-8,o=(128<<n)+.5,p=255*(1<<n),s=.5*p,q=-s;var K=i.components[0],L=d-3;if(u=G.length,K.codingStyleParameters.reversibleTransformation)for(t=0;u>t;t++,E+=L)v=G[t]+o,w=H[t],x=I[t],z=v-(x+w>>2),y=z+x,A=z+w,m[E++]=0>=y?0:y>=p?255:y>>n,m[E++]=0>=z?0:z>=p?255:z>>n,m[E++]=0>=A?0:A>=p?255:A>>n;else for(t=0;u>t;t++,E+=L)v=G[t]+o,w=H[t],x=I[t],y=v+1.402*x,z=v-.34413*w-.71414*x,A=v+1.772*w,m[E++]=0>=y?0:y>=p?255:y>>n,m[E++]=0>=z?0:z>=p?255:z>>n,m[E++]=0>=A?0:A>=p?255:A>>n;if(F)for(t=0,E=3;u>t;t++,E+=4)B=J[t],m[E]=q>=B?0:B>=s?255:B+o>>n}else for(h=0;d>h;h++)if(8===c[h].precision){var M=j[h].items;for(n=c[h].precision-8,o=(128<<n)+.5,p=127.5*(1<<n),q=-p,E=h,t=0,u=M.length;u>t;t++)C=M[t],m[E]=q>=C?0:C>=p?255:C+o>>n,E+=d}else{var l=c[h].isSigned,M=j[h].items;if(l)for(E=h,t=0,u=M.length;u>t;t++)m[E]=M[t],E+=d;else{n=c[h].precision-8,o=(128<<n)+.5;var N=Math.pow(2,c[h].precision)-1;for(E=h,t=0,u=M.length;u>t;t++)C=M[t],m[E]=Math.max(Math.min(C+o,N),0),E+=d}}e.push(D)}return e}function t(a,b){for(var c=a.SIZ,d=c.Csiz,e=a.tiles[b],f=0;d>f;f++){var g=e.components[f],h=void 0!==a.currentTile.QCC[f]?a.currentTile.QCC[f]:a.currentTile.QCD;g.quantizationParameters=h;var i=void 0!==a.currentTile.COC[f]?a.currentTile.COC[f]:a.currentTile.COD;g.codingStyleParameters=i}e.codingStyleDefaultParameters=a.currentTile.COD}var u={LL:0,LH:1,HL:1,HH:2};a.prototype={parse:function(a){var b=readUint16(a,0);if(65359===b)return void this.parseCodestream(a,0,a.length);for(var c=0,d=a.length;d>c;){var e=8,f=readUint32(a,c),g=readUint32(a,c+4);if(c+=e,1===f&&(f=4294967296*readUint32(a,c)+readUint32(a,c+4),c+=8,e+=8),0===f&&(f=d-c+e),e>f)throw new Error("JPX Error: Invalid box field size");var h=f-e,i=!0;switch(g){case 1785737832:i=!1;break;case 1668246642:var j=a[c];a[c+1],a[c+2];if(1===j){var k=readUint32(a,c+3);switch(k){case 16:case 17:case 18:break;default:warn("Unknown colorspace "+k)}}else 2===j&&info("ICC profile not supported");break;case 1785737827:this.parseCodestream(a,c,c+h);break;case 1783636e3:218793738!==readUint32(a,c)&&warn("Invalid JP2 signature");break;case 1783634458:case 1718909296:case 1920099697:case 1919251232:case 1768449138:break;default:var l=String.fromCharCode(g>>24&255,g>>16&255,g>>8&255,255&g);warn("Unsupported header type "+g+" ("+l+")")}i&&(c+=h)}},parseImageProperties:function(a){for(var b=a.getByte();b>=0;){var c=b;b=a.getByte();var d=c<<8|b;if(65361===d){a.skip(4);var e=a.getInt32()>>>0,f=a.getInt32()>>>0,g=a.getInt32()>>>0,h=a.getInt32()>>>0;a.skip(16);var i=a.getUint16();return this.width=e-g,this.height=f-h,this.componentsCount=i,void(this.bitsPerComponent=8)}}throw new Error("JPX Error: No size marker found in JPX stream")},parseCodestream:function(a,d,e){var f={};try{for(var g=!1,h=d;e>h+1;){var i=readUint16(a,h);h+=2;var j,k,l,m,n,q,r=0;switch(i){case 65359:f.mainHeader=!0;break;case 65497:break;case 65361:r=readUint16(a,h);var u={};u.Xsiz=readUint32(a,h+4),u.Ysiz=readUint32(a,h+8),u.XOsiz=readUint32(a,h+12),u.YOsiz=readUint32(a,h+16),u.XTsiz=readUint32(a,h+20),u.YTsiz=readUint32(a,h+24),u.XTOsiz=readUint32(a,h+28),u.YTOsiz=readUint32(a,h+32);var v=readUint16(a,h+36);u.Csiz=v;var w=[];j=h+38;for(var x=0;v>x;x++){var y={precision:(127&a[j])+1,isSigned:!!(128&a[j]),XRsiz:a[j+1],YRsiz:a[j+1]};b(y,u),w.push(y)}f.SIZ=u,f.components=w,c(f,w),f.QCC=[],f.COC=[];break;case 65372:r=readUint16(a,h);var z={};switch(j=h+2,k=a[j++],31&k){case 0:m=8,n=!0;break;case 1:m=16,n=!1;break;case 2:m=16,n=!0;break;default:throw new Error("JPX Error: Invalid SQcd value "+k)}for(z.noQuantization=8===m,z.scalarExpounded=n,z.guardBits=k>>5,l=[];r+h>j;){var A={};8===m?(A.epsilon=a[j++]>>3,A.mu=0):(A.epsilon=a[j]>>3,A.mu=(7&a[j])<<8|a[j+1],j+=2),l.push(A)}z.SPqcds=l,f.mainHeader?f.QCD=z:(f.currentTile.QCD=z,f.currentTile.QCC=[]);break;case 65373:r=readUint16(a,h);var B={};j=h+2;var C;switch(f.SIZ.Csiz<257?C=a[j++]:(C=readUint16(a,j),j+=2),k=a[j++],31&k){case 0:m=8,n=!0;break;case 1:m=16,n=!1;break;case 2:m=16,n=!0;break;default:throw new Error("JPX Error: Invalid SQcd value "+k)}for(B.noQuantization=8===m,B.scalarExpounded=n,B.guardBits=k>>5,l=[];r+h>j;)A={},8===m?(A.epsilon=a[j++]>>3,A.mu=0):(A.epsilon=a[j]>>3,A.mu=(7&a[j])<<8|a[j+1],j+=2),l.push(A);B.SPqcds=l,f.mainHeader?f.QCC[C]=B:f.currentTile.QCC[C]=B;break;case 65362:r=readUint16(a,h);var D={};j=h+2;var E=a[j++];D.entropyCoderWithCustomPrecincts=!!(1&E),D.sopMarkerUsed=!!(2&E),D.ephMarkerUsed=!!(4&E),D.progressionOrder=a[j++],D.layersCount=readUint16(a,j),j+=2,D.multipleComponentTransform=a[j++],D.decompositionLevelsCount=a[j++],D.xcb=(15&a[j++])+2,D.ycb=(15&a[j++])+2;var F=a[j++];if(D.selectiveArithmeticCodingBypass=!!(1&F),D.resetContextProbabilities=!!(2&F),D.terminationOnEachCodingPass=!!(4&F),D.verticalyStripe=!!(8&F),D.predictableTermination=!!(16&F),D.segmentationSymbolUsed=!!(32&F),D.reversibleTransformation=a[j++],D.entropyCoderWithCustomPrecincts){for(var G=[];r+h>j;){var H=a[j++];G.push({PPx:15&H,PPy:H>>4})}D.precinctsSizes=G}var I=[];if(D.selectiveArithmeticCodingBypass&&I.push("selectiveArithmeticCodingBypass"),D.resetContextProbabilities&&I.push("resetContextProbabilities"),D.terminationOnEachCodingPass&&I.push("terminationOnEachCodingPass"),D.verticalyStripe&&I.push("verticalyStripe"),D.predictableTermination&&I.push("predictableTermination"),I.length>0)throw g=!0,new Error("JPX Error: Unsupported COD options ("+I.join(", ")+")");f.mainHeader?f.COD=D:(f.currentTile.COD=D,f.currentTile.COC=[]);break;case 65424:r=readUint16(a,h),q={},q.index=readUint16(a,h+2),q.length=readUint32(a,h+4),q.dataEnd=q.length+h-2,q.partIndex=a[h+8],q.partsCount=a[h+9],f.mainHeader=!1,0===q.partIndex&&(q.COD=f.COD,q.COC=f.COC.slice(0),q.QCD=f.QCD,q.QCC=f.QCC.slice(0)),f.currentTile=q;break;case 65427:q=f.currentTile,0===q.partIndex&&(t(f,q.index),o(f)),r=q.dataEnd-h,p(f,a,h,r);break;case 65365:case 65367:case 65368:case 65380:r=readUint16(a,h);break;case 65363:throw new Error("JPX Error: Codestream code 0xFF53 (COC) is not implemented");default:throw new Error("JPX Error: Unknown codestream code: "+i.toString(16))}h+=r}}catch(J){if(g||this.failOnCorruptedImage)throw J;warn("Trying to recover from "+J.message)}this.tiles=s(f),this.width=f.SIZ.Xsiz-f.SIZ.XOsiz,this.height=f.SIZ.Ysiz-f.SIZ.YOsiz,this.componentsCount=f.SIZ.Csiz}};var v=function(){function a(a,b){var c=log2(Math.max(a,b))+1;this.levels=[];for(var d=0;c>d;d++){var e={width:a,height:b,items:[]};this.levels.push(e),a=Math.ceil(a/2),b=Math.ceil(b/2)}}return a.prototype={reset:function(a,b){for(var c,d=0,e=0;d<this.levels.length;){c=this.levels[d];var f=a+b*c.width;if(void 0!==c.items[f]){e=c.items[f];break}c.index=f,a>>=1,b>>=1,d++}d--,c=this.levels[d],c.items[c.index]=e,this.currentLevel=d,delete this.value},incrementValue:function(){var a=this.levels[this.currentLevel];a.items[a.index]++},nextLevel:function(){var a=this.currentLevel,b=this.levels[a],c=b.items[b.index];return a--,0>a?(this.value=c,!1):(this.currentLevel=a,b=this.levels[a],b.items[b.index]=c,!0)}},a}(),w=function(){function a(a,b){var c=log2(Math.max(a,b))+1;this.levels=[];for(var d=0;c>d;d++){for(var e=new Uint8Array(a*b),f=new Uint8Array(a*b),g=0,h=e.length;h>g;g++)e[g]=0,f[g]=0;var i={width:a,height:b,items:e,status:f};this.levels.push(i),a=Math.ceil(a/2),b=Math.ceil(b/2)}}return a.prototype={reset:function(a,b,c){this.currentStopValue=c;for(var d=0;d<this.levels.length;){var e=this.levels[d],f=a+b*e.width;e.index=f,a>>=1,b>>=1,d++}this.currentLevel=this.levels.length-1,this.minValue=this.levels[this.currentLevel].items[0]},incrementValue:function(){var a=this.levels[this.currentLevel];a.items[a.index]=a.items[a.index]+1,a.items[a.index]>this.minValue&&(this.minValue=a.items[a.index])},nextLevel:function(){var a=this.currentLevel;if(a--,0>a)return!1;this.currentLevel=a;var b=this.levels[a];return b.items[b.index]<this.minValue?b.items[b.index]=this.minValue:b.items[b.index]>this.minValue&&(this.minValue=b.items[b.index]),!0},isLeaf:function(){return 0===this.currentLevel},isAboveThreshold:function(){var a=this.currentLevel,b=this.levels[a];return b.items[b.index]>this.currentStopValue},isKnown:function(){var a=this.currentLevel,b=this.levels[a];return b.status[b.index]>0},setKnown:function(){var a=this.currentLevel,b=this.levels[a];b.status[b.index]=1}},a}(),x=function(){function a(a,b,c,g,h){this.width=a,this.height=b,this.contextLabelTable="HH"===c?f:"HL"===c?e:d;var i=a*b;this.neighborsSignificance=new Uint8Array(i),this.coefficentsSign=new Uint8Array(i),this.coefficentsMagnitude=h>14?new Uint32Array(i):h>6?new Uint16Array(i):new Uint8Array(i),this.processingFlags=new Uint8Array(i);var j=new Uint8Array(i);if(0!==g)for(var k=0;i>k;k++)j[k]=g;this.bitsDecoded=j,this.reset()}var b=17,c=18,d=new Uint8Array([0,5,8,0,3,7,8,0,4,7,8,0,0,0,0,0,1,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8]),e=new Uint8Array([0,3,4,0,5,7,7,0,8,8,8,0,0,0,0,0,1,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8]),f=new Uint8Array([0,1,2,0,1,2,2,0,2,2,2,0,0,0,0,0,3,4,5,0,4,5,5,0,5,5,5,0,0,0,0,0,6,7,7,0,7,7,7,0,7,7,7,0,0,0,0,0,8,8,8,0,8,8,8,0,8,8,8,0,0,0,0,0,8,8,8,0,8,8,8,0,8,8,8]);return a.prototype={setDecoder:function(a){this.decoder=a},reset:function(){this.contexts=new Int8Array(19),this.contexts[0]=8,this.contexts[b]=92,this.contexts[c]=6},setNeighborsSignificance:function(a,b,c){var d,e=this.neighborsSignificance,f=this.width,g=this.height,h=b>0,i=f>b+1;a>0&&(d=c-f,h&&(e[d-1]+=16),i&&(e[d+1]+=16),e[d]+=4),g>a+1&&(d=c+f,h&&(e[d-1]+=16),i&&(e[d+1]+=16),e[d]+=4),h&&(e[c-1]+=1),i&&(e[c+1]+=1),e[c]|=128},runSignificancePropogationPass:function(){for(var a=this.decoder,b=this.width,c=this.height,d=this.coefficentsMagnitude,e=this.coefficentsSign,f=this.neighborsSignificance,g=this.processingFlags,h=this.contexts,i=this.contextLabelTable,j=this.bitsDecoded,k=-2,l=1,m=2,n=0;c>n;n+=4)for(var o=0;b>o;o++)for(var p=n*b+o,q=0;4>q;q++,p+=b){var r=n+q;if(r>=c)break;if(g[p]&=k,!d[p]&&f[p]){var s=i[f[p]],t=a.readBit(h,s);if(t){var u=this.decodeSignBit(r,o,p);e[p]=u,d[p]=1,this.setNeighborsSignificance(r,o,p),g[p]|=m}j[p]++,g[p]|=l}}},decodeSignBit:function(a,b,c){var d,e,f,g,h,i,j=this.width,k=this.height,l=this.coefficentsMagnitude,m=this.coefficentsSign;g=b>0&&0!==l[c-1],j>b+1&&0!==l[c+1]?(f=m[c+1],g?(e=m[c-1],d=1-f-e):d=1-f-f):g?(e=m[c-1],d=1-e-e):d=0;var n=3*d;return g=a>0&&0!==l[c-j],k>a+1&&0!==l[c+j]?(f=m[c+j],g?(e=m[c-j],d=1-f-e+n):d=1-f-f+n):g?(e=m[c-j],d=1-e-e+n):d=n,d>=0?(h=9+d,i=this.decoder.readBit(this.contexts,h)):(h=9-d,i=1^this.decoder.readBit(this.contexts,h)),i},runMagnitudeRefinementPass:function(){for(var a,b=this.decoder,c=this.width,d=this.height,e=this.coefficentsMagnitude,f=this.neighborsSignificance,g=this.contexts,h=this.bitsDecoded,i=this.processingFlags,j=1,k=2,l=c*d,m=4*c,n=0;l>n;n=a){a=Math.min(l,n+m);for(var o=0;c>o;o++)for(var p=n+o;a>p;p+=c)if(e[p]&&0===(i[p]&j)){var q=16;if(0!==(i[p]&k)){i[p]^=k;var r=127&f[p];q=0===r?15:14}var s=b.readBit(g,q);e[p]=e[p]<<1|s,h[p]++,i[p]|=j}}},runCleanupPass:function(){for(var a,d=this.decoder,e=this.width,f=this.height,g=this.neighborsSignificance,h=this.coefficentsMagnitude,i=this.coefficentsSign,j=this.contexts,k=this.contextLabelTable,l=this.bitsDecoded,m=this.processingFlags,n=1,o=2,p=e,q=2*e,r=3*e,s=0;f>s;s=a){a=Math.min(s+4,f);for(var t=s*e,u=f>s+3,v=0;e>v;v++){var w,x=t+v,y=u&&0===m[x]&&0===m[x+p]&&0===m[x+q]&&0===m[x+r]&&0===g[x]&&0===g[x+p]&&0===g[x+q]&&0===g[x+r],z=0,A=x,B=s;if(y){var C=d.readBit(j,c);if(!C){l[x]++,l[x+p]++,l[x+q]++,l[x+r]++;continue}z=d.readBit(j,b)<<1|d.readBit(j,b),0!==z&&(B=s+z,A+=z*e),w=this.decodeSignBit(B,v,A),i[A]=w,h[A]=1,this.setNeighborsSignificance(B,v,A),m[A]|=o,A=x;for(var D=s;B>=D;D++,A+=e)l[A]++;z++}for(B=s+z;a>B;B++,A+=e)if(!h[A]&&0===(m[A]&n)){var E=k[g[A]],F=d.readBit(j,E);1===F&&(w=this.decodeSignBit(B,v,A),i[A]=w,h[A]=1,this.setNeighborsSignificance(B,v,A),m[A]|=o),l[A]++}}}},checkSegmentationSymbol:function(){var a=this.decoder,c=this.contexts,d=a.readBit(c,b)<<3|a.readBit(c,b)<<2|a.readBit(c,b)<<1|a.readBit(c,b);if(10!==d)throw new Error("JPX Error: Invalid segmentation symbol")}},a}(),y=function(){function a(){}return a.prototype.calculate=function(a,b,c){for(var d=a[0],e=1,f=a.length;f>e;e++)d=this.iterate(d,a[e],b,c);return d},a.prototype.extend=function(a,b,c){var d=b-1,e=b+1,f=b+c-2,g=b+c;a[d--]=a[e++],a[g++]=a[f--],a[d--]=a[e++],a[g++]=a[f--],a[d--]=a[e++],a[g++]=a[f--],a[d]=a[e],a[g]=a[f]},a.prototype.iterate=function(a,b,c,d){var e,f,g,h,i,j,k=a.width,l=a.height,m=a.items,n=b.width,o=b.height,p=b.items;for(g=0,e=0;l>e;e++)for(h=2*e*n,f=0;k>f;f++,g++,h+=2)p[h]=m[g];m=a.items=null;var q=4,r=new Float32Array(n+2*q);if(1===n){if(0!==(1&c))for(j=0,g=0;o>j;j++,g+=n)p[g]*=.5}else for(j=0,g=0;o>j;j++,g+=n)r.set(p.subarray(g,g+n),q),this.extend(r,q,n),this.filter(r,q,n),p.set(r.subarray(q,q+n),g);var s=16,t=[];for(e=0;s>e;e++)t.push(new Float32Array(o+2*q));var u,v=0;if(a=q+o,1===o){if(0!==(1&d))for(i=0;n>i;i++)p[i]*=.5}else for(i=0;n>i;i++){if(0===v){for(s=Math.min(n-i,s),g=i,h=q;a>h;g+=n,h++)for(u=0;s>u;u++)t[u][h]=p[g+u];v=s}v--;var w=t[v];if(this.extend(w,q,o),this.filter(w,q,o),0===v)for(g=i-s+1,h=q;a>h;g+=n,h++)for(u=0;s>u;u++)p[g+u]=t[u][h]}return{width:n,height:o,items:p}},a}(),z=function(){function a(){y.call(this)}return a.prototype=Object.create(y.prototype),a.prototype.filter=function(a,b,c){var d=c>>1;b=0|b;var e,f,g,h,i=-1.586134342059924,j=-.052980118572961,k=.882911075530934,l=.443506852043971,m=1.230174104914001,n=1/m;for(e=b-3,f=d+4;f--;e+=2)a[e]*=n;for(e=b-2,g=l*a[e-1],f=d+3;f--&&(h=l*a[e+1],a[e]=m*a[e]-g-h,f--);e+=2)e+=2,g=l*a[e+1],a[e]=m*a[e]-g-h;for(e=b-1,g=k*a[e-1],f=d+2;f--&&(h=k*a[e+1],a[e]-=g+h,f--);e+=2)e+=2,g=k*a[e+1],a[e]-=g+h;for(e=b,g=j*a[e-1],f=d+1;f--&&(h=j*a[e+1],a[e]-=g+h,f--);e+=2)e+=2,g=j*a[e+1],a[e]-=g+h;if(0!==d)for(e=b+1,g=i*a[e-1],f=d;f--&&(h=i*a[e+1],a[e]-=g+h,f--);e+=2)e+=2,g=i*a[e+1],a[e]-=g+h},a}(),A=function(){function a(){y.call(this)}return a.prototype=Object.create(y.prototype),a.prototype.filter=function(a,b,c){var d=c>>1;b=0|b;var e,f;for(e=b,f=d+1;f--;e+=2)a[e]-=a[e-1]+a[e+1]+2>>2;for(e=b+1,f=d;f--;e+=2)a[e]+=a[e-1]+a[e+1]>>1},a}();return a}(),ArithmeticDecoder=function(){function a(a,b,c){this.data=a,this.bp=b,this.dataEnd=c,this.chigh=a[b],this.clow=0,this.byteIn(),this.chigh=this.chigh<<7&65535|this.clow>>9&127,this.clow=this.clow<<7&65535,this.ct-=7,this.a=32768}var b=[{qe:22017,nmps:1,nlps:1,switchFlag:1},{qe:13313,nmps:2,nlps:6,switchFlag:0},{qe:6145,nmps:3,nlps:9,switchFlag:0},{qe:2753,nmps:4,nlps:12,switchFlag:0},{qe:1313,nmps:5,nlps:29,switchFlag:0},{qe:545,nmps:38,nlps:33,switchFlag:0},{qe:22017,nmps:7,nlps:6,switchFlag:1},{qe:21505,nmps:8,nlps:14,switchFlag:0},{qe:18433,nmps:9,nlps:14,switchFlag:0},{qe:14337,nmps:10,nlps:14,switchFlag:0},{qe:12289,nmps:11,nlps:17,switchFlag:0},{qe:9217,nmps:12,nlps:18,switchFlag:0},{qe:7169,nmps:13,nlps:20,switchFlag:0},{qe:5633,nmps:29,nlps:21,switchFlag:0},{qe:22017,nmps:15,nlps:14,switchFlag:1},{qe:21505,nmps:16,nlps:14,switchFlag:0},{qe:20737,nmps:17,nlps:15,switchFlag:0},{qe:18433,nmps:18,nlps:16,switchFlag:0},{qe:14337,nmps:19,nlps:17,switchFlag:0},{qe:13313,nmps:20,nlps:18,switchFlag:0},{qe:12289,nmps:21,nlps:19,switchFlag:0},{qe:10241,nmps:22,nlps:19,switchFlag:0},{qe:9217,nmps:23,nlps:20,switchFlag:0},{qe:8705,nmps:24,nlps:21,switchFlag:0},{qe:7169,nmps:25,nlps:22,switchFlag:0},{qe:6145,nmps:26,nlps:23,switchFlag:0},{qe:5633,nmps:27,nlps:24,switchFlag:0},{
qe:5121,nmps:28,nlps:25,switchFlag:0},{qe:4609,nmps:29,nlps:26,switchFlag:0},{qe:4353,nmps:30,nlps:27,switchFlag:0},{qe:2753,nmps:31,nlps:28,switchFlag:0},{qe:2497,nmps:32,nlps:29,switchFlag:0},{qe:2209,nmps:33,nlps:30,switchFlag:0},{qe:1313,nmps:34,nlps:31,switchFlag:0},{qe:1089,nmps:35,nlps:32,switchFlag:0},{qe:673,nmps:36,nlps:33,switchFlag:0},{qe:545,nmps:37,nlps:34,switchFlag:0},{qe:321,nmps:38,nlps:35,switchFlag:0},{qe:273,nmps:39,nlps:36,switchFlag:0},{qe:133,nmps:40,nlps:37,switchFlag:0},{qe:73,nmps:41,nlps:38,switchFlag:0},{qe:37,nmps:42,nlps:39,switchFlag:0},{qe:21,nmps:43,nlps:40,switchFlag:0},{qe:9,nmps:44,nlps:41,switchFlag:0},{qe:5,nmps:45,nlps:42,switchFlag:0},{qe:1,nmps:45,nlps:43,switchFlag:0},{qe:22017,nmps:46,nlps:46,switchFlag:0}];return a.prototype={byteIn:function(){var a=this.data,b=this.bp;if(255===a[b]){var c=a[b+1];c>143?(this.clow+=65280,this.ct=8):(b++,this.clow+=a[b]<<9,this.ct=7,this.bp=b)}else b++,this.clow+=b<this.dataEnd?a[b]<<8:65280,this.ct=8,this.bp=b;this.clow>65535&&(this.chigh+=this.clow>>16,this.clow&=65535)},readBit:function(a,c){var d,e=a[c]>>1,f=1&a[c],g=b[e],h=g.qe,i=this.a-h;if(this.chigh<h)h>i?(i=h,d=f,e=g.nmps):(i=h,d=1^f,1===g.switchFlag&&(f=d),e=g.nlps);else{if(this.chigh-=h,0!==(32768&i))return this.a=i,f;h>i?(d=1^f,1===g.switchFlag&&(f=d),e=g.nlps):(d=f,e=g.nmps)}do 0===this.ct&&this.byteIn(),i<<=1,this.chigh=this.chigh<<1&65535|this.clow>>15&1,this.clow=this.clow<<1&65535,this.ct--;while(0===(32768&i));return this.a=i,a[c]=e<<1|f,d}},a}(),globalScope="undefined"==typeof window?this:window,isWorker="undefined"==typeof window,FONT_IDENTITY_MATRIX=[.001,0,0,.001,0,0],TextRenderingMode={FILL:0,STROKE:1,FILL_STROKE:2,INVISIBLE:3,FILL_ADD_TO_PATH:4,STROKE_ADD_TO_PATH:5,FILL_STROKE_ADD_TO_PATH:6,ADD_TO_PATH:7,FILL_STROKE_MASK:3,ADD_TO_PATH_FLAG:4},ImageKind={GRAYSCALE_1BPP:1,RGB_24BPP:2,RGBA_32BPP:3},AnnotationType={WIDGET:1,TEXT:2,LINK:3},StreamType={UNKNOWN:0,FLATE:1,LZW:2,DCT:3,JPX:4,JBIG:5,A85:6,AHX:7,CCF:8,RL:9},FontType={UNKNOWN:0,TYPE1:1,TYPE1C:2,CIDFONTTYPE0:3,CIDFONTTYPE0C:4,TRUETYPE:5,CIDFONTTYPE2:6,TYPE3:7,OPENTYPE:8,TYPE0:9,MMTYPE1:10};globalScope.PDFJS||(globalScope.PDFJS={}),globalScope.PDFJS.pdfBug=!1,PDFJS.VERBOSITY_LEVELS={errors:0,warnings:1,infos:5};var OPS=PDFJS.OPS={dependency:1,setLineWidth:2,setLineCap:3,setLineJoin:4,setMiterLimit:5,setDash:6,setRenderingIntent:7,setFlatness:8,setGState:9,save:10,restore:11,transform:12,moveTo:13,lineTo:14,curveTo:15,curveTo2:16,curveTo3:17,closePath:18,rectangle:19,stroke:20,closeStroke:21,fill:22,eoFill:23,fillStroke:24,eoFillStroke:25,closeFillStroke:26,closeEOFillStroke:27,endPath:28,clip:29,eoClip:30,beginText:31,endText:32,setCharSpacing:33,setWordSpacing:34,setHScale:35,setLeading:36,setFont:37,setTextRenderingMode:38,setTextRise:39,moveText:40,setLeadingMoveText:41,setTextMatrix:42,nextLine:43,showText:44,showSpacedText:45,nextLineShowText:46,nextLineSetSpacingShowText:47,setCharWidth:48,setCharWidthAndBounds:49,setStrokeColorSpace:50,setFillColorSpace:51,setStrokeColor:52,setStrokeColorN:53,setFillColor:54,setFillColorN:55,setStrokeGray:56,setFillGray:57,setStrokeRGBColor:58,setFillRGBColor:59,setStrokeCMYKColor:60,setFillCMYKColor:61,shadingFill:62,beginInlineImage:63,beginImageData:64,endInlineImage:65,paintXObject:66,markPoint:67,markPointProps:68,beginMarkedContent:69,beginMarkedContentProps:70,endMarkedContent:71,beginCompat:72,endCompat:73,paintFormXObjectBegin:74,paintFormXObjectEnd:75,beginGroup:76,endGroup:77,beginAnnotations:78,endAnnotations:79,beginAnnotation:80,endAnnotation:81,paintJpegXObject:82,paintImageMaskXObject:83,paintImageMaskXObjectGroup:84,paintImageXObject:85,paintInlineImageXObject:86,paintInlineImageXObjectGroup:87,paintImageXObjectRepeat:88,paintImageMaskXObjectRepeat:89,paintSolidColorImageMask:90,constructPath:91},UNSUPPORTED_FEATURES=PDFJS.UNSUPPORTED_FEATURES={unknown:"unknown",forms:"forms",javaScript:"javaScript",smask:"smask",shadingPattern:"shadingPattern",font:"font"},UnsupportedManager=PDFJS.UnsupportedManager=function(){var a=[];return{listen:function(b){a.push(b)},notify:function(b){warn('Unsupported feature "'+b+'"');for(var c=0,d=a.length;d>c;c++)a[c](b)}}}();PDFJS.isValidUrl=isValidUrl,PDFJS.shadow=shadow;var PasswordResponses=PDFJS.PasswordResponses={NEED_PASSWORD:1,INCORRECT_PASSWORD:2},PasswordException=function(){function a(a,b){this.name="PasswordException",this.message=a,this.code=b}return a.prototype=new Error,a.constructor=a,a}();PDFJS.PasswordException=PasswordException;var UnknownErrorException=function(){function a(a,b){this.name="UnknownErrorException",this.message=a,this.details=b}return a.prototype=new Error,a.constructor=a,a}();PDFJS.UnknownErrorException=UnknownErrorException;var InvalidPDFException=function(){function a(a){this.name="InvalidPDFException",this.message=a}return a.prototype=new Error,a.constructor=a,a}();PDFJS.InvalidPDFException=InvalidPDFException;var MissingPDFException=function(){function a(a){this.name="MissingPDFException",this.message=a}return a.prototype=new Error,a.constructor=a,a}();PDFJS.MissingPDFException=MissingPDFException;var UnexpectedResponseException=function(){function a(a,b){this.name="UnexpectedResponseException",this.message=a,this.status=b}return a.prototype=new Error,a.constructor=a,a}();PDFJS.UnexpectedResponseException=UnexpectedResponseException;var NotImplementedException=function(){function a(a){this.message=a}return a.prototype=new Error,a.prototype.name="NotImplementedException",a.constructor=a,a}(),MissingDataException=function(){function a(a,b){this.begin=a,this.end=b,this.message="Missing data ["+a+", "+b+")"}return a.prototype=new Error,a.prototype.name="MissingDataException",a.constructor=a,a}(),XRefParseException=function(){function a(a){this.message=a}return a.prototype=new Error,a.prototype.name="XRefParseException",a.constructor=a,a}();Object.defineProperty(PDFJS,"isLittleEndian",{configurable:!0,get:function(){return shadow(PDFJS,"isLittleEndian",isLittleEndian())}}),Object.defineProperty(PDFJS,"hasCanvasTypedArrays",{configurable:!0,get:function(){return shadow(PDFJS,"hasCanvasTypedArrays",hasCanvasTypedArrays())}});var Uint32ArrayView=function(){function a(a,b){this.buffer=a,this.byteLength=a.length,this.length=void 0===b?this.byteLength>>2:b,c(this.length)}function b(a){return{get:function(){var b=this.buffer,c=a<<2;return(b[c]|b[c+1]<<8|b[c+2]<<16|b[c+3]<<24)>>>0},set:function(b){var c=this.buffer,d=a<<2;c[d]=255&b,c[d+1]=b>>8&255,c[d+2]=b>>16&255,c[d+3]=b>>>24&255}}}function c(c){for(;c>d;)Object.defineProperty(a.prototype,d,b(d)),d++}a.prototype=Object.create(null);var d=0;return a}(),IDENTITY_MATRIX=[1,0,0,1,0,0],Util=PDFJS.Util=function(){function a(){}var b=["rgb(",0,",",0,",",0,")"];return a.makeCssRgb=function(a,c,d){return b[1]=a,b[3]=c,b[5]=d,b.join("")},a.transform=function(a,b){return[a[0]*b[0]+a[2]*b[1],a[1]*b[0]+a[3]*b[1],a[0]*b[2]+a[2]*b[3],a[1]*b[2]+a[3]*b[3],a[0]*b[4]+a[2]*b[5]+a[4],a[1]*b[4]+a[3]*b[5]+a[5]]},a.applyTransform=function(a,b){var c=a[0]*b[0]+a[1]*b[2]+b[4],d=a[0]*b[1]+a[1]*b[3]+b[5];return[c,d]},a.applyInverseTransform=function(a,b){var c=b[0]*b[3]-b[1]*b[2],d=(a[0]*b[3]-a[1]*b[2]+b[2]*b[5]-b[4]*b[3])/c,e=(-a[0]*b[1]+a[1]*b[0]+b[4]*b[1]-b[5]*b[0])/c;return[d,e]},a.getAxialAlignedBoundingBox=function(b,c){var d=a.applyTransform(b,c),e=a.applyTransform(b.slice(2,4),c),f=a.applyTransform([b[0],b[3]],c),g=a.applyTransform([b[2],b[1]],c);return[Math.min(d[0],e[0],f[0],g[0]),Math.min(d[1],e[1],f[1],g[1]),Math.max(d[0],e[0],f[0],g[0]),Math.max(d[1],e[1],f[1],g[1])]},a.inverseTransform=function(a){var b=a[0]*a[3]-a[1]*a[2];return[a[3]/b,-a[1]/b,-a[2]/b,a[0]/b,(a[2]*a[5]-a[4]*a[3])/b,(a[4]*a[1]-a[5]*a[0])/b]},a.apply3dTransform=function(a,b){return[a[0]*b[0]+a[1]*b[1]+a[2]*b[2],a[3]*b[0]+a[4]*b[1]+a[5]*b[2],a[6]*b[0]+a[7]*b[1]+a[8]*b[2]]},a.singularValueDecompose2dScale=function(a){var b=[a[0],a[2],a[1],a[3]],c=a[0]*b[0]+a[1]*b[2],d=a[0]*b[1]+a[1]*b[3],e=a[2]*b[0]+a[3]*b[2],f=a[2]*b[1]+a[3]*b[3],g=(c+f)/2,h=Math.sqrt((c+f)*(c+f)-4*(c*f-e*d))/2,i=g+h||1,j=g-h||1;return[Math.sqrt(i),Math.sqrt(j)]},a.normalizeRect=function(a){var b=a.slice(0);return a[0]>a[2]&&(b[0]=a[2],b[2]=a[0]),a[1]>a[3]&&(b[1]=a[3],b[3]=a[1]),b},a.intersect=function(b,c){function d(a,b){return a-b}var e=[b[0],b[2],c[0],c[2]].sort(d),f=[b[1],b[3],c[1],c[3]].sort(d),g=[];return b=a.normalizeRect(b),c=a.normalizeRect(c),e[0]===b[0]&&e[1]===c[0]||e[0]===c[0]&&e[1]===b[0]?(g[0]=e[1],g[2]=e[2],f[0]===b[1]&&f[1]===c[1]||f[0]===c[1]&&f[1]===b[1]?(g[1]=f[1],g[3]=f[2],g):!1):!1},a.sign=function(a){return 0>a?-1:1},a.appendToArray=function(a,b){Array.prototype.push.apply(a,b)},a.prependToArray=function(a,b){Array.prototype.unshift.apply(a,b)},a.extendObj=function(a,b){for(var c in b)a[c]=b[c]},a.getInheritableProperty=function(a,b){for(;a&&!a.has(b);)a=a.get("Parent");return a?a.get(b):null},a.inherit=function(a,b,c){a.prototype=Object.create(b.prototype),a.prototype.constructor=a;for(var d in c)a.prototype[d]=c[d]},a.loadScript=function(a,b){var c=document.createElement("script"),d=!1;c.setAttribute("src",a),b&&(c.onload=function(){d||b(),d=!0}),document.getElementsByTagName("head")[0].appendChild(c)},a}(),PageViewport=PDFJS.PageViewport=function(){function a(a,b,c,d,e,f){this.viewBox=a,this.scale=b,this.rotation=c,this.offsetX=d,this.offsetY=e;var g,h,i,j,k=(a[2]+a[0])/2,l=(a[3]+a[1])/2;switch(c%=360,c=0>c?c+360:c){case 180:g=-1,h=0,i=0,j=1;break;case 90:g=0,h=1,i=1,j=0;break;case 270:g=0,h=-1,i=-1,j=0;break;default:g=1,h=0,i=0,j=-1}f&&(i=-i,j=-j);var m,n,o,p;0===g?(m=Math.abs(l-a[1])*b+d,n=Math.abs(k-a[0])*b+e,o=Math.abs(a[3]-a[1])*b,p=Math.abs(a[2]-a[0])*b):(m=Math.abs(k-a[0])*b+d,n=Math.abs(l-a[1])*b+e,o=Math.abs(a[2]-a[0])*b,p=Math.abs(a[3]-a[1])*b),this.transform=[g*b,h*b,i*b,j*b,m-g*b*k-i*b*l,n-h*b*k-j*b*l],this.width=o,this.height=p,this.fontScale=b}return a.prototype={clone:function(b){b=b||{};var c="scale"in b?b.scale:this.scale,d="rotation"in b?b.rotation:this.rotation;return new a(this.viewBox.slice(),c,d,this.offsetX,this.offsetY,b.dontFlip)},convertToViewportPoint:function(a,b){return Util.applyTransform([a,b],this.transform)},convertToViewportRectangle:function(a){var b=Util.applyTransform([a[0],a[1]],this.transform),c=Util.applyTransform([a[2],a[3]],this.transform);return[b[0],b[1],c[0],c[1]]},convertToPdfPoint:function(a,b){return Util.applyInverseTransform([a,b],this.transform)}},a}(),PDFStringTranslateTable=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,728,711,710,729,733,731,730,732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8226,8224,8225,8230,8212,8211,402,8260,8249,8250,8722,8240,8222,8220,8221,8216,8217,8218,8482,64257,64258,321,338,352,376,381,305,322,339,353,382,0,8364];PDFJS.createPromiseCapability=createPromiseCapability,function(){function a(a){this._status=b,this._handlers=[];try{a.call(this,this._resolve.bind(this),this._reject.bind(this))}catch(c){this._reject(c)}}if(globalScope.Promise)return"function"!=typeof globalScope.Promise.all&&(globalScope.Promise.all=function(a){var b,c,d=0,e=[],f=new globalScope.Promise(function(a,d){b=a,c=d});return a.forEach(function(a,f){d++,a.then(function(a){e[f]=a,d--,0===d&&b(e)},c)}),0===d&&b(e),f}),"function"!=typeof globalScope.Promise.resolve&&(globalScope.Promise.resolve=function(a){return new globalScope.Promise(function(b){b(a)})}),"function"!=typeof globalScope.Promise.reject&&(globalScope.Promise.reject=function(a){return new globalScope.Promise(function(b,c){c(a)})}),void("function"!=typeof globalScope.Promise.prototype["catch"]&&(globalScope.Promise.prototype["catch"]=function(a){return globalScope.Promise.prototype.then(void 0,a)}));var b=0,c=1,d=2,e=500,f={handlers:[],running:!1,unhandledRejections:[],pendingRejectionCheck:!1,scheduleHandlers:function(a){a._status!==b&&(this.handlers=this.handlers.concat(a._handlers),a._handlers=[],this.running||(this.running=!0,setTimeout(this.runHandlers.bind(this),0)))},runHandlers:function(){for(var a=1,b=Date.now()+a;this.handlers.length>0;){var e=this.handlers.shift(),f=e.thisPromise._status,g=e.thisPromise._value;try{f===c?"function"==typeof e.onResolve&&(g=e.onResolve(g)):"function"==typeof e.onReject&&(g=e.onReject(g),f=c,e.thisPromise._unhandledRejection&&this.removeUnhandeledRejection(e.thisPromise))}catch(h){f=d,g=h}if(e.nextPromise._updateStatus(f,g),Date.now()>=b)break}return this.handlers.length>0?void setTimeout(this.runHandlers.bind(this),0):void(this.running=!1)},addUnhandledRejection:function(a){this.unhandledRejections.push({promise:a,time:Date.now()}),this.scheduleRejectionCheck()},removeUnhandeledRejection:function(a){a._unhandledRejection=!1;for(var b=0;b<this.unhandledRejections.length;b++)this.unhandledRejections[b].promise===a&&(this.unhandledRejections.splice(b),b--)},scheduleRejectionCheck:function(){this.pendingRejectionCheck||(this.pendingRejectionCheck=!0,setTimeout(function(){this.pendingRejectionCheck=!1;for(var a=Date.now(),b=0;b<this.unhandledRejections.length;b++)if(a-this.unhandledRejections[b].time>e){var c=this.unhandledRejections[b].promise._value,d="Unhandled rejection: "+c;c.stack&&(d+="\n"+c.stack),warn(d),this.unhandledRejections.splice(b),b--}this.unhandledRejections.length&&this.scheduleRejectionCheck()}.bind(this),e))}};a.all=function(b){function c(a){g._status!==d&&(i=[],f(a))}var e,f,g=new a(function(a,b){e=a,f=b}),h=b.length,i=[];if(0===h)return e(i),g;for(var j=0,k=b.length;k>j;++j){var l=b[j],m=function(a){return function(b){g._status!==d&&(i[a]=b,h--,0===h&&e(i))}}(j);a.isPromise(l)?l.then(m,c):m(l)}return g},a.isPromise=function(a){return a&&"function"==typeof a.then},a.resolve=function(b){return new a(function(a){a(b)})},a.reject=function(b){return new a(function(a,c){c(b)})},a.prototype={_status:null,_value:null,_handlers:null,_unhandledRejection:null,_updateStatus:function(b,e){if(this._status!==c&&this._status!==d){if(b===c&&a.isPromise(e))return void e.then(this._updateStatus.bind(this,c),this._updateStatus.bind(this,d));this._status=b,this._value=e,b===d&&0===this._handlers.length&&(this._unhandledRejection=!0,f.addUnhandledRejection(this)),f.scheduleHandlers(this)}},_resolve:function(a){this._updateStatus(c,a)},_reject:function(a){this._updateStatus(d,a)},then:function(b,c){var d=new a(function(a,b){this.resolve=a,this.reject=b});return this._handlers.push({thisPromise:this,onResolve:b,onReject:c,nextPromise:d}),f.scheduleHandlers(this),d},"catch":function(a){return this.then(void 0,a)}},globalScope.Promise=a}();var StatTimer=function(){function a(a,b,c){for(;a.length<c;)a+=b;return a}function b(){this.started={},this.times=[],this.enabled=!0}return b.prototype={time:function(a){this.enabled&&(a in this.started&&warn("Timer is already running for "+a),this.started[a]=Date.now())},timeEnd:function(a){this.enabled&&(a in this.started||warn("Timer has not been started for "+a),this.times.push({name:a,start:this.started[a],end:Date.now()}),delete this.started[a])},toString:function(){var b,c,d=this.times,e="",f=0;for(b=0,c=d.length;c>b;++b){var g=d[b].name;g.length>f&&(f=g.length)}for(b=0,c=d.length;c>b;++b){var h=d[b],i=h.end-h.start;e+=a(h.name," ",f)+" "+i+"ms\n"}return e}},b}();PDFJS.createBlob=function(a,b){if("undefined"!=typeof Blob)return new Blob([a],{type:b});var c=new MozBlobBuilder;return c.append(a),c.getBlob(b)},PDFJS.createObjectURL=function(){var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";return function(b,c){if(!PDFJS.disableCreateObjectURL&&"undefined"!=typeof URL&&URL.createObjectURL){var d=PDFJS.createBlob(b,c);return URL.createObjectURL(d)}for(var e="data:"+c+";base64,",f=0,g=b.length;g>f;f+=3){var h=255&b[f],i=255&b[f+1],j=255&b[f+2],k=h>>2,l=(3&h)<<4|i>>4,m=g>f+1?(15&i)<<2|j>>6:64,n=g>f+2?63&j:64;e+=a[k]+a[l]+a[m]+a[n]}return e}}(),MessageHandler.prototype={on:function(a,b,c){var d=this.actionHandler;d[a]&&error('There is already an actionName called "'+a+'"'),d[a]=[b,c]},send:function(a,b,c){var d={action:a,data:b};this.postMessage(d,c)},sendWithPromise:function(a,b,c){var d=this.callbackIndex++,e={action:a,data:b,callbackId:d},f=createPromiseCapability();this.callbacksCapabilities[d]=f;try{this.postMessage(e,c)}catch(g){f.reject(g)}return f.promise},postMessage:function(a,b){b&&this.postMessageTransfers?this.comObj.postMessage(a,b):this.comObj.postMessage(a)}};
/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JSZip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength);
    } else {
        output = new Array(totalLength);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":27,"./utils":29}],2:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":22,"./stream/DataLengthProbe":23,"./stream/DataWorker":24}],3:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":7,"./stream/GenericWorker":25}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};
// vim: set shiftwidth=4 softtabstop=4:

},{"./utils":29}],5:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],6:[function(require,module,exports){
'use strict';

var ES6Promise = require("es6-promise").Promise;

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"es6-promise":37}],7:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = new pako[action]({
        raw:true,
        level : options.level || -1 // default compression
    });
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};

    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":25,"./utils":29,"pako":38}],8:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    // set bit 11 if utf8
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    // don't stream folders (because they don't have any content)
    if(this.streamFiles && !streamInfo['file'].dir) {
        var record = generateZipParts(streamInfo, this.streamFiles, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var record = generateZipParts(streamInfo, this.streamFiles, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(this.streamFiles && !streamInfo['file'].dir) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":20,"../stream/GenericWorker":25,"../utf8":28,"../utils":29}],9:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":3,"./ZipFileWorker":8}],10:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":13,"./support":27}],11:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":6,"./nodejsUtils":12,"./stream/Crc32Probe":22,"./utf8":28,"./utils":29,"./zipEntries":30}],12:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBuffer : function(data, encoding){
        return new Buffer(data, encoding);
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

}).call(this,(typeof Buffer !== "undefined" ? Buffer : undefined))
},{}],13:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} o the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, o) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    o = utils.extend(o || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    o.binary = !isUnicodeString;


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              options.platform === 'darwin' ||
              options.platform === 'freebsd' ||
              options.platform === 'linux' ||
              options.platform === 'sunos'
          ) {
              options.platform = "UNIX";
          }
          if (options.platform === 'win32') {
              options.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":35,"./nodejsUtils":12,"./stream/GenericWorker":25,"./stream/StreamHelper":26,"./utf8":28,"./utils":29,"./zipObject":32}],14:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":29,"./DataReader":15}],15:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specifed index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":29}],16:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":29,"./Uint8ArrayReader":18}],17:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":29,"./DataReader":15}],18:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":29,"./ArrayReader":14}],19:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

// vim: set shiftwidth=4 softtabstop=4:

},{"../support":27,"../utils":29,"./ArrayReader":14,"./NodeBufferReader":16,"./StringReader":17,"./Uint8ArrayReader":18}],20:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],21:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":29,"./GenericWorker":25}],22:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":4,"../utils":29,"./GenericWorker":25}],23:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":29,"./GenericWorker":25}],24:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":29,"./GenericWorker":25}],25:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],26:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
var external = require("../external");

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

}).call(this,(typeof Buffer !== "undefined" ? Buffer : undefined))
},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":35,"../utils":29,"./ConvertWorker":21,"./GenericWorker":25}],27:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

exports.nodestream = !!require("./nodejs/NodejsStreamOutputAdapter").prototype;

}).call(this,(typeof Buffer !== "undefined" ? Buffer : undefined))
},{"./nodejs/NodejsStreamOutputAdapter":35}],28:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBuffer(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":12,"./stream/GenericWorker":25,"./support":27,"./utils":29}],29:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var asap = require('asap');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.newBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.newBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    asap(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    var promise = null;
    if (support.blob && inputData instanceof Blob && typeof FileReader !== "undefined") {
        promise = new external.Promise(function (resolve, reject) {
            var reader = new FileReader();

            reader.onload = function(e) {
                resolve(e.target.result);
            };
            reader.onerror = function(e) {
                reject(e.target.error);
            };
            reader.readAsArrayBuffer(inputData);
        });
    } else {
        // if data is already a promise, this flatten it.
        promise = external.Promise.resolve(inputData);
    }

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("The data of '" + name + "' is in an unsupported format !")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":1,"./external":6,"./nodejsUtils":12,"./support":27,"asap":33}],30:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the speficied signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip : can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":19,"./signature":20,"./support":27,"./utf8":28,"./utils":29,"./zipEntry":31}],31:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":19,"./support":27,"./utf8":28,"./utils":29}],32:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
        }
        var result = this._decompressWorker();

        var isUnicodeString = !this._dataBinary;

        if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":2,"./stream/DataWorker":24,"./stream/GenericWorker":25,"./stream/StreamHelper":26,"./utf8":28}],33:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":34}],34:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(require,module,exports){

},{}],36:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],37:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":36}],38:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],42:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":41}],43:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],44:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],45:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],46:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],48:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],49:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":41}],51:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],52:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":41}],53:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}]},{},[10])(10)
});
/**
 * Created by admin on 2016/6/13.
 */
if(!dvStruct){
    var dvStruct = {};
}

//用于双击操作标志
//用于方法1
dvStruct.dblclickFlag={
    clickState:false,
    winNo:16//选中窗口的序号
};
 

//promise缓存---原始的
dvStruct.imgObjArr = [];

// dvStruct.printObjArr ;
// dvStruct.printRightObjArr ;
//html大容器
dvStruct.container = undefined;
//图像数据
dvStruct.seriesArr = [];
dvStruct.insertSeries = function(newS){
    if(dvStruct.seriesArr.length==0){dvStruct.seriesArr.push(newS);
        return;}
    for(var i=0,len=dvStruct.seriesArr.length;i<len;i++){
        //字典不比后面大就插前面
        if(!firstIsBigger(newS.suid,dvStruct.seriesArr[i].suid)){
            dvStruct.seriesArr.splice(i, 0, newS);
            return;
        }
    }
    //没有可插的就加后面
    dvStruct.seriesArr.push(newS);
}
//添加序列
dvStruct.addSeries = function(suid,dicomCoverted){
    //这是在已经检查过series的存在之后
    var newS = {
        suid:suid,
        sNo:dicomCoverted.infoSet.SeriesInfo.SeriesNo.val,//sNo --- 不用这个排   还是suid --- 时间
        dicomArr:[],
        sideImageIds:[]
    };
    newS.sideImageIds.push({
        farsideImageId:dicomCoverted.imageId
        ,nearsideImageId:dicomCoverted.imageId
    });
    //初始化offset(算距离的时候消除整个序列相对原点的偏移)  这里还不能直接赋值，因为序列就位了dicom没就位还
    newS.offset = undefined;
    //把新的序列排序插入
    dvStruct.insertSeries(newS);
    //添加第一个对象
    newS.dicomArr.push(dicomCoverted);
    //触发新序列添加事件
    commEventHandler.fireEvent({type:'dicomSeriesAdded',suid:suid,sNo:newS.sNo,dicomCoverted:dicomCoverted});
    return newS;
}
dvStruct.dicomInsert = function(series,dicomCoverted){
    if(series.dicomArr.length==0){
        series.dicomArr.push(dicomCoverted);
        commEventHandler.fireEvent({type:'dicomAddedPush',series:series,dicomCoverted:dicomCoverted});
        return;}
    for(var i=0,len=series.dicomArr.length;i<len;i++){//series.dicomArr.length 是动态的！！！所以前面return弄丢会出现循环 danm！
        //字典不比后面大就插前面
        if(parseInt(dicomCoverted.iid)<parseInt(series.dicomArr[i].iid)){
            series.dicomArr.splice(i, 0, dicomCoverted);
            commEventHandler.fireEvent({type:'dicomAddedSplice',series:series,dicomCoverted:dicomCoverted,i:i});
            return;
        }
    }
    //没有可插的就加后面
    series.dicomArr.push(dicomCoverted);
    commEventHandler.fireEvent({type:'dicomAddedPush',series:series,dicomCoverted:dicomCoverted});
};
dvStruct.addDicom = function(dicomCoverted,infoAfterAnalysised){
    var suid = dicomCoverted.infoSet.UIDS.SeriesUID.val;
    infoAfterAnalysised.suid = suid;//传参给文件
    var series = dvStruct.findSeries(suid);
    if(series){
        dvStruct.dicomInsert(series,dicomCoverted);
    }else{
        series = dvStruct.addSeries(suid,dicomCoverted);
    }
    //console.log(series);
    //触发事件
    commEventHandler.fireEvent({type:'dicomAdded',suid:suid,dicomCoverted:dicomCoverted,series:series});
}
dvStruct.findSeries = function(seriesUid){

       // translate2Chinese();//汉化
         


    return _.find(dvStruct.seriesArr,function(o){
        return o.suid == seriesUid;
    });
}
dvStruct.findSeriesByElement = function(element){
    var winId = $(element).parents('.seriesWindow:first').attr('id');
    var w = _.find(dvStruct.viewer.winArr,function(w){
        return w.winId == winId ;
    });
    if(!_.isUndefined(w)){
        var suid = w.wrappers[0].suid;
        var s = dvStruct.findSeries(suid);
        return s;
    }
    return undefined;
}
dvStruct.countSNo = function(seriesUid){
    var No=0;
    var re= _.find(dvStruct.seriesArr,function(o){
        No++;
        return o.suid == seriesUid;
    });
    return No;
}
dvStruct.findOriInfoByIds = function(imageId,suid){
    var s = dvStruct.findSeries(suid);
    if(!_.isUndefined(s)){
        var arr = s.dicomArr;
        var re = _.find(arr,function(o){
            return o.imageId == imageId;
        });
        if(!_.isUndefined(re)){
            return re.infoSet
        }
    }
    return undefined;
}
dvStruct.findOriInfoOnlyByOriId = function(imageId){
    for(var i=0,len=dvStruct.seriesArr.length;i<len;i++){
        var s = dvStruct.seriesArr[i];
        if(!_.isUndefined(s)){
            var arr = s.dicomArr;
            var re = _.find(arr,function(o){
                return o.imageId == imageId;
            });
            if(!_.isUndefined(re)){
                return re.infoSet
            }
        }
    }
    return undefined;
}

//----------------eventHandler

commEventHandler.addEventListener('dicomAdded',function(event){
    //-------------位置信息相关-------------------------
    // console.log("-------------位置信息相关-------------------------");
    //   console.log( event.dicomCoverted.imageId);
    var newSourceImagePlane = cornerstoneTools.metaData.get('imagePlane', event.dicomCoverted.imageId);
    // console.log(newSourceImagePlane);
    
    var newPosition=null;
    var newSourceImageNormal=null;
    var seeked = false;
    // console.log(newSourceImagePlane);
    if( newSourceImagePlane!=undefined){
        newPosition= newSourceImagePlane.imagePositionPatient;



      newSourceImageNormal = newSourceImagePlane.rowCosines.clone().cross(newSourceImagePlane.columnCosines);

    for(var i=0,len=event.series.sideImageIds.length;i<len;i++){
        var sides = event.series.sideImageIds[i];
        var farplane =  cornerstoneTools.metaData.get('imagePlane', sides.farsideImageId);
        var farplaneNormal = farplane.rowCosines.clone().cross(farplane.columnCosines);
        var angleInRadians = newSourceImageNormal.angleTo(farplaneNormal);
        angleInRadians = Math.abs(angleInRadians);
        //判断平行
        if (angleInRadians < 0.1&&newPosition!=null) { // 0.5 radians = ~30 degrees  0.1弧度(rad)=5.729578度(°)  还真的有乱拍的，就是不知道这个图。。。留什么好
            seeked = true;
            //算离原点最远的一面以及离这一面最远的一面
            var farpos =  farplane.imagePositionPatient;
            var farmore =  dvStruct.vo.farsideCal(farpos,newPosition);
            // console.log(newPosition,farpos,farmore,dvStruct.vo.notSame(farpos,farmore));
            if(dvStruct.vo.notSame(farpos,farmore)){
                sides.farsideImageId = event.dicomCoverted.imageId;
            }else{
                var nearpos =  dvStruct.vo.getPositionById(sides.nearsideImageId);
                if(dvStruct.vo.calDistanceSquared([nearpos,farpos])<dvStruct.vo.calDistanceSquared([newPosition,farpos])){
                    sides.nearsideImageId = event.dicomCoverted.imageId;
                }
            }
            break;
        }
    }
    }
    if(!seeked){
        event.series.sideImageIds.push({
            farsideImageId:event.dicomCoverted.imageId,
            nearsideImageId:event.dicomCoverted.imageId
        });
    }

    //算偏移
    //if(!!!event.series.offset){
    //    event.series.offset = dvStruct.vo.getPositionById(event.dicomCoverted.imageId)
    //}else{
    //    var oldOfs = event.series.offset;
    //    var nearly = dvStruct.vo.nearToOrigin(oldOfs,newPosition);
    //    if(dvStruct.vo.notSame(nearly,oldOfs)){
    //        event.series.offset = nearly;
    //        //这里可以发个事件
    //    }
    //}

    //其它
    var node;
    var iid = event.series.dicomArr[0].iid;
    var imageId = event.series.dicomArr[0].imageId;

    var studyDate=event.series.dicomArr[0].infoSet.StudyInfo.StudyDate.val;
    $(dvStruct.container).find('.leftGallery .img').each(function(){
        if($(this).attr('suid')==event.suid){
            var s = dvStruct.findSeries(event.suid);
            if(!_.isUndefined(s)){
                var num = s.dicomArr.length;
                $(this).parent().find('.total').text(num);
            //    sj add
                $(this).parent().find('.studyDate').text(studyDate);
            }
            return false;
        }
    });//console.log(event.dicomCoverted);
    //查左边序列是否要更新
    $(dvStruct.container).find('.leftGallery .img').each(function(){
        if($(this).attr('suid')==event.suid){
            var theiid = $(this).attr('iid');
            if(parseInt(iid)<parseInt(theiid)){
                var ele = $(this).get(0);
                var enableEle = cornerstone.getEnabledElement(ele);enableEle.viewport=undefined;
                cornerstone.loadImage(imageId).then(function(image) {
                    cornerstone.displayImage(ele, image);
                });
            }
        }
    });
});

function updateTotalImgNo(win){
    for(var i=0,len=win.wrappers.length;i<len;i++){
        var wrapper = win.wrappers[i];
        var len = wrapper.stack.imageIds.length;
        if(len>0){
            var wrapperBox = $(wrapper.element).parent();
            $(wrapperBox).find('.js-info-totalNo').text('/'+len);
        }
    }
}
//以push的方式同步插入到窗体
commEventHandler.addEventListener('dicomAddedPush',function(event){
    if(dvStruct.showHander)//console.log('dicomAddedPush')
    ;

    ////同步到窗体-------窗体内的数字更新就暂时不加了(懒得加)（要改，1把总数提出来 单独，2，在这里改总数）
    var dataSet = event.dicomCoverted.dataSet;
    for(var i=0,len=dvStruct.viewer.col*dvStruct.viewer.row;i<len;i++){
        var win  = dvStruct.viewer.winArr[i];//console.log(win);
        if(win.wrappers[0].suid == event.series.suid){
            var newImgObj =   createNewImageObject(dataSet,'series:'+win.winId+':'+event.series.suid);
            var newImgId =  event.dicomCoverted.imageId;
            newImgObj.bindOriImageId = newImgId;//这个用来获取对应的原始信息
            win.imgObjArr.push(newImgObj);
            //用的是同一个数组
            var wrapper = win.wrappers[0];
            if(wrapper.stack.imageIds.length>0){
                wrapper.stack.imageIds.push(newImgObj.imageId);
                //至于N*N这个。。。
                var len =wrapper.stack.imageIds.length;
                if(len>1&&len<=win.col*win.row){
                    var wrapChange = win.wrappers[len-1]; var lastWrapper = win.wrappers[len-2];
                    var enabledElement = cornerstone.getEnabledElement(wrapChange.element);
                    wrapChange.stack.imageIds = wrapper.stack.imageIds;
                    wrapChange.stack.currentImageIdIndex = lastWrapper.stack.currentImageIdIndex+1>=len?0:lastWrapper.stack.currentImageIdIndex+1;
                    //清空信息----放前面
                    dvStruct.viewer.emptyInfo(wrapChange);
                    //清掉viewport之后它才会重画
                    enabledElement.viewport = undefined;//console.log(enabledElement);
                    reDrawWrapper(wrapChange);
                    dvStruct.fun.elementIni(wrapChange.element,win);
                    dvStruct.fun.checkAndSetActive(wrapChange.element);
                    //添加信息
                    dvStruct.viewer.fillInfo(wrapChange);//console.log(wrapper);
                }
                //把图片总数更新了
                updateTotalImgNo(win);
            }
        }
    }
});
//以splice的形式插入
commEventHandler.addEventListener('dicomAddedSplice',function(event){if(dvStruct.showHander)//console.log('dicomAddedSplice')
     ;

    var dataSet = event.dicomCoverted.dataSet;
    var insertIndex = event.i;
    for(var i=0,len1=dvStruct.viewer.col*dvStruct.viewer.row;i<len1;i++) {
        var win = dvStruct.viewer.winArr[i];
        if (win.wrappers[0].suid == event.series.suid) {
            //创建对象
            var newImgObj =   createNewImageObject(dataSet,'series:'+win.winId+':'+event.series.suid);
            var newImgId =  event.dicomCoverted.imageId;
            newImgObj.bindOriImageId = newImgId;
            //obj插入
            win.imgObjArr.splice(i,0,newImgObj);
            var wrapper = win.wrappers[0];
            if(wrapper.stack.imageIds.length>0){
                //id插入
                wrapper.stack.imageIds.splice(insertIndex,0,newImgObj.imageId);//由于是通的，共用一个数组的引用，所以就这样了
                //图未全的时候
                var  len =wrapper.stack.imageIds.length;
                if(len>1&&len<=win.col*win.row){
                    for(var j=0;j<len;j++){
                        var wp = win.wrappers[j];
                        var enabledElement = cornerstone.getEnabledElement(wp.element);
                        if(j==len-1){
                            //新出一个图像
                            var lastWrapper = win.wrappers[len-2];
                            wp.stack.imageIds = wrapper.stack.imageIds;
                            wp.stack.currentImageIdIndex = lastWrapper.stack.currentImageIdIndex+1>=len?0:lastWrapper.stack.currentImageIdIndex+1;
                            //清空信息----放前面
                            dvStruct.viewer.emptyInfo(wp);
                            //清掉viewport之后它才会重画
                            enabledElement.viewport = undefined;//console.log(enabledElement);
                            reDrawWrapper(wp);
                            dvStruct.fun.elementIni(wp.element,win);
                            dvStruct.fun.checkAndSetActive(wp.element);
                            //添加信息
                            dvStruct.viewer.fillInfo(wp);//console.log(wrapper);
                        }else{//console.log(wp.stack.currentImageIdIndex,insertIndex);
                            if(wp.stack.currentImageIdIndex >= insertIndex){
                                reDrawWrapper(wp);
                            }
                        }
                    }
                }else if(len>=win.col*win.row){
                    for(var j=0;j<win.col*win.row;j++){
                        var wp = win.wrappers[j];
                        var enabledElement = cornerstone.getEnabledElement(wp.element);
                        if(wp.stack.currentImageIdIndex >= insertIndex){
                            reDrawWrapper(wp);
                        }
                    }
                }
                updateTotalImgNo(win);
            }
        }
    }
});

//一开始等待绑定的窗口以及序列
dvStruct.waitingBind = [];
dvStruct.addWaitingBind = function(suid,win){dvStruct.waitingBind.push({suid:suid,win:win});}
var checkAndBind = function(suid){
    for(var i = 0,len=dvStruct.waitingBind.length;i<len;i++){
        if(dvStruct.waitingBind[i].suid == suid){
            //没有被绑才绑
            if(!dvStruct.waitingBind[i].win.wrappers[0].suid){
                dvStruct.viewer.bindSeries(dvStruct.waitingBind[i].win,suid);
            }
            //从等待绑定的序列中移除
            dvStruct.waitingBind.splice(i,1);
            break;
        }
    }
}

commEventHandler.addEventListener('dicomSeriesAddedOld',function(event){
    if(dvStruct.showHander)//console.log('dicomSeriesAdded');
    var tmp = get_dicom_imgViewer_templates('preview');
    var id = guid(8,'gallery');
    var imageId = event.dicomCoverted.imageId;
    var iid =  event.dicomCoverted.iid;
    if($(dvStruct.container).find('.leftGallery .imgBox').length==0){
        $(dvStruct.container).find('.leftGallery').append(tmp({
            id:id,suid:event.suid,imageId:imageId,iid:iid,sNo:event.sNo
        }));
    }else{
        var done = false;
        $(dvStruct.container).find('.leftGallery .imgBox').each(function(){
            var suid = $(this).find('.img').attr('suid');
            if(!firstIsBigger(event.suid,suid)){
                $(this).before(tmp({
                    id:id,suid:event.suid,imageId:imageId,iid:iid
                }));
                done=true;return false;
            }
        });
        if(!done){
            $(dvStruct.container).find('.leftGallery').append(tmp({
                id:id,suid:event.suid,imageId:imageId,iid:iid
            }));
        }
    }
    var ele = $(dvStruct.container).find('#'+id).get(0);
    cornerstone.enable(ele);
    //小图要取消对scroll事件的限制，不然滚动条事件触发不了，这里hack一下(不是这里？？)
    cornerstoneTools.mouseWheelInput.disable(ele);$(ele).off('mousewheel DOMMouseScroll');
    //绘制小图
    cornerstone.loadImage(imageId).then(function(image) {//console.log('dicomSeriesAdded:',image);
        cornerstone.displayImage(ele, image);
    });
    //检查是否有需要绑定的
    checkAndBind(event.suid);
    //序列号的添加/修改
    // console.time('testt');
    $(dvStruct.container).find('.leftGallery').find('.imgBox').each(function(){
        var suid = $(this).children('.img').attr('suid');
        $(this).find('.se').text('Se: '+dvStruct.countSNo(suid));
    });
    for(var i=0,len1=dvStruct.viewer.maxCol*dvStruct.viewer.maxRow;i<len1;i++) {
        var win = dvStruct.viewer.winArr[i];
        if (win&&win.wrappers[0].suid) {
            var no  = dvStruct.countSNo(win.wrappers[0].suid);
            for(var j=0,len2=win.wrappers.length;j<len2;j++){
                if(win.wrappers[j].stack.imageIds.length>0)
                    $(win.wrappers[j].element).parents('.viewportWrapper').find('.js-info-SeNo').text('Se: '+no);;
            }
        }
    }
    // console.timeEnd('testt');
});


commEventHandler.addEventListener('dicomSeriesAdded',function(event){
    if(dvStruct.showHander)//console.log('dicomSeriesAdded');
        var tmp = get_dicom_imgViewer_templates('preview');
    var id = guid(8,'gallery');
    var imageId = event.dicomCoverted.imageId;
    var iid =  event.dicomCoverted.iid;

    var patientName=event.dicomCoverted.infoSet.PatientInfo.PatientName.val;
    // var studyDate=event.dicomCoverted.infoSet.StudyInfo.StudyDate.val;

    var patientNameShow=patientName;

    var byteLen=getByte(patientName);

if(byteLen>8){
    patientNameShow=cutString(patientName,8,"...");
}

    //检查是否有该病人
    if($(dvStruct.container).find('.leftGallery .patientName').length==0){
       /* var patientNameHtml='<div class="patientName"><div class="title"><span class="txt">'+patientName+'</span> ' +
            '<div class="folder"><i class="fa fa-plus folderOut" style="display: none" aria-hidden="true"></i>'+
            '<i class="fa fa-minus folderIn" aria-hidden="true"></i></div></div></div>';*/

        var patientNameHtml=$('<div class="patientName"></div>');
        var folder=$('<div class="folder"><i class="fa fa-plus folderOut" style="display: none" aria-hidden="true"></i><i class="fa fa-minus folderIn" aria-hidden="true"></i></div>');
        var txt=$('<span class="txt">'+patientNameShow+'</span>');
        var title=$('<div class="title" title="'+patientName+'"></div>');
        title.append(folder,txt);
        patientNameHtml.append(title);
        $(dvStruct.container).find('.leftGallery').append(patientNameHtml);
    }
    else{
        var isExistence=false;
        $(dvStruct.container).find('.leftGallery .patientName').each(function (k,val) {
            var name=$(this).find('.title').attr("title");

            if(name==patientName)
            {
                isExistence=true;
            }
        });
        if(!isExistence){

            if(getByte(patientName)>8){
                patientNameShow=cutString(patientName,8,"...");
            }

            var patientNameHtml=$('<div class="patientName"></div>');
            var folder=$('<div class="folder"><i class="fa fa-plus folderOut" style="display: none" aria-hidden="true"></i><i class="fa fa-minus folderIn" aria-hidden="true"></i></div>');
            var txt=$('<span class="txt">'+patientNameShow+'</span>');
            var title=$('<div class="title" title="'+patientName+'"></div>');
            title.append(folder,txt);
            patientNameHtml.append(title);
            $(dvStruct.container).find('.leftGallery').append(patientNameHtml);

        }
    }

    //图像插入
    $(dvStruct.container).find('.leftGallery .patientName').each(function () {

        var name=$(this).find('.title').attr("title");

        if(name==patientName)
        {
            if($(this).find('.imgBox').length==0){
                $(this).append(tmp({
                    id:id,suid:event.suid,imageId:imageId,iid:iid,sNo:event.sNo
                }));
            }
            else {
                var done = false;
                $(this).find('.imgBox').each(function () {
                    var suid = $(this).find('.img').attr('suid');
                    if(!firstIsBigger(event.suid,suid)){
                        $(this).before(tmp({
                            id:id,suid:event.suid,imageId:imageId,iid:iid
                        }));
                        done=true;return false;
                    }
                });
                if(!done){
                    $(this).append(tmp({
                        id:id,suid:event.suid,imageId:imageId,iid:iid
                    }));
                }
            }
        }

    });



    var ele = $(dvStruct.container).find('#'+id).get(0);
    cornerstone.enable(ele);
    //小图要取消对scroll事件的限制，不然滚动条事件触发不了，这里hack一下(不是这里？？)
    cornerstoneTools.mouseWheelInput.disable(ele);$(ele).off('mousewheel DOMMouseScroll');
    //绘制小图
    cornerstone.loadImage(imageId).then(function(image) {//console.log('dicomSeriesAdded:',image);
        cornerstone.displayImage(ele, image);
    });
    //检查是否有需要绑定的
    checkAndBind(event.suid);
    //序列号的添加/修改
    // console.time('testt');
    $(dvStruct.container).find('.leftGallery').find('.imgBox').each(function(){
        var suid = $(this).children('.img').attr('suid');
        $(this).find('.se').text('Se: '+dvStruct.countSNo(suid));
    });


    for(var i=0,len1=dvStruct.viewer.maxCol*dvStruct.viewer.maxRow;i<len1;i++) {
        var win = dvStruct.viewer.winArr[i];
        if (win&&win.wrappers[0].suid) {
            var no  = dvStruct.countSNo(win.wrappers[0].suid);
            for(var j=0,len2=win.wrappers.length;j<len2;j++){
                if(win.wrappers[j].stack.imageIds.length>0)
                    $(win.wrappers[j].element).parents('.viewportWrapper').find('.js-info-SeNo').text('Se: '+no);;
            }
        }
    }
    // console.timeEnd('testt');
});


function reDrawWrapper(wrapper){//console.log(wrapper);
    var imageId = wrapper.stack.imageIds[wrapper.stack.currentImageIdIndex];
    // console.log("redrawwrapper========================");
    if(imageId){
        cornerstone.loadImage(imageId).then(function(image) {
            try {
                //if(type&&type=='forceIniRender')cornerstone.initializeGrayscaleRenderCanvas(image);
                cornerstone.displayImage(wrapper.element, image);
                //方位标签
                cornerstoneTools.orientationMarkers.enable(wrapper.element);
                // cornerstoneTools.drarRuler.enable(wrapper.element);
            }catch(e){
                console.error(e);//updateImage: image has not been loaded yet
                console.error(image,imageId,wrapper.element);
            }
        });
    }
}

commEventHandler.addEventListener('bindImage',function(event){if(dvStruct.showHander)//console.log('bindImage');
    event.eleObj.imageId = event.imageId; reDrawEle(event.eleObj);
});

dvStruct.showHander = true;
/**
 * Created by admin on 2016/3/25.
 */
if (!dvStruct) {
    var dvStruct = {};
}

//视图数据 --- 历史，与缓存 ------  只有一层排列，自由搭配，原先是照着墨洛维搞的，跟他后处理不同，抽象层次多了编程还麻烦。很多软件是只有一层的
dvStruct.viewer = {
    col: 1, row: 1, maxCol: 4, maxRow: 4, eachW: 0, eachH: 0,
    maxInnerCol: 2,
    maxInnerRow: 2,
    scrollAll: false,
    //
    addNewWin: function (id, no) {
        var newWin = {
            winId: id,//id也是html元素的id
            no: no,//第几个，有用得上的时候
            row: 1,
            col: 1,
            wrappers: [],
            imgObjArr: [],//wrapper里面只有一个imageId
            //一个窗口一个同步对象
            synchronizerWWWC: new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.wwwcSynchronizer),
            synchronizerZoomPan: new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.panZoomSynchronizer),
            //旋转----这个是自己新加的
            //synchronizerRotate : new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.rotateSynchronizer)
        };
        this.winArr.push(newWin);
        return newWin;
    },
    winArr: [],
    getWinByNo: function (no) {
        return _.find(dvStruct.viewer.winArr, function (o) {
            return o.no == no;
        });
    },
    //返回eachW eahcH
    calInnerEachSize: function (a) {
        //id或者obj
        if (_.isObject(a)) {
            re = a;
        } else {
            var re = _.find(dvStruct.viewer.winArr, function (o) {
                return o.winId == a;
            });
        }
        if (_.isObject(re)) {
            return [(dvStruct.viewer.eachW - 4) / re.col, (dvStruct.viewer.eachH - 4) / re.row];
        }
        return undefined;
    },
    //返回选中的win
    getCheckedWin: function () {
        var id = $('.seriesWindow.checked').attr('id');
        var win = _.find(dvStruct.viewer.winArr, function (o) {
            return o.winId == id;
        });
        return win;
    },
    isInWin: function (element, win) {
        for (var i = 0,len=win.wrappers.length; i < len; i++) {
            var ele = win.wrappers[i].element;
            if (element == ele) {
                return true;
            }
        }
        return false;
    },
    isInSameWin: function (element1, element2) {
        if ($(element1).parents('.seriesWindow').get(0) == $(element2).parents('.seriesWindow').get(0))return true;
        return false;
    },
    //寻找一个win
    getWin: function (wid) {
        var re = _.find(dvStruct.viewer.winArr, function (o) {
            return o.winId == a;
        });
        return re;
    },
    //建一个包
    createWrapper: function (o, No) {
        return {
            no: No,//在窗体内部是第几个
            pid: o.pid,//parent id
            eid: o.eid,//element的id ------ id就够了
            element: o.element,
            suid: undefined,
            stack: {
                currentImageIdIndex: 0,
                imageIds: []
            }
        }
    },
    clearWrapper: function (w) {
        w.suid = undefined;
        w.stack.currentImageIdIndex = 0;
        w.stack.imageIds = [];
    },
    //遍历wrapper
    eachElement: function (opts) {
        if (!_.isObject(opts))opts = {};
        if (_.isObject(opts.win)) {
            var arr = [opts.win];
        } else {
            var arr = dvStruct.viewer.winArr;
        }
        for (var i = 0,len0=arr.length; i < len0; i++) {
            var win = arr[i];
            for (var j = 0,len1=win.wrappers.length; j < len1; j++) {
                if (opts.callback) {//console.log(win.wrappers[j]);
                    opts.callback(win.wrappers[j].element, win.wrappers[j]);
                }
            }
        }
    },
    eachWin: function (opts) {
        if (!_.isObject(opts))opts = {};
        var arr = dvStruct.viewer.winArr;
        for (var i = 0,len=arr.length; i < len; i++) {
            if (opts.callback) {
                opts.callback(arr[i]);
            }
        }
    },
    getWrapperById: function (eid) {
        var arr = dvStruct.viewer.winArr;
        for (var i = 0,len=arr.length; i < len; i++) {
            var win = arr[i];
            for (var j = 0,len1=win.wrappers.length; j < len1; j++) {
                var wrapper = win.wrappers[j];
                if (wrapper.eid == eid) {
                    return wrapper;
                }
            }
        }
        return undefined;
    }
};
dvStruct.viewer.findOriInfoByIds = function (imageId) {//由于绘制逻辑似乎不简单，cornerstone里面的onViewportUpdated，并不完全受我控制还
    if (imageId.indexOf("loadJoinImg")>=0) {
        return;//imgjoin
    }
    var arr = imageId.split(':');//console.log(imageId);
    if (arr[0] == 'oridcm') {
        return dvStruct.findOriInfoOnlyByOriId(imageId);
    } else {
        var winId = arr[1];
        var suid = arr[2];
        var win = _.find(dvStruct.viewer.winArr, function (o) {
            return o.winId == winId;
        });
        var re = _.find(win.imgObjArr, function (o) {
            return o.imageId == imageId;
        });
        if (_.isObject(re)) {
            var oriImageId = re.bindOriImageId;
            return dvStruct.findOriInfoByIds(oriImageId, suid);
        }
    }
    return undefined;
};
dvStruct.viewer.findWin = function (winId) {
    var win = _.find(dvStruct.viewer.winArr, function (o) {
        return o.winId == winId;
    });
    return win;
};
dvStruct.viewer.bindSeries = function (win, suid) {
    //原始series数据
    var series = dvStruct.findSeries(suid);
    var imgs = series.dicomArr;
    var imgids = [];
    win.imgObjArr = [];//清空与不清空，就在这一念间
    for (var i = 0,len0=imgs.length; i < len0; i++) {
        //把element的id以及原始suid和imageId的信息也传入imgId里去
        var imgObj = createNewImageObject(imgs[i].dataSet, 'series:' + win.winId + ':' + suid);
        imgObj.bindOriImageId = imgs[i].imageId;//这个用来获取对应的原始信息
        win.imgObjArr.push(imgObj);
        imgids.push(imgObj.imageId);
    }
    var len = imgids.length;
    //联动先去掉
    for (var i = 0,len0=dvStruct.viewer.maxInnerCol * dvStruct.viewer.maxInnerRow; i < len0; i++) {
        var wrapper = win.wrappers[i];
        dvStruct.fun.removeSync(win, wrapper.element);
    }
    for (var i = 0,len0=dvStruct.viewer.maxInnerCol * dvStruct.viewer.maxInnerRow; i < len0; i++) {
        var wrapper = win.wrappers[i];
        wrapper.suid = suid;
        //imageIds
        wrapper.stack.imageIds = [];//只有当前显示的才有imageIds，这个会用在很多判断
        if (i < win.col * win.row) {
            var enabledElement = cornerstone.getEnabledElement(wrapper.element);
            //suid
            //初始的索引
            //如果图片数量还没wrapper多，则多余的画布无效化
            if (i < len) {
                wrapper.stack.currentImageIdIndex = i;
            }
            //画
            //console.log(i,len-1);
            if (i < len) {
                wrapper.stack.imageIds = imgids;
                //清空信息----放前面
                dvStruct.viewer.emptyInfo(wrapper);
                //清掉viewport之后它才会重画
                enabledElement.viewport = undefined;//console.log(enabledElement);
                //console.log(i,wrapper);
                reDrawWrapper(wrapper);
                dvStruct.fun.elementIni(wrapper.element, win);
                dvStruct.fun.checkAndSetActive(wrapper.element);
                //添加信息
                dvStruct.viewer.fillInfo(wrapper);//console.log(wrapper);
            } else {
                //id清空
                wrapper.stack.imageIds = [];
                //如果有图了，则清空
                var img = cornerstone.getImage(wrapper.element);//console.log(img);
                // 所以下面自己写清空
                if (_.isObject(img)) {
                    //先把动作去掉，特别是需要图的
                    cornerstoneTools.mouseInput.disable(wrapper.element);
                    dvStruct.fun.disableTools(wrapper.element);
                    // clear the canvas
                    var context = enabledElement.canvas.getContext('2d');
                    context.setTransform(1, 0, 0, 1, 0, 0);//还非要加这个 作者没有置回去
                    context.fillStyle = 'black';
                    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
                    //
                    enabledElement.data = {};
                    enabledElement.image = undefined;
                    //清空信息-------放后面
                    dvStruct.viewer.emptyInfo(wrapper);
                }
            }
        }
    }
};
dvStruct.viewer.resizeWin = function (win) {
    var firstWrapper = win.wrappers[0];
    var firstEnabledElement = cornerstone.getEnabledElement(firstWrapper.element);
    var currentFirst = firstWrapper.stack.currentImageIdIndex;
    var len = firstWrapper.stack.imageIds.length;//console.log(win);
    if (len > 0)
        for (var i = 1,len1=win.col * win.row; i < len1; i++) {
            var wrapper = win.wrappers[i];
            var enabledElement = cornerstone.getEnabledElement(wrapper.element);
            if (i < len) {//console.log(enabledElement.viewport,firstEnabledElement.viewport);
                wrapper.stack.imageIds = firstWrapper.stack.imageIds;
                var nowIndex = currentFirst + i > len - 1 ? (currentFirst + i) - len : currentFirst + i;//console.log(nowIndex,wrapper.stack.imageIds);
                wrapper.stack.currentImageIdIndex = nowIndex;//console.log(wrapper.stack.imageIds,nowIndex);
                reDrawWrapper(wrapper);
                if (enabledElement.viewport.fakeColor != firstEnabledElement.viewport.fakeColor) {
                    enabledElement.viewport.fakeColor = firstEnabledElement.viewport.fakeColor;
                    var redv = 1;
                }
                if (enabledElement.viewport.invert != firstEnabledElement.viewport.invert) {
                    enabledElement.viewport.invert = firstEnabledElement.viewport.invert;//一致性
                    var redv = 1;
                }
                if (redv)reDrawWrapper(wrapper);
                //有子布局被关掉的就要开启
                dvStruct.fun.elementIni(wrapper.element, win);
                dvStruct.fun.checkAndSetActive(wrapper.element);
                //添加信息
                dvStruct.viewer.fillInfo(wrapper);//console.log(wrapper);
            } else {
                var context = enabledElement.canvas.getContext('2d');
                // clear the canvas
                context.setTransform(1, 0, 0, 1, 0, 0);//还非要加这个 作者没有置回去
                context.fillStyle = 'black';
                context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
            }
        }
};
dvStruct.viewer.emptyInfo = function (wrapper) {
    // console.log('emptyInfo:',wrapper);
    var wrapperBox = $(wrapper.element).parent();
    $(wrapperBox).find('.js-info').text('');
};
dvStruct.viewer.fillInfo = function (wrapper) {
    //同一个序列的设备啥的应该都一样吧
    var imageId = wrapper.stack.imageIds[wrapper.stack.currentImageIdIndex];
    var suid = wrapper.suid;
    var info = dvStruct.viewer.findOriInfoByIds(imageId, suid);

    if (_.isUndefined(info))return;
    var sNo = dvStruct.countSNo(suid);
    var wrapperBox = $(wrapper.element).parent();
    try {

        //添加的信息属性可在MPR时使用
        //var date = info.InstanceInfo.ContentDate.val.toString();var time = info.InstanceInfo.ContentTime.val.toString();
        var date = info.StudyInfo.StudyDate.val.toString();
        var time = info.StudyInfo.StudyTime.val.toString();
        if (date && time) {
            $(wrapperBox).find('.js-info-datetime').text(date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2) + ' ' + time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2));
        }

        //窗位窗宽信息
        //   console.log(info);
        var wwArr = info.SomeUsefulInfo.ww.val.split("\\");
        var wcArr = info.SomeUsefulInfo.wc.val.split("\\");
        // console.log(wwArr[0],wcArr[0]);
        $(wrapperBox).attr('ww', wwArr[0]);//添加默认窗位窗宽
        $(wrapperBox).attr('wc', wcArr[0]);
        $(wrapperBox).attr('intercept', info.ImageInfo.RescaleIntercept.val);
        $(wrapperBox).attr('slope', info.ImageInfo.RescaleSlope.val);

        // console.log("最值=======================================================");
        // console.log(info);
        // console.log(info.SomeUsefulInfo.minPixelValue.val,info.SomeUsefulInfo.maxPixelValue.val);
        $(wrapperBox).attr('studyDate',date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2));
        $(wrapperBox).attr('studyTime', time);
        $(wrapperBox).attr('sex', info.PatientInfo.PatientSex.val);
        $(wrapperBox).attr('patientName', info.PatientInfo.PatientName.val);




        if (info.SeriesInfo.Modality.val) {
            $(wrapperBox).find('.js-info-Modality').text(info.SeriesInfo.Modality.val);
        }

        // $(wrapperBox).find('.js-info-nowNo').text('Im:'+(wrapper.stack.currentImageIdIndex+1));
        $(wrapperBox).find('.js-info-totalNo').text('/' + wrapper.stack.imageIds.length);
        $(wrapperBox).find('.js-info-SeNo').text('Se: ' + sNo);

        if (!dvStruct.share)//分享状态时不显示病人姓名
        {
            $(wrapperBox).find('.js-info-PatientName').text(info.PatientInfo.PatientName.val);//sj change
        }
        // $(wrapperBox).find('.js-info-PatientName').text(info.PatientInfo.PatientName.val);//sj change
        $(wrapperBox).find('.js-info-PatientID').text(info.PatientInfo.PatientID.val);
        $(wrapperBox).find('.js-info-PatientSex').text(' ' + info.PatientInfo.PatientSex.val);
        $(wrapperBox).find('.js-info-PatientAge').text(' ' + info.PatientInfo.PatientsAge.val);

        if (birth) {
            var birth = info.PatientInfo.PatientBirthDate.val;
            $(wrapperBox).find('.js-info-PatientBirthDate').text(birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2));
        }
        if (!dvStruct.share)//分享状态时不显示医院名称
        {
            $(wrapperBox).find('.js-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);//sj
        }
        // $(wrapperBox).find('.js-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);//sj
        $(wrapperBox).find('.js-info-ProtocolName').text(info.StudyInfo.ProtocolName.val);
        $(wrapperBox).find('.js-info-StudyDescription').text(info.StudyInfo.StudyDescription.val);

        //sj add
        // console.log(info.SomeUsefulInfo.mA.val);
        // console.log(info.SomeUsefulInfo.kvp.val);
        if (info.SomeUsefulInfo.mA.val) {
            $(wrapperBox).find('.js-info-mA').text(info.SomeUsefulInfo.mA.val + 'mA');
        }

        if (info.SomeUsefulInfo.kvp.val) {
            $(wrapperBox).find('.js-info-kvp').text(info.SomeUsefulInfo.kvp.val + 'kV');
        }

        //sj add end

        var backInfo = searchBackInfo(info.UIDS.InstanceUID.val);
        if (backInfo) {
            $(wrapperBox).find('.js-info-CBZ').text(backInfo.CBZ);
        }
        if (info.ImageInfo.FieldofView.val) {
            //field of view 扫描视野 0018,0094
            $(wrapperBox).find('.js-info-fov').text('FOV:' + parseFloat(info.ImageInfo.FieldofView.val).toFixed(1));
        }
        if (info.SomeUsefulInfo.MagneticFieldStrength.val)$(wrapperBox).find('.js-info-MagneticFieldStrength').text('FS: ' + info.SomeUsefulInfo.MagneticFieldStrength.val);
        if (info.SomeUsefulInfo.RepetitionTime.val || info.SomeUsefulInfo.RepetitionTime.val)$(wrapper).find('.js-info-TrTe').text('TR: ' + info.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + info.SomeUsefulInfo.EchoTime.val);

        var pixelSpacingArr=info.ImageInfo.PixelSpacing.val.split("\\");
        // console.log("draw screen info======================",pixelSpacingArr,info.ImageInfo.PixelSpacing.val);
        // console.log(rulerInfo);
        var rulerInfo={
            imgW:parseInt(info.ImageInfo.Columns.val),
            imgH:parseInt(info.ImageInfo.Rows.val),
            pixelSpacingX:parseFloat(pixelSpacingArr[0])||1,
            pixelSpacingY:parseFloat(pixelSpacingArr[1])||1
        };
        // console.log(JSON.stringify(rulerInfo));
        // $(wrapperBox).attr('rulerInfo',JSON.stringify(rulerInfo));

        $(wrapperBox).attr('rulerInfo',JSON.stringify(rulerInfo));
        drawRuler($(wrapperBox),rulerInfo,1);

    } catch (e) {
        console.error(e);
    }
};
/**
 * Created by admin on 2016/5/6.
 */
if (!dvStruct)dvStruct = {};
if (!dvStruct.viewer)dvStruct.viewer = {};

if (!dvStruct.fun)dvStruct.fun = {};//...这个分类太糟糕了，但还是兼容下以前写的吧

dvStruct.viewer.btnStates = {//做成对象是为了之后 多键自定义考虑  现在就左键,
    wwwc: {enable: 0, type: 0},
    pan: {enable: 0, type: 0},
    zoom: {enable: 0, type: 0},
    magnify: {enable: 0, type: 1},//sj add
    magnifyTouchDrag: {enable: 0, type: 1},//sj add
    rotate: {enable: 0, type: 0},
    probe: {enable: 0, type: 0},
    probeUnSave: {enable: 0, type: 0},
    length: {enable: 0, type: 0},
    twolines: {enable: 0, type: 0},
    heartScale: {enable: 0, type: 0},//sj add
    ellipticalRoi: {enable: 0, type: 0},
    rectangleRoi: {enable: 0, type: 0},
    angle: {enable: 0, type: 0},
    simpleAngle: {enable: 0, type: 0},
    referenceLines: {enable: false}
};
dvStruct.viewer.leftBtnDisable = function () {//left mouse
    disableAllTools(1);
    for (var i in dvStruct.viewer.btnStates) {
        if (dvStruct.viewer.btnStates[i].type && dvStruct.viewer.btnStates[i].type == 1) {
            dvStruct.viewer.btnStates[i].enable = 0;
        }
    }
};
dvStruct.viewer.middleBtnDisable = function () {
    disableAllTools(2);
    for (var i in dvStruct.viewer.btnStates) {
        if (dvStruct.viewer.btnStates[i].type && dvStruct.viewer.btnStates[i].type == 2) {
            dvStruct.viewer.btnStates[i].enable = 0;
        }
    }
};
dvStruct.viewer.rightBtnDisable = function () {
    disableAllTools(4);
    for (var i in dvStruct.viewer.btnStates) {
        if (dvStruct.viewer.btnStates[i].type && dvStruct.viewer.btnStates[i].type == 4) {
            dvStruct.viewer.btnStates[i].enable = 0;
        }
    }
};

function disableAllTools(type) {
    dvStruct.viewer.eachElement({
        callback: function (element, wrapper) {
            try {
                var img = cornerstone.getImage(element);
                if (_.isObject(img))
                    dvStruct.fun.disableTools(element, type);
            } catch (e) {
                console.error(e);
            }
        }
    });
}

dvStruct.fun.disableTools = function (element, type) {
    if (!type)type = 1;//1是左键 2 is middle mouse button// 4 is right mouse button// 5 means left mouse button and right mouse button
    // console.log(element,type);
    cornerstoneTools.wwwc.deactivate(element, type);
    cornerstoneTools.pan.deactivate(element, type);
    cornerstoneTools.zoom.deactivate(element, type);
    cornerstoneTools.rotate.deactivate(element, type);
    cornerstoneTools.probe.deactivate(element, type);
    cornerstoneTools.probeUnSave.deactivate(element, type);
    cornerstoneTools.length.deactivate(element, type);
    cornerstoneTools.ellipticalRoi.deactivate(element, type);
    cornerstoneTools.rectangleRoi.deactivate(element, type);
    cornerstoneTools.angle.deactivate(element, type);
    cornerstoneTools.twolines.deactivate(element, type);
    cornerstoneTools.heartScale.deactivate(element, type);
    cornerstoneTools.magnify.deactivate(element, type);
    cornerstoneTools.magnifyTouchDrag.deactivate(element, type);
};

//这个在disable或者初始ini之后
dvStruct.fun.checkAndSetActive = function (element) {
    for (var i in dvStruct.viewer.btnStates) {
        var type = dvStruct.viewer.btnStates[i].type;
        if (dvStruct.viewer.btnStates[i].enable) {
            if (i == 'referenceLines') {
                cornerstoneTools.referenceLines.tool.enable(element, synchronizer);
            } else {
                cornerstoneTools[i].activate(element, type);
            }
        } else {
            if (i == 'referenceLines') {
                cornerstoneTools.referenceLines.tool.disable(element, synchronizer);
            } else {
                cornerstoneTools[i].deactivate(element, type);
            }
        }
    }
};

//var storage = window.localStorage;
//function showStorage(){
//    for(var i=0;i<storage.length;i++){
//        //key(i)获得相应的键，再用getItem()方法获得对应的值
//        document.write(storage.key(i)+ " : " + storage.getItem(storage.key(i)) + "<br>");
//    }
//}

(dvStruct.viewer.getBtnDiy = function () {
    if (localStorage.getItem('btnDiyStat') != 'undefined' && !!localStorage.getItem('btnDiyStat')) {
        var re = JSON.parse(localStorage.getItem('btnDiyStat'));
        //因为一旦有更新的话，以前的字段就不知道能不能用了，所以这里要用代码确保一下
        var c = false;
        if (!re.default) {
            re.default = {enable: 0, type: 0, cls: 'js-default'};
        }
        if (!re.wwwc) {
            re.wwwc = {enable: 0, type: 0, cls: 'js-wwwl'};
        }
        if (!re.pan) {
            re.pan = {enable: 0, type: 0, cls: 'js-pan'};
        }
        if (!re.zoom) {
            re.zoom = {enable: 0, type: 0, cls: 'js-zoom'};
        }
        if (!re.probe) {
            re.probe = {enable: 0, type: 0, cls: 'js-probe'};
        }
        if (!re.probeUnSave) {
            re.probeUnSave = {enable: 0, type: 0, cls: 'js-probeUnSave'};
        }
        if (!re.length) {
            re.length = {enable: 0, type: 0, cls: 'js-length'};
        }
        if (!re.twolines) {
            re.twolines = {enable: 0, type: 0, cls: 'js-twolines'};
        }
        if (!re.heartScale) {
            re.heartScale = {enable: 0, type: 0, cls: 'js-heartScale'};
        }
        if (!re.ellipticalRoi) {
            re.ellipticalRoi = {enable: 0, type: 0, cls: 'js-ellipse'};
        }
        if (!re.rectangleRoi) {
            re.rectangleRoi = {enable: 0, type: 0, cls: 'js-rect'};
        }
        if (!re.angle) {
            re.angle = {enable: 0, type: 0, cls: 'js-angle'};
        }
        if (!re.simpleAngle) {
            re.sampleAngle = {enable: 0, type: 0, cls: 'js-simpleAngle'};
        }
        if (c)localStorage.setItem('btnDiyStat', JSON.stringify(re));
    } else {
        localStorage.setItem('btnDiyStat', JSON.stringify({
            default: {enable: 1, type: 4, cls: 'js-default'},
            wwwc: {enable: 1, type: 1, cls: 'js-wwwl'},
            pan: {enable: 0, type: 0, cls: 'js-pan'},
            zoom: {enable: 0, type: 0, cls: 'js-zoom'},
            probe: {enable: 0, type: 0, cls: 'js-probe'},
            probeUnSave: {enable: 0, type: 0, cls: 'js-probeUnSave'},
            length: {enable: 0, type: 0, cls: 'js-length'},
            twolines: {enable: 0, type: 0, cls: 'js-twolines'},
            heartScale: {enable: 0, type: 0, cls: 'js-heartScale'},
            ellipticalRoi: {enable: 0, type: 0, cls: 'js-ellipse'},
            rectangleRoi: {enable: 0, type: 0, cls: 'js-rect'},
            angle: {enable: 0, type: 0, cls: 'js-angle'},
            simpleAngle: {enable: 0, type: 0, cls: 'js-simpleAngle'}
        }));
    }
    return JSON.parse(localStorage.getItem('btnDiyStat'));
})();
//
dvStruct.viewer.initBtnDiy = function () {
    var stat = dvStruct.viewer.getBtnDiy();//console.log(stat);
    $('.js-topPannel .btnArea').removeClass('leftBtnActive').removeClass('rightBtnActive').removeClass('middleBtnActive');
    for (var i in stat) {
        if (stat[i].enable) {
            for (var j in dvStruct.viewer.btnStates) {
                if (i == j) {
                    dvStruct.viewer.btnStates[j].type = stat[i].type;
                    dvStruct.viewer.btnStates[j].enable = stat[i].enable;
                }
            }
            switch (stat[i].type) {
                case 1:
                    $('.' + stat[i].cls).addClass('leftBtnActive');
                    break;
                case 2:
                    $('.' + stat[i].cls).addClass('middleBtnActive');
                    break;
                case 4:
                    $('.' + stat[i].cls).addClass('rightBtnActive');
                    break;
            }
        }
    }
}

//按钮，键位类型
dvStruct.viewer.saveDiyStat = function (cls, type) {
    var stat = dvStruct.viewer.getBtnDiy();
    for (var i in stat) {
        if (stat[i].type == type) {
            stat[i].type = 0;
            stat[i].enable = 0;
        }
        if (stat[i].cls == cls) {
            stat[i].type = type;
            stat[i].enable = 1;
        }
    }
    localStorage.setItem('btnDiyStat', JSON.stringify(stat));
}
/**
 * Created by admin on 2016/3/30.
 */
var dvStruct = dvStruct || {};
dvStruct.fun = dvStruct.fun || {};
//
var synchronizer = new cornerstoneTools.Synchronizer("CornerstoneNewImage", cornerstoneTools.updateImageSynchronizer);
dvStruct.fun.enableReferenceLines = function (element) {
    cornerstoneTools.referenceLines.tool.enable(element, synchronizer);
}
dvStruct.fun.disableReferenceLines = function (element) {
    cornerstoneTools.referenceLines.tool.disable(element, synchronizer);
}
//初始化对象
dvStruct.fun.elementIni = function (element, win) {
    cornerstoneTools.mouseInput.enable(element);//这个判定我还自己做了一遍，也是醉了
    //cornerstoneTools.mouseWheelInput.enable(element);//结合伪彩有问题貌似
    //cornerstoneTools.stackScrollWheel.activate(element);
    // Enable all tools we want to use with this element
    //cornerstoneTools.wwwc.activate(element, 1); // ww/wc is the default tool for left mouse button
    //cornerstoneTools.pan.activate(element, 2); // pan is the default tool for middle mouse button
    //cornerstoneTools.zoom.activate(element, 4); // zoom is the default tool for right mouse button
    //cornerstoneTools.zoomWheel.activate(element); // zoom is the default tool for middle mouse wheel
    cornerstoneTools.wwwc.enable(element);
    cornerstoneTools.pan.enable(element);
    cornerstoneTools.zoom.enable(element);
    cornerstoneTools.magnify.enable(element);//magnify
    cornerstoneTools.probe.enable(element);
    cornerstoneTools.probeUnSave.enable(element);
    cornerstoneTools.length.enable(element);
    cornerstoneTools.twolines.enable(element);
    cornerstoneTools.ellipticalRoi.enable(element);
    cornerstoneTools.rectangleRoi.enable(element);
    cornerstoneTools.angle.enable(element);
    cornerstoneTools.rotate.enable(element);
    //定位线
    synchronizer.add(element);//这里改写过，
    //cornerstoneTools.referenceLines.tool.enable(element, synchronizer);
    //同步
    if (win) {
        win.synchronizerWWWC.add(element);
        win.synchronizerZoomPan.add(element);
        //win.synchronizerRotate.add(element);
    }
}
dvStruct.fun.removeSync = function (win, element) {
    synchronizer.remove(element);
    win.synchronizerWWWC.remove(element);
    win.synchronizerZoomPan.remove(element);
}

function setAllEle(callbackFun) {
    dvStruct.viewer.eachElement({
        callback: function (element, wrapper) {
            try {
                var img = cornerstone.getImage(element);
                if (_.isObject(img))
                    callbackFun(element);
            } catch (e) {
                console.error(e);
            }
        }
    });
}

//找鼠标位置，不在图窗返回undefined
dvStruct.whereIsMouse = undefined;
dvStruct.init = dvStruct.init || {};
dvStruct.init.checkMouseOnViewpoint = function () {
    var $node = $(dvStruct.container).find('.js-imageViewer');
    $node.on('mousemove', function (e) {
        var x = e.pageX, y = e.pageY;
        var vArea = $(dvStruct.container).find('.js-imageViewer');
        var ofs = $(vArea).offset();
        //计算鼠标所在行列
        var cols = Math.ceil((x - ofs.left) / dvStruct.viewer.eachW);
        var rows = Math.ceil((y - ofs.top) / dvStruct.viewer.eachH);
        if (cols <= 0 || cols > dvStruct.viewer.col || rows <= 0 || rows > dvStruct.viewer.row) {
            dvStruct.whereIsMouse = undefined;
        } else {
            // 原方法 zyy
            /* var No = dvStruct.viewer.col * (rows-1) + cols -1;
             dvStruct.whereIsMouse =  dvStruct.viewer.getWinByNo(No);*/
            //增加双击操作时的鼠标位置识别处理 sj add
            if (dvStruct.dblclickFlag.winNo != 16) {
                dvStruct.whereIsMouse = dvStruct.viewer.getWinByNo(dvStruct.dblclickFlag.winNo);
            }
            else {
                var No = dvStruct.viewer.col * (rows - 1) + cols - 1;
                dvStruct.whereIsMouse = dvStruct.viewer.getWinByNo(No);
            }
        }
    });
    $node.on('mouseleave', function (e) {
        dvStruct.whereIsMouse = undefined;
    });
}

//翻页---------------规则参考chafey，鼠标在那上面就翻页上面的
dvStruct.fun.nextPage = function () {
    if (dvStruct.viewer.scrollAll) {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            dvStruct.fun.elementPaging(arr[i]);
        }
    } else {
        var win = dvStruct.whereIsMouse;
        dvStruct.fun.elementPaging(win);
        dvStruct.fun.synPagingCheck(win);
    }
};
dvStruct.fun.prevPage = function () {
    if (dvStruct.viewer.scrollAll) {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            dvStruct.fun.elementPaging(arr[i], 'prev');
        }
    } else {
        var win = dvStruct.whereIsMouse;
        dvStruct.fun.elementPaging(win, 'prev');
        dvStruct.fun.synPagingCheck(win);
    }
};
dvStruct.fun.elementPaging = function (win, type) {

    if (_.isObject(win)) {
        var winLen=win.col * win.row;
        var arrLen=win.wrappers[0].stack.imageIds.length;
        var curentImageIndex1=win.wrappers[0].stack.currentImageIdIndex;
        var curentImageIndex4=win.wrappers[winLen-1].stack.currentImageIdIndex;


        if(type=='prev'){
            if(curentImageIndex1==0){
                return false;
            }
        }
        else{
            if(curentImageIndex4==arrLen-1){
                return false;
            }
        }
        // var multiImg=false;
     /*   for (var i = 0,count=0; i < winLen; i++){
            var wrapper = win.wrappers[i];
            var stack = wrapper.stack;
            var len = stack.imageIds.length;//图像数
            if (len > 0)
                count++;
            if(count>1){
                multiImg=true;
                break;
            }
        }*/


        for (var i = 0 ; i < winLen; i++) {
            var wrapper = win.wrappers[i];
            var stack = wrapper.stack;
            // var len = stack.imageIds.length;//图像数
            if (arrLen > 0) {
                if(winLen>1){
                    //old  循环
                    if(type=='prev'){
                        // if(parseInt(curentImageIndex1)==0)
                        //     break;
                        if(stack.currentImageIdIndex<=0){
                            stack.currentImageIdIndex = arrLen-1;
                        }else{
                            stack.currentImageIdIndex--;
                        }
                    }else{
                        // if(parseInt(curentImageIndex4)==len-1)
                        //     break;
                        if(stack.currentImageIdIndex<arrLen-1){
                            stack.currentImageIdIndex++;
                        }else{
                            stack.currentImageIdIndex=0;
                        }
                    }
                }
                else {
                    //new 不循环
                    if (type == 'prev') {
                        if (stack.currentImageIdIndex <= 0) {
                            stack.currentImageIdIndex = 0;
                        } else {
                            stack.currentImageIdIndex--;
                        }
                    } else {
                        if (stack.currentImageIdIndex < arrLen - 1) {
                            stack.currentImageIdIndex++;
                        } else {
                            stack.currentImageIdIndex = arrLen - 1;
                        }
                    }
                }
                var imageId = stack.imageIds[stack.currentImageIdIndex];
                cornerstone.loadImage(imageId).then(function (image) {
                    cornerstone.displayImage(wrapper.element, image);
                });
            }
        }
    }
};
dvStruct.fun.synPagingCheck = function (win) {
    if (dvStruct.synposition.enable) {
        var wrapper = win.wrappers[0];
        var stack = wrapper.stack;
        var imageId = stack.imageIds[stack.currentImageIdIndex];
        dvStruct.synposition.findAndSyn(imageId, wrapper);
    }
};

//播放 ---------- 规则参考chafey，简单粗暴
dvStruct.playSpeed = 2;//framesPerSecond       1000/framesPerSecond
dvStruct.isplaying = false;
dvStruct.savedPlaying = [];//改变速度的时候的缓存   -------  实际上暂时并没用
dvStruct.fun.play = function (useSave) {
    if (useSave && dvStruct.savedPlaying.length > 0) {
        for (var i = 0,len1=dvStruct.savedPlaying.length; i < len1; i++) {
            cornerstoneTools.diy.winPlayClip(dvStruct.savedPlaying[i], dvStruct.playSpeed);
        }
    } else {
        var checkedWin = dvStruct.viewer.getCheckedWin();

        if (checkedWin) {
            //播放也是序列内部联动的
            cornerstoneTools.diy.winPlayClip(checkedWin, dvStruct.playSpeed);//自写函数
            dvStruct.savedPlaying.push(checkedWin);
        } else {
            var arr = dvStruct.viewer.winArr;
            var len = dvStruct.viewer.col * dvStruct.viewer.row;
            for (var i = 0; i < len; i++) {
                cornerstoneTools.diy.winPlayClip(arr[i], dvStruct.playSpeed);
                dvStruct.savedPlaying.push(arr[i]);
            }
        }
    }
    dvStruct.isplaying = true;
};
//-----停止----没啥好想的，全部停止 -------  方便 --------免得改布局的时候还要各种判断
dvStruct.fun.stop = function (notCancelSave) {
    var arr = dvStruct.viewer.winArr;
    var len = dvStruct.viewer.col * dvStruct.viewer.row;
    for (var i = 0; i < len; i++) {
        cornerstoneTools.diy.winStopClip(arr[i]);
    }
    dvStruct.isplaying = false;
    if (!!!notCancelSave) {
        dvStruct.savedPlaying = [];
    }
};
//停止当前的
dvStruct.fun.stopCurrent = function (winNo) {
    var arr = dvStruct.viewer.winArr;
    cornerstoneTools.diy.winStopClip(arr[winNo]);
    dvStruct.isplaying = false;
};
//----------------------------------------
//目前还只有全部反显
dvStruct.fun.invert = function () {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        //反显只有一个就是了
        var wrapper = checkedWin.wrappers[0];
        if (wrapper.stack.imageIds.length > 0) {
            dvStruct.fun.invertEle(wrapper.element);
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            //有联动
            var wrapper = arr[i].wrappers[0];
            if (wrapper.stack.imageIds.length > 0) {
                dvStruct.fun.invertEle(wrapper.element);
            }
        }
    }
}

dvStruct.fun.invertEle = function (element) {
    var viewport = cornerstone.getViewport(element);
    if (viewport) {
        if (viewport.invert === true) {
            viewport.invert = false;
        } else {
            viewport.invert = true;
        }
        cornerstone.setViewport(element, viewport);
    }
}

dvStruct.fun.fake = function () {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                dvStruct.fun.fakeEle(wrapper.element);
            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    dvStruct.fun.fakeEle(wrapper.element);
                }
            }
        }
    }
}

dvStruct.fun.reset = function () {
    // console.log("重置========================");
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (!!checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                cornerstone.reset(wrapper.element);

                    var rulerInfo=JSON.parse($(wrapper.element).parent().attr('rulerInfo'));
                    // console.log("1======reset==========");
                    // console.log(rulerInfo);
                    drawRuler($(wrapper.element).parent(),rulerInfo,1);


            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    cornerstone.reset(wrapper.element);
                    var rulerInfo=JSON.parse($(wrapper.element).parent().attr('rulerInfo'));
                    // console.log("2=======reset=========");
                    // console.log(rulerInfo);
                      drawRuler($(wrapper.element).parent(),rulerInfo,1);
                }
            }
        }
    }
}

dvStruct.fun.wwwc = function (ww, wc) {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                var viewport = cornerstone.getViewport(wrapper.element);
                viewport.voi.windowWidth = ww;
                viewport.voi.windowCenter = wc;
                cornerstone.setViewport(wrapper.element, viewport);
            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    var viewport = cornerstone.getViewport(wrapper.element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(wrapper.element, viewport);
                }
            }
        }
    }
}

dvStruct.fun.fakeEle = function (element) {
    var viewport = cornerstone.getViewport(element);
    if (viewport) {//console.log(viewport.fakeColor );
        if (viewport.fakeColor === true) {
            viewport.fakeColor = 'printBack';
        } else {
            viewport.fakeColor = true;
        }
        cornerstone.setViewport(element, viewport);
    }
};

//dvStruct.fun.delLastMeasurement = function(){
//    var checkedWin  = dvStruct.viewer.getCheckedWin();
//    if(checkedWin){
//        var wrapper = checkedWin.wrappers[0];
//        if(wrapper.stack.imageIds.length>1){
//            cornerstoneTools.delLastMeasurement(wrapper.element,'length');
//            cornerstone.updateImage(wrapper.element);
//        }
//    }
//}
dvStruct.fun.clearToolState = function () {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                var element = wrapper.element;
                try {
                    cornerstoneTools.clearToolState(element, "length");
                    cornerstoneTools.clearToolState(element, "probe");
                    cornerstoneTools.clearToolState(element, "rectangleRoi");
                    cornerstoneTools.clearToolState(element, "ellipticalRoi");
                    cornerstoneTools.clearToolState(element, "length");
                    cornerstoneTools.clearToolState(element, "angle");
                    cornerstoneTools.clearToolState(element, "simpleAngle");
                    cornerstoneTools.clearToolState(element, "heartScale");
                    cornerstoneTools.clearToolState(element, "twolines");

                } catch (e) {
                    console.error(e);
                }
                cornerstone.updateImage(element);
            }
        }
    }
};

//旋转---------cornerstione的作者的设计，是带不了旋转的，旋转只能90度转，画线才没得问题
dvStruct.fun.rotate = function () {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                var viewport = cornerstone.getViewport(wrapper.element);
                viewport.rotation = (viewport.rotation + 90) % 360;
                cornerstone.setViewport(wrapper.element, viewport);
            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    var viewport = cornerstone.getViewport(wrapper.element);
                    viewport.rotation = (viewport.rotation + 90) % 360;
                    cornerstone.setViewport(wrapper.element, viewport);
                }
            }
        }
    }
}

//sj add
//旋转---------cornerstione的作者的设计，是带不了旋转的，旋转只能90度转，画线才没得问题
dvStruct.fun.rotate2 = function () {
    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                var viewport = cornerstone.getViewport(wrapper.element);
                viewport.rotation = (viewport.rotation - 90) % 360;
                cornerstone.setViewport(wrapper.element, viewport);
            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    var viewport = cornerstone.getViewport(wrapper.element);
                    viewport.rotation = (viewport.rotation - 90) % 360;//左旋
                    cornerstone.setViewport(wrapper.element, viewport);
                }
            }
        }
    }
}
//sj add end
//----------翻转---------------------------------
dvStruct.fun.rev = function (direct) {

    var direct = direct || 'h';

    var checkedWin = dvStruct.viewer.getCheckedWin();
    if (checkedWin) {
        var len = checkedWin.wrappers.length;
        for (var i = 0; i < len; i++) {
            var wrapper = checkedWin.wrappers[i];
            if (wrapper.stack.imageIds.length > 0) {
                var viewport = cornerstone.getViewport(wrapper.element);
                var changeFlag = false;
                if (viewport.rotation == 90 || viewport.rotation == -90 || viewport.rotation == 270 || viewport.rotation == -270) {
                    changeFlag = true;
                }
                if (direct == 'h') {
                    if (changeFlag) {
                        viewport.vflip = !viewport.vflip;
                    }
                    else {
                        viewport.hflip = !viewport.hflip;
                    }


                } else {
                    if (changeFlag) {
                        viewport.hflip = !viewport.hflip;
                    }
                    else {
                        viewport.vflip = !viewport.vflip;
                    }
                }
                cornerstone.setViewport(wrapper.element, viewport);
            }
        }
    } else {
        var arr = dvStruct.viewer.winArr;
        var len = dvStruct.viewer.col * dvStruct.viewer.row;
        for (var i = 0; i < len; i++) {
            for (var j = 0 ,len2=arr[i].wrappers.length; j < len2; j++) {
                var wrapper = arr[i].wrappers[j];
                if (wrapper.stack.imageIds.length > 0) {
                    var viewport = cornerstone.getViewport(wrapper.element);
                    var changeFlag = false;
                    if (viewport.rotation == 90 || viewport.rotation == -90 || viewport.rotation == 270 || viewport.rotation == -270) {
                        changeFlag = true;
                    }
                    if (direct == 'h') {
                        if (changeFlag) {
                            viewport.vflip = !viewport.vflip;
                        }
                        else {
                            viewport.hflip = !viewport.hflip;
                        }


                    } else {
                        if (changeFlag) {
                            viewport.hflip = !viewport.hflip;
                        }
                        else {
                            viewport.vflip = !viewport.vflip;
                        }
                    }
                    /* if(direct=='h') {
                     viewport.hflip = !viewport.hflip;
                     }else{
                     viewport.vflip = !viewport.vflip;
                     }*/
                    cornerstone.setViewport(wrapper.element, viewport);
                }
            }
        }
    }
};


/*
 * 转到指定图像索引
 * 索引位置为该序列所在比例位置
 * */
dvStruct.fun.goToIndex = function (scale) {
    var win = dvStruct.whereIsMouse;
    dvStruct.fun.elementPaging(win);
    dvStruct.fun.synPagingCheck(win);

    if (_.isObject(win)) {
        for (var i = 0,len=win.col * win.row; i < len; i++) {
            var wrapper = win.wrappers[i];
            var stack = wrapper.stack;
            var len = stack.imageIds.length;
            var imgIndex = parseInt(len * scale);
            // console.log("图像索引："+imgIndex);
            if (len > 0) {
                if (imgIndex <= 0) {
                    stack.currentImageIdIndex = 0;
                }
                else if (imgIndex >= len) {
                    stack.currentImageIdIndex = len - 1;
                } else {
                    stack.currentImageIdIndex = imgIndex;
                }
                var imageId = stack.imageIds[stack.currentImageIdIndex];
                cornerstone.loadImage(imageId).then(function (image) {
                    cornerstone.displayImage(wrapper.element, image);
                });
            }
        }
    }
}





/**
 * Created by admin on 2016/3/29.
 */
var unit = {};
unit.mask = {
    getMask: (function () {
        var maskDiv;
        return function () {
            return maskDiv || (function () {
                    $(document.body).append('<div id="unitMask"></div>');
                    return maskDiv = document.getElementById('unitMask');
                })();
        };
    })(),
    show: function () {
        var mask = this.getMask();
        $(mask).show();
    },
    hide: function () {
        var mask = this.getMask();
        $(mask).hide();
    }
};

function layoutSelectorBuilder(col, row, idName) {
    var obj = {
        cols: col, rows: row,
        layoutSelector: undefined,
        getLayoutSelector: (function () {
            return function () {
                return obj.layoutSelector || (function () {
                        var o = obj;
                        var w = o.cols * 23 + 4;
                        var h = o.rows * 23 + 4;
                        var html = '<div style="height:' + h + 'px;width:' + w + 'px;visibility: hidden" id="' + idName + '">';
                        for (var i = 0,len=o.cols * o.rows; i < len; i++) {
                            if (i % o.cols == 0) {
                                html += '<div class="urow">';
                            }
                            html += '<div class="ucol" colNum=' + (i % o.cols + 1) + ' rowNum=' + (parseInt(i / o.cols) + 1) + ' ></div>';
                            if (i % o.cols == o.cols - 1) {
                                html += '</div>';
                            }
                        }
                        html += '</div>';
                        $(document.body).append(html);
                        return obj.layoutSelector = document.getElementById(idName);
                    })();
            };
        })(),
        show: function (place, type) {
            unit.mask.show();
            var layoutSelector = this.getLayoutSelector();
            if (type == 'left') {
                var w = $(layoutSelector).width();
                var y = place.y;
                var x = place.x - w;
            } else {
                var y = place.y;
                var x = place.x;
            }
            $(layoutSelector).css({
                top: y + 'px',
                left: x + 'px'
            });
            $(layoutSelector).css('visibility', 'visible');
            this.onSelecting();
        },
        hide: function () {
            var layoutSelector = this.getLayoutSelector();
            $(layoutSelector).css('visibility', 'hidden');
            unit.mask.hide();
        },
        onSelecting: function () {
            var _this = this;
            $(document.body).on('mousemove', function (e) {
                _this.getNowColAndRow(e);
            });
            $(document.body).on('mousedown', function (e) {
                $(document.body).off('mousedown');
                $(document.body).off('mousemove');
                _this.endSelecting(e);
            });
        },
        endSelecting: function (e) {
            this.hide();
            var layout = this.getNowColAndRow(e);
            if (layout.col != 0 && layout.row != 0) {
                this.callback(layout);
            }
        },
        getNowColAndRow: function (e) {
            var layoutSelector = this.getLayoutSelector();
            var ofs = $(layoutSelector).offset();
            var x = e.pageX, y = e.pageY;
            //样式
            var col = 0, row = 0;
            $(layoutSelector).find('.ucol').each(function () {
                var ofs = $(this).offset();
                if (x > ofs.left && y > ofs.top) {
                    $(this).addClass('lighten');
                    var colNum = parseInt($(this).attr('colNum'));
                    var rowNum = parseInt($(this).attr('rowNum'));
                    if (colNum > col)col = colNum;
                    if (rowNum > row)row = rowNum;
                } else {
                    $(this).removeClass('lighten');
                }
            });
            var layoutObj = {col: col, row: row};
            return layoutObj;
        },
        callback: function () {/* 把选中的col row传过去 */
        }
    }
    return obj;
}

unit.layoutSelector = layoutSelectorBuilder(4, 4, 'unitLayoutSelector');

unit.layoutSelector.callback = function (layoutObj) {
    // console.log(layoutObj);
    dvStruct.viewer.col = layoutObj.col;
    dvStruct.viewer.row = layoutObj.row;
    dvStruct.dvResize.call(dvStruct.container);
};

unit.innerLayoutSelector = layoutSelectorBuilder(2, 2, 'unitInnerLayoutSelector');

unit.innerLayoutSelector.callback = function (layoutObj) {
    // console.log(layoutObj);
    var win = dvStruct.viewer.getCheckedWin();//console.log(win);
    if (_.isObject(win)) {
        win.col = layoutObj.col;
        win.row = layoutObj.row;
        var size = dvStruct.viewer.calInnerEachSize(win.winId);
        //内容改变
        dvStruct.viewer.resizeWin(win);
        //大小
        $('#' + win.winId).find('.viewportWrapper').css({
            'height': size[1] + 'px',
            'width': size[0] + 'px'
        }).each(function () {
            // console.log($(this).find('.viewport').get(0));
            cornerstone.resize($(this).find('.viewport').get(0), true);
            var rulerInfo=JSON.parse($(this).attr('rulerInfo'));
         //  $(this).attr('rulerInfo',JSON.stringify(rulerInfo));
         //    console.log(rulerInfo);
            drawRuler($(this),rulerInfo,1);
        });
    }
};

unit.quickWWWL = {
    ceils: [
        {ww: 90, wc: 35, name: '头颅平扫'},
        {ww: 85, wc: 40, name: '头颅增强'},
        {ww: 1600, wc: 450, name: '头颅骨窗'},
        {ww: 1600, wc: 550, name: '关节骨窗'},
        {ww: 300, wc: 40, name: '关节软组织窗'},
        {ww: 2000, wc: 450, name: '鼻窦骨窗'},
        {ww: 350, wc: 35, name: '鼻窦软组织窗'},
        {ww: 4000, wc: 650, name: '乳突'},
        {ww: 2000, wc: 450, name: '椎间盘骨窗'},
        {ww: 350, wc: 40, name: '椎间盘软组织窗'},
        {ww: 1000, wc: -650, name: '肺窗'},
        {ww: 1500, wc: -600, name: '肺窗2'},
        {ww: 350, wc: -40, name: '纵隔窗1'},
        {ww: 430, wc: 55, name: '纵隔窗2'},
        {ww: 200, wc: 50, name: '肝脏'},
        {ww: 350, wc: 40, name: '肾脏'},
        {ww: 300, wc: 55, name: '肾脏'}
    ],
    savedStatus: {
        beginOfsX: 0,
        beginOfsY: 0,
        prevPageX: undefined,
        prevPageY: undefined
    },
    //container:dvStruct.container,
    wwwlBoxIni: function (quickWWWLBox) {
        $(quickWWWLBox).find('.closeBtn').on('mousedown', function (e) {
            unit.quickWWWL.hide();
            e.stopPropagation();
        });
        $(quickWWWLBox).find('.topbar').on('mousedown', function () {
            //绑定拖拽
            $(document.body).on('mousemove', function (e) {
                var x = e.pageX, y = e.pageY;
                var savedStatus = unit.quickWWWL.savedStatus;
                if (!_.isUndefined(savedStatus.prevPageX) && !_.isUndefined(savedStatus.prevPageY)) {
                    var newx = savedStatus.beginOfsX + x - savedStatus.prevPageX;
                    var newy = savedStatus.beginOfsY + y - savedStatus.prevPageY;
                    $(quickWWWLBox).css({
                        top: newy + 'px',
                        left: newx + 'px',
                        right: 'auto',
                        bottom: 'auto'
                    });
                    savedStatus.beginOfsX = newx;
                    savedStatus.beginOfsY = newy;
                }
                savedStatus.prevPageX = x;
                savedStatus.prevPageY = y;
            });
            $(document.body).on('mouseup mouseleave', function (e) {
                $(document.body).off('mousedown');
                $(document.body).off('mousemove');
                var savedStatus = unit.quickWWWL.savedStatus;
                savedStatus.prevPageX = undefined;
                savedStatus.prevPageY = undefined;
            });
        });
        $(quickWWWLBox).find('.ceilBox').click(function (e) {
            var ele = e.target;
            if ($(ele).hasClass('aCeil')) {
                var ww = parseInt($(ele).attr('ww'));
                var wc = parseInt($(ele).attr('wc'));
                $(quickWWWLBox).find('.wwVal').val(ww);
                $(quickWWWLBox).find('.wcVal').val(wc);
            }
            e.stopPropagation();
        });
        $(quickWWWLBox).find('.yes').click(function () {
            var ww = parseInt($(quickWWWLBox).find('.wwVal').val());
            var wc = parseInt($(quickWWWLBox).find('.wcVal').val());
            if (!isNaN(ww) && !isNaN(wc))dvStruct.fun.wwwc(ww, wc);
        });
    },
    getWWWLBox: (function () {
        var quickWWWLBox;
        return function () {
            return quickWWWLBox || (function () {
                    var html = '<div id="quickWWWLBox">';
                    html += '<div class="topbar"  style=" -webkit-user-select: none; -webkit-user-drag: none;touch-action: none;" ><div class="closeBtn">✖</div></div>';
                    html += '<div class="calBox"  style=" -webkit-user-select: none; -webkit-user-drag: none;touch-action: none;">';
                    html += '<div class="inputArea">窗位:&ensp;<input class="wcVal"></div>';
                    html += '<div class="inputArea">窗宽:&ensp;<input class="wwVal"></div>';
                    html += '<div class="yes">确定</div>';
                    html += '</div>';
                    html += '<div class="ceilBox"></div>';
                    html += '</div>';
                    $(dvStruct.container).append(html);
                    quickWWWLBox = document.getElementById('quickWWWLBox');
                    for (var i = 0,len=unit.quickWWWL.ceils.length; i < len; i++) {
                        var ceil = unit.quickWWWL.ceils[i];
                        $(quickWWWLBox).find('.ceilBox').append('<div class="aCeil" ww="' + ceil.ww + '" wc="' + ceil.wc + '" >' + ceil.name + '</div>');
                    }
                    unit.quickWWWL.wwwlBoxIni(quickWWWLBox);
                    return quickWWWLBox;
                })();
        };
    })(),
    show: function () {
        unit.mask.show();
        var quickWWWLBox = unit.quickWWWL.getWWWLBox();
        $(quickWWWLBox).css({
            top: 0, left: 0, right: 0, bottom: 0
        });
        $(quickWWWLBox).show();
        var savedStatus = unit.quickWWWL.savedStatus;
        var ofs = $(quickWWWLBox).offset();
        savedStatus.beginOfsX = ofs.left;
        savedStatus.beginOfsY = ofs.top;
        savedStatus.prevPageX = undefined;
        savedStatus.prevPageY = undefined;
    },
    hide: function () {
        unit.mask.hide();
        var quickWWWLBox = unit.quickWWWL.getWWWLBox();
        $(quickWWWLBox).hide();
    }
};
unit.loadingProcessing = {
    failedUrls: [],
    getProcessiong: (function () {
        var processingBox;
        return function () {
            return processingBox || (function () {
                    var html = '<div id="processingBox" style="display: none"  class="processingBox">';
                    html += '<div class="js-hide hidebtn" style="display: none"><span>✖</span></div>';
                    html += '<div class="failed" style="display: none">失败：<span class="failedNum"></span>&ensp;<span class="tryAgain">重试</span></div>';
                    html += '<div class="loadingTxt" >正在加载:<span class="now">0</span>/<span class="max"></span></div>';
                    html += '<div class="processing">';
                    html += '<div class="progress progress-striped active"><div class="progress-bar "  role="progressbar" style="width:0"></div></div>'
                    html += '</div>';
                    html += '</div>';
                    $('.leftGallery').append(html);

                    processingBox = document.getElementById('processingBox');

                    $(processingBox).find('.tryAgain').click(function () {
                        var maxNum = unit.loadingProcessing.failedUrls.length;
                        var arr = unit.loadingProcessing.failedUrls.concat();
                        unit.loadingProcessing.failedUrls = [];
                        unit.loadingProcessing.finished = 0;
                        $(processingBox).find('.js-hide').hide();
                        $(processingBox).find('.loadingTxt').show();
                        $(processingBox).find('.failed').hide();
                        unit.loadingProcessing.init(maxNum);
                        for (var i = 0; i < maxNum; i++) {
                            io.Url.load(arr[i]);
                        }
                    });
                    $(processingBox).find('.js-hide').click(function () {
                        $(processingBox).hide();
                    });
                    return processingBox;
                })();
        };
    })(),
    maxNum: 0, finished: 0,
    clear: function () {
        this.maxNum = 0;
        this.finished = 0;
        this.success = 0;
        var node = this.getProcessiong();
        $(node).hide();
    },
    updateProcessing: function (failedUrl) {

        if (failedUrl) {
            this.failedUrls.push(failedUrl);
        } else {
            this.finished++;
            var w = parseInt(this.finished / this.maxNum * 100);
            var processingBox = this.getProcessiong();
            $(processingBox).find('.now').text(this.finished);
            $(processingBox).find('.progress-bar').css('width', w + '%');
        }
        if (this.finished + this.failedUrls.length == this.maxNum) {
            this.end();
        }
    },
    end: function () {
        var processingBox = this.getProcessiong();
        if (this.failed > 0) {
            $(processingBox).find('.js-hide').show();
            $(processingBox).find('.loadingTxt').hide();
            $(processingBox).find('.failed').show().find('.failedNum').text(this.failedUrls.length);
        } else {
            $(processingBox).hide();
            //初始快捷调窗信息
            setTimeout(function () {
                // callFlaw();//数据解冻
                //初始快捷调窗信息
                // dvStruct.userCode='gly';
                if(dvStruct.userCode!=undefined&&dvStruct.userCode!=null){
                    if (dvStruct.userCode.length > 0) {
                        getModality();
                        if (Modality != "none") {
                           
                            wwwlShow(Modality, dvStruct.userCode);
                            $('.device').val(Modality);
                            typeChange(dvStruct.userCode);
                        }
                    }

                }
                if(dvStruct.hospitalCode!=undefined&&dvStruct.hospitalCode!=null){
                    if (dvStruct.hospitalCode.length > 0) {
                        var code = dvStruct.hospitalCode;
                        showPrintInfo(code);
                        initinfoScreenArr(code);
                    }
                }

                if(dvStruct.hospitalCode!=undefined&&dvStruct.hospitalCode!=null) {
                   // console.log("dovr0000000000000000000002222222222222222222220000000000");
                   // doVR();//三维服务
                }

                /*加载完后汉化，优化为边加载边汉化*/
               // translate2Chinese();//汉化
                btnShowCheck();//检查按钮的显示与否
                // callPrinter();//图像加载完后显示打印页面，是否要剥离出来？
            }, 100);
        }
    }
    ,
    init: function (max) {
        this.maxNum = parseInt(max);
        if (this.maxNum > 0) {
            var processingBox = this.getProcessiong();
            $(processingBox).find('.progress-bar').width(0);
            $(processingBox).find('.max').text(this.maxNum);
            $(processingBox).show();
        }
    }
};

unit.speedSlider = {
    ini: function () {
        var node = this.getSliderBox();
        var rangebar = $(node).find('.rangeBar').get(0);
        noUiSlider.create(rangebar, {
            start: [10], snap: true,
            range: {
                'min': 1,//1000
                '15%': 2,//500
                '25%': 4,//250
                '35%': 8,//125
                '50%': 10,//100
                '65%': 20,//50
                '75%': 25,//40
                '85%': 50,//20
                'max': 100//10
            }
        });
        rangebar.noUiSlider.on('update', function (values, handle) {
            // console.log(values[handle]);
            if (dvStruct.isplaying) {
                dvStruct.playSpeed = parseInt(values[handle]);
                dvStruct.fun.stop();
                dvStruct.fun.play();
            }
        });
    },
    getSliderBox: function () {
        return document.getElementById('playSpeedSet');
    },
    show: function () {
        $(unit.mask.getMask()).on('click', function (e) {
            unit.speedSlider.hide();
            e.preventDefault();
        });
        var box = this.getSliderBox();
        unit.mask.show();
        $(box).show();
    },
    hide: function () {
        $(this.getSliderBox()).hide();
        unit.mask.hide();
        $(unit.mask.getMask()).off('click');
    }
};
//unit.config = {};



/**
 * Created by admin on 2016/3/28.
 */

//dicom转换
function dicomLocalCovert(res,callback){

    //解析dicom
    var dicomPart10AsArrayBuffer = res;
    var byteArray = new Uint8Array(dicomPart10AsArrayBuffer);
    var dataSet = dicomParser.parseDicom(byteArray);
    if(!dataSet){alert('解析失败');return undefined;}
    //console.log(dataSet);
    //提取dicom信息
    var infoSet = getDicomInfo(dataSet);//console.log(infoSet);

    callback(dataSet);
    var imgObj = createNewImageObject(dataSet);dvStruct.imgObjArr.push(imgObj);
    return {dataSet:dataSet,infoSet:infoSet,imageId:imgObj.imageId,iid:infoSet.InstanceInfo.InstanceNumber.val};
}
function dicomLocalCoverUint8(byteArray,callback){
    var dataSet = dicomParser.parseDicom(byteArray);
    if(!dataSet){alert('解析失败');return undefined;}
    var infoSet = getDicomInfo(dataSet);//console.log(infoSet);

    callback(dataSet);
    var imgObj = createNewImageObject(dataSet);dvStruct.imgObjArr.push(imgObj);
    return {dataSet:dataSet,infoSet:infoSet,imageId:imgObj.imageId,iid:infoSet.InstanceInfo.InstanceNumber.val};
}

function getDicomInfo(dataSet) {
    var infoSet = {};
    var encodeWay = dataSet.string('x00080005');//这个就是Specific Character Set
    encodeWay = encodeWay ? encodeWay.toUpperCase() : undefined;
    // console.log('encodeWay', encodeWay);
    // console.log(dataSet);
    //奇葩事件记录  ISO_IR 100 可以识别却不可以解 iso-ir-100别名CP819 latin1 ISO_8859-1  GB18030也是可以解。。。。用 CP936也可以解 。。。也就是说，编码是中文，但是机器没改。。就是卧了个槽，话说这是日本人的编码吧，喔日本人
    //有了上面的事件，所以先做一个匹配度判断，能匹配的直接国标了
    if(encodeWay=='ISO_IR 192'||encodeWay=='ISO 10646-1'||encodeWay=='ISO 10646-2'){//UTF-8 ----
        infoDecode(dataSet, infoSet,'UTF-8');//但是用utf-8解出来都是数呢
        return infoSet;
    }else{
        if (_.isObject(jschardet)) {//这个的代价比较大，三百多k啊
            if (encodeWay && encodeWay.indexOf('GB') < 0) {
                var patientName = dataSet.string('x00100010');
                var institutionName = dataSet.string('x00080080');
                var studyDescription = dataSet.string('x00081030');
                var eo = jschardet.detect(patientName + institutionName + studyDescription);
                if (_.isObject(eo) && eo.confidence > 0.5) {
                    encodeWay = eo.encoding.toUpperCase();
                } else {//识别也可能不准，外国文字？？马蛋外国的就不管了---以后大不了地区判断
                    console.log(eo);
                    encodeWay = 'GB18030';
                }
            }
        } else {
            encodeWay = 'GB18030';//直接暴力用国标
        }
    }
    if (encodeWay && iconvForUse.encodingExists(encodeWay)) {//判断编码存在
        // console.log('exsit', iconvForUse.encodingExists(encodeWay));
        infoDecode(dataSet, infoSet, encodeWay);
    } else if (encodeWay && encodeWay.indexOf('GB') > -1) {//避免万一出现gb2313这种操蛋的情况
        encodeWay = 'GB18030';
        infoDecode(dataSet, infoSet, encodeWay);
    } else {
        console.log('没有特别编码  或者为 不能识别的编码方式');//console.log('encodeWay:',encodeWay);console.log( dataSet.string('x00080005'));
        //infoDecode(dataSet,infoSet,'');
        encodeWay = 'GB18030';//马蛋，居然有不带的，那就这样搞了
        infoDecode(dataSet, infoSet, encodeWay);
    }
    return infoSet;
}

//信息解析
function infoDecode(dataSet,infoSet,encodeWay){
    //信息组织  ----  data-dicom ---- 字符串处理    -----data-dicomUint---- 用length再怎么怎么滴 这里参考Chris Hafey的dragAndDropParse
    infoSet.PatientInfo = {
        PatientName:{
            tag:'x00100010',
            val:'',des:'',type:'data-dicom'
        },
        PatientID:{
            tag:'x00100020',
            val:'',des:'',type:'data-dicom'
        },
        PatientBirthDate:{
            tag:'x00100030',
            val:'',des:'',type:'data-dicom'
        },
        PatientBirthTime:{
            tag:'x00100032',
            val:'',des:'',type:'data-dicom'
        },
        PatientsAge:{
            tag:'x00101010',val:'',des:'',type:'data-dicom'
        },
        PatientSex:{
            tag:'x00100040',
            val:'',des:'',type:'data-dicom'
        },
        PatientWeight:{
            tag:'x00101030',
            val:'',des:'',type:'data-dicom'
        },
        PregnancyStatus:{//怀孕状态
            tag:'x001021c0',
            val:'',des:'',type:'data-dicom'
        },
        AccessionNumber:{
            tag:'x00080050',
            val:'',des:'',type:'data-dicom'
        },
        PatientPosition:{//病人位置   HFP头在前俯卧，HFS头在前仰卧
            tag:'x00185100',
            val:'',des:'',type:'data-dicom'
        },
    };
    infoSet.StudyInfo = {
        StudyDescription:{//描述
            tag:'x00081030',
            val:'',des:'',type:'data-dicom'
        },
        ProtocolName:{
            tag:'x00181030',
            val:'',des:'',type:'data-dicom'
        },
        Accession:{
            tag:'x00080050',
            val:'',des:'',type:'data-dicom'
        },
        StudyId:{
            tag:'x00200010',
            val:'',des:'',type:'data-dicom'
        },
        StudyDate:{//检查日期
            tag:'x00080020',
            val:'',des:'',type:'data-dicom'
        },
        StudyTime:{
            tag:'x00080030',
            val:'',des:'',type:'data-dicom'
        },
        ModalitiesInStudy:{//一个检查中含有的不同检查类型.
            tag:'x00080061',
            val:'',des:'',type:'data-dicom'
        }
    };
    infoSet.SeriesInfo = {
        SeriesDescription:{
            tag:'x0008103e',
            val:'',des:'',type:'data-dicom'
        },
        SeriesNo:{
            tag:'x00200011',
            val:'',des:'',type:'data-dicom'
        },
        Modality:{
            tag:'x00080060',
            val:'',des:'',type:'data-dicom'
        },
        BodyPart:{//身体部位
            tag:'x00180015',
            val:'',des:'',type:'data-dicom'
        },
        SeriesDate:{
            tag:'x00080021',
            val:'',des:'',type:'data-dicom'
        },
        SeriesTime:{
            tag:'x00080031',
            val:'',des:'',type:'data-dicom'
        },
        SliceThickness:{//层厚 mm  T
            tag:'x00180050',
            val:'',des:'',type:'data-dicom'
        },
        SpacingBetweenSlices:{//层与层之间的间距,单位为mm   --------  这个也特么不建议使用 ---  不过本来就没有用
            tag:'x00180088',val:'',des:'',type:'data-dicom'
        },
        SliceLocation:{//实际的相对位置，单位为mm.  L?  ----------  有时会是空的？？  ----------  老外说，不要用这个，经常空的，而且错的
            tag:'x00201041',
            val:'',des:'',type:'data-dicom'
        },
        MRAcquisition:{
            tag:'x00180023',val:'',des:'',type:'data-dicom'
        },
        FlipAngle:{
            tag:'x00181314',val:'',des:'',type:'data-dicom'
        }
    };
    infoSet.InstanceInfo={
        InstanceNumber:{//实例码 识别图像的号码？
            tag:'x00200013',
            val:'',des:'',type:'data-dicom'
        },
        ContentDate:{//影像拍摄的日期.
            tag:'x00080023',
            val:'',des:'',type:'data-dicom'
        },
        ContentTime:{//影像拍摄的日期.
            tag:'x00080033',
            val:'',des:'',type:'data-dicom'
        },
        AcquisitionNumber:{
            tag:'x00200012',
            val:'',des:'',type:'data-dicom'
        },
        AcquisitionDate:{
            tag:'x00080022',
            val:'',des:'',type:'data-dicom'
        },
        AcquisitionTime:{
            tag:'x00080032',
            val:'',des:'',type:'data-dicom'
        }
    };
    infoSet.ImageInfo={
        Rows:{
            tag:'x00280010',
            val:'',des:'',type:'data-dicomUint'
        },
        Columns:{
            tag:'x00280011',
            val:'',des:'',type:'data-dicomUint'
        },
        PhotometricInterpretation:{//MONOCHROME1，MONOCHROME2.用来判断图像是否是彩色的，MONOCHROME1/2是灰度图，RGB则是真彩色图，还有其他.
            tag:'x00280004',
            val:'',des:'',type:'data-dicom'
        },
        ImageType:{
            tag:'x00080008',
            val:'',des:'',type:'data-dicom'
        },
        BitsAllocated:{
            tag:'x00280100',
            val:'',des:'',type:'data-dicomUint'
        },
        BitsStored:{
            tag:'x00280101',
            val:'',des:'',type:'data-dicomUint'
        },
        HighBit:{
            tag:'x00280102',
            val:'',des:'',type:'data-dicomUint'
        },
        PixelRepresentation:{
            tag:'x00280103',
            val:'',des:'',type:'data-dicomUint'
        },
        RescaleSlope:{
            tag:'x00281053',
            val:'',des:'',type:'data-dicom'
        },
        RescaleIntercept:{
            tag:'x00281052',
            val:'',des:'',type:'data-dicom'
        },
        ImagePositionPatient:{
            tag:'x00200032',
            val:'',des:'',type:'data-dicom'
        },
        ImageOrientationPatient:{
            tag:'x00200037',
            val:'',des:'',type:'data-dicom'
        },
        PixelSpacing:{
            tag:'x00280030',
            val:'',des:'',type:'data-dicom'
        },
        ImagerPixelSpacing:{//DR的像素值存放位置
            tag:'x00181164',
            val:'',des:'',type:'data-dicom'
        },
        SamplesPerPixel:{
            tag:'x00280002',
            val:'',des:'',type:'data-dicomUint'
        },
        WindowCenter:{
            tag:'x00281050',
            val:'',des:'',type:'data-dicomUint'
        },
        WindowWidth:{
            tag:'x00281051',
            val:'',des:'',type:'data-dicomUint'
        },
        RescaleType:{
            tag:'x00281054',
            val:'',des:'',type:'data-dicomUint'
        },
        FieldofView:{
            tag:'x00180094',
            val:'',des:'',type:'data-dicom'
        }
    };
    infoSet.EquipmentInfo={
        Manufacturer:{
            tag:'x00080070',
            val:'',des:'',type:'data-dicom'
        },
        Model:{
            tag:'x00081090',
            val:'',des:'',type:'data-dicom'
        },
        StationName:{
            tag:'x00081010',
            val:'',des:'',type:'data-dicom'
        },
        AETitle:{
            tag:'x00020016',
            val:'',des:'',type:'data-dicom'
        },
        InstitutionName:{
            tag:'x00080080',
            val:'',des:'',type:'data-dicom'
        },
        SoftwareVersion:{
            tag:'x00181020',
            val:'',des:'',type:'data-dicom'
        },
        ImplementationVersionNam:{
            tag:'x00020013',
            val:'',des:'',type:'data-dicom'
        }
    };
    infoSet.UIDS = {
        StudyUID:{
            tag:'x0020000d',
            val:'',des:'',type:'data-dicom'
        },
        SeriesUID:{
            tag:'x0020000e',
            val:'',des:'',type:'data-dicom'
        },
        InstanceUID:{
            tag:'x00080018',
            val:'',des:'',type:'data-dicom'
        },
        SOPClassUID:{
            tag:'x00080016',
            val:'',des:'',type:'data-dicom'
        },
        TransferSyntaxUID:{
            tag:'x00020010',
            val:'',des:'',type:'data-dicom'
        },
        FrameOfReferenceUID:{
            tag:'x00200052',
            val:'',des:'',type:'data-dicom'
        },
    };
    infoSet.SomeUsefulInfo = {
        MagneticFieldStrength:{
            tag:"x00180087",
            val:'',des:'',type:'data-dicom'
        },
        RepetitionTime:{
            tag:"x00180080",
            val:'',des:'',type:'data-dicom'
        },
        EchoTime:{
            tag:'x00180081',
            val:'',des:'',type:'data-dicom'
        },
        //sj add
        kvp:{
            tag:'x00180060' ,
            val:'',des:'',type:'data-dicom'
        },
        mA:{
            tag:'x00181151',
            val:'',des:'',type:'data-dicom'
        },
        ww:{
            tag:'x00281051',
            val:'',des:'',type:'data-dicom'
        },
        wc:{
            tag:'x00281050',
            val:'',des:'',type:'data-dicom'
        },
        minPixelValue:{
            tag:'x00280106',
            val:'',des:'',type:'data-dicom'
        },
        maxPixelValue:{
            tag:'x00280107',
            val:'',des:'',type:'data-dicom'
        }
        //sj add end
    };
    var others = {};
    for(var i in dataSet.elements){
        var tag = dataSet.elements[i].tag;
        var newInfo = true;
        for(var j in infoSet){
            var infoChildrenSet = infoSet[j];
            for(var k in infoChildrenSet){
                //console.log(infoChildrenSet[k].tag,tag);
                if(infoChildrenSet[k].tag==tag){
                    newInfo = false;break;
                }
            }
        }
        if(newInfo){
            others[i] = {
                tag:tag,
                val:'',des:'',type:'data-dicom'
            };
        }
    }
    //console.log(infoSet);
    infoSet.others = others;
    //翻译和取值
    try {
        for (var i in infoSet) {
            var infoChildrenSet = infoSet[i];
            for (var j in infoChildrenSet) {
                var info = infoChildrenSet[j];
                if (info.tag == 'x7fe00010')continue;//x7fe00010是数据
                matchDict(info);//字典匹配
                var tag = info.tag;
                if (info.type == 'data-dicom') {
                    var element = dataSet.elements[tag];
                    var text = "";
                    if (element !== undefined) {
                        var str = dataSet.string(tag);
                        if (str !== undefined) {
                            if (!encodeWay) {
                                text = str;
                            } else {
                                if (encodeWay == 'UTF-8') {
                                    text = iconvForUse.decode(str, encodeWay);
                                } else {
                                    //据说不推荐 但可以直接传str，因为并不是node后台，并没有Buffer.concat()
                                    //这个uint8Array试试，原理上应该是这个
                                    //x00020000 ，FileMetaInformationGroupLength,取出来前就是奇葩字符
                                    var b = new Uint8Array(str.length);
                                    for (var k = 0; k < b.length; k++) {
                                        var x = str.charCodeAt(k);
                                        b[k] = x;
                                    }
                                    //try {
                                    //console.log(b);
                                    text = iconvForUse.decode(b, encodeWay);
                                    //}catch(e){
                                    //    console.error(e);console.log(b,encodeWay);console.log(iconvForUse);
                                    //}
                                }
                            }
                        }
                    }
                    info.val = text;
                } else if (info.type == 'data-dicomUint') {
                    var element = dataSet.elements[tag];
                    var text = "";
                    if (element !== undefined) {
                        if (element.length === 2) {
                            text += dataSet.uint16(tag);
                        }
                        else if (element.length === 4) {
                            text += dataSet.uint32(tag);
                        }
                    }
                    info.val = text;
                }
            }
        }
    }catch(e){
        console.error('infoSet iconv error');
        console.error(e);
    }
}

//把里面的buffer拷贝出来改写成这个
Uint8Array.prototype.slice = function slice (start, end) {
    var len = this.length
    start = ~~start
    end = end === undefined ? len : ~~end

    if (start < 0) {
        start += len
        if (start < 0) start = 0
    } else if (start > len) {
        start = len
    }

    if (end < 0) {
        end += len
        if (end < 0) end = 0
    } else if (end > len) {
        end = len
    }

    if (end < start) end = start

    var newBuf
    if (Uint8Array.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Uint8Array.prototype
    } else {
        var sliceLen = end - start
        newBuf = new Uint8Array(sliceLen, undefined)
        for (var i = 0; i < sliceLen; i++) {
            newBuf[i] = this[i + start]
        }
    }

    if (newBuf.length) newBuf.parent = this.parent || this

    return newBuf
}

Uint8Array.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
    }

    var len = end - start
    var i

    if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; i--) {
            target[i + targetStart] = this[i + start]
        }
    } else if (len < 1000 || !Uint8Array.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; i++) {
            target[i + targetStart] = this[i + start]
        }
    } else {
        Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
        )
    }

    return len
}

//字典描述匹配
function matchDict(infoEle){
    var tag = infoEle.tag;
    if(tag){
        tag = '('+ tag.substr(1,4).toUpperCase()+','+tag.substr(5,4).toUpperCase() +')';
        if(TAG_DICT[tag]&&_.isObject(TAG_DICT[tag])){
            infoEle.des = TAG_DICT[tag].name;
        }
    }
}
/**
 * Created by admin on 2016/4/6.
 */

var io = io || {};
io.Url = {
    load:function(url,dO){
        console.log("url",url);
        console.log("do",dO);
        var xhrRequestPromise =  io.Url.xhrRequest(url,dO);
        console.log(xhrRequestPromise);
        return xhrRequestPromise;
    },
    xhrRequest:function(url,dO) {//参考cornerstone，但是1，没有deferred——因为有压缩文件，结果不止一个；2，不用imageId
        // Make the request for the DICOM P10 SOP Instance
        var deferred = $.Deferred();

        var xhr = new XMLHttpRequest();
        xhr.open("get", url, true);
        xhr.responseType = "arraybuffer";
        cornerstoneWADOImageLoader.internal.options.beforeSend(xhr);

        xhr.onreadystatechange = function (oEvent) {
            // TODO: consider sending out progress messages here as we receive the pixel data
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    // request succeeded, create an image object and resolve the deferred
                    // Parse the DICOM File
                    var dicomPart10AsArrayBuffer = xhr.response;
                    var urlArr = url.split('/');
                    var fname = urlArr[urlArr.length-1];
                    var infoAfterAnalysised = {};
                    commEventHandler.fireEvent({type:'dicomDownloaded',name:fname,data:dicomPart10AsArrayBuffer,infoAfterAnalysised:infoAfterAnalysised});
                   

                    var pos = url.lastIndexOf(".");
                    var ext =url.substring(pos,url.length);
                    unit.loadingProcessing.updateProcessing();
                    //后台传过来的是原文件或者一重zip
                    if (ext.toLowerCase() != ".zip" ){
                        var byteArray = new Uint8Array(dicomPart10AsArrayBuffer);
                        var dataSet = dicomParser.parseDicom(byteArray);
                        // console.log(dataSet);
                        if(_.isObject(dataSet)){
                            var imgObj = createNewImageObject(dataSet);
                            var infoSet = getDicomInfo(dataSet);
                            var dicom = {dataSet:dataSet,infoSet:infoSet,imageId:imgObj.imageId,iid:infoSet.InstanceInfo.InstanceNumber.val};
                            // console.log(imgObj);
                            //汉化begin
                            //检查描述
                            if(dO.CDes!=""&&dO.CDes!=undefined&&dO.CDes!=null){
                                dicom.infoSet.StudyInfo.StudyDescription.val=dO.CDes;
                            }
                            //检查机构
                            if(dO.CHos!=""&&dO.CHos!=undefined&&dO.CHos!=null){
                                dicom.infoSet.EquipmentInfo.InstitutionName.val=dO.CHos;
                            }
                            //患者性别
                            if(dO.sex!=""&&dO.sex!=undefined&&dO.sex!=null){
                                dicom.infoSet.PatientInfo.PatientSex.val=dO.sex;
                            }
                            //患者年龄
                            if(dO.age!=""&&dO.age!=undefined&&dO.age!=null){
                                dicom.infoSet.PatientInfo.PatientsAge.val=dO.age;
                            }
                            //患者姓名
                            if(dO.CPName!=""&&dO.CPName!=undefined&&dO.CPName!=null){
                                dicom.infoSet.PatientInfo.PatientName.val=dO.CPName;
                            }
                            //检查类型
                           /* if(dO.CModality.length>0){
                                dicom.infoSet.SeriesInfo.Modality.val=dO.CModality;
                            }*/

                            //study number


                            //汉化
                            if(dO.studynum!=""&&dO.studynum!=undefined&&dO.studynum!=null){
                                dicom.infoSet.PatientInfo.AccessionNumber.val=dO.studynum;
                            }

                            dvStruct.imgObjArr.push(imgObj);
                            // dicom= changeInfoType(dO,dicom);//替换信息
                            dvStruct.addDicom(dicom,infoAfterAnalysised);//infoAfterAnalysised是为了把序列与下载的dicom关联起来
                        }
                    }else{
                        var zip = new JSZip();
                        var zipPromise = zip.loadAsync(dicomPart10AsArrayBuffer);
                        zipPromise.then(function(zip){
                            for (var nameOfFileContainedInZipFile in zip.files)
                            {
                                var fileContainedInZipFile = zip.files[nameOfFileContainedInZipFile];
                                //console.log(fileContainedInZipFile);
                                //先判断类型，文件还是文件夹
                                if(fileContainedInZipFile.dir){
                                }else{
                                    dealUrlFile(zip,fileContainedInZipFile,infoAfterAnalysised);
                                }
                            }
                        });
                    }
                } else {
                    if(xhr.statusText=="Forbidden"){
                        // urlFlawArr.push(url);//链接保存到数组
                        callFlaw();//数据解冻处理
                    }

                    unit.loadingProcessing.updateProcessing(url);
                    // request failed, reject the deferred
                    deferred.reject(xhr.response);

                }
            }
        };

        xhr.onprogress = function (oProgress) {
            // console.log('progress:',oProgress)
            if (oProgress.lengthComputable) {  //evt.loaded the bytes browser receive
                //evt.total the total bytes seted by the header
                var loaded = oProgress.loaded;
                var total = oProgress.total;
                var percentComplete = Math.round((loaded / total) * 100);
            }
        };


        xhr.send();



        return deferred.promise();
    }
};
function dealUrlFile(zip,fileContainedInZipFile,infoAfterAnalysised){
    var name_pos = fileContainedInZipFile.name.lastIndexOf(".");
    var name_ext =fileContainedInZipFile.name.substring(name_pos,fileContainedInZipFile.name.length);
    if (name_ext.toLowerCase() != ".zip" ){
        var promise = zip.file(fileContainedInZipFile.name).async("uint8array");
        promise.then(function(byteArray){
            var dataSet = dicomParser.parseDicom(byteArray);
            if(_.isObject(dataSet)){
                var imgObj = createNewImageObject(dataSet);
                var infoSet = getDicomInfo(dataSet);
                var dicom = {dataSet:dataSet,infoSet:infoSet,imageId:imgObj.imageId,iid:infoSet.InstanceInfo.InstanceNumber.val};
                 
                dvStruct.imgObjArr.push(imgObj);
                dvStruct.addDicom(dicom,infoAfterAnalysised);
            }
        });
    }else{
        goUrlZipWay(fileContainedInZipFile,infoAfterAnalysised);
    }
}
function goUrlZipWay(fileContainedInZipFile,infoAfterAnalysised){
    var zip = new JSZip();
    var promise = zip.loadAsync(fileContainedInZipFile._data.compressedContent);
    promise.then(function (zip) {
        for (var nameOfFileContainedInZipFile in zip.files) {
            var fileContainedInZipFile2 = zip.files[nameOfFileContainedInZipFile];
            //先判断类型，文件还是文件夹
            if (fileContainedInZipFile2.dir) {
            } else {
                dealUrlFile(zip,fileContainedInZipFile2,infoAfterAnalysised);
            }
        }
    });
}

try {//safari 9以下没得FileReader，做个保险，不然解缩后影响后面的，要崩
    io.File = {
        zipReader: new FileReader(),
        dcmReader: new FileReader(),
        load: function (files) {
            try {
                for (var i = 0,len=files.length; i < len; i++) {
                    var file = files[i];
                    var pos = file.name.lastIndexOf(".");
                    var ext = file.name.substring(pos, file.name.length);
                    if (ext.toLowerCase() != ".zip") {
                        io.File.dcmReader.readAsArrayBuffer(file);
                    } else {
                        io.File.zipReader.readAsArrayBuffer(file);
                    }
                }
            } catch (e) {
                console.error(e);
                alert('加载异常');
            }
        },
        checkType: function () {

        },
        //zipReaderOnload:function(e) {
        //    //console.log(e);
        //    var zipFileLoaded = new JSZip(e.target.result);
        //    //console.log(zipFileLoaded);
        //    // do something with result
        //    for (var nameOfFileContainedInZipFile in zipFileLoaded.files)
        //    {
        //        var fileContainedInZipFile = zipFileLoaded.files[nameOfFileContainedInZipFile];
        //        //console.log(fileContainedInZipFile);
        //        //先判断类型，文件还是文件夹
        //        if(fileContainedInZipFile.dir){
        //        }else{
        //            io.File.zipReader.dealFile(fileContainedInZipFile);
        //        }
        //    }
        //}
        zipReaderOnload: function (e) {
            //console.log(e);
            var zip = new JSZip();
            var promise = zip.loadAsync(e.target.result);
            //console.log(promise);
            promise.then(function (zip) {
                // console.log(zip);
                // do something with result
                //zip.forEach(function (relativePath, zipEntry) {
                //    console.log(zipEntry);
                //});
                for (var nameOfFileContainedInZipFile in zip.files) {
                    var fileContainedInZipFile = zip.files[nameOfFileContainedInZipFile];
                    //console.log(fileContainedInZipFile);
                    //先判断类型，文件还是文件夹
                    if (fileContainedInZipFile.dir) {
                    } else {
                        io.File.zipReader.dealFile(fileContainedInZipFile, zip);
                    }
                }
            });
        }
    };

    io.File.zipReader.onload = io.File.zipReaderOnload;
    io.File.zipReader.dealFile = function (fileContainedInZipFile, zip) {
        var str = fileContainedInZipFile.name;
        var pos = str.lastIndexOf(".");
        var ext = str.substring(pos, str.length);
        if (ext.toLowerCase() != ".zip") {
            try {
                var onLoadView = function (dataSet) {
                };
                var promise = zip.file(fileContainedInZipFile.name).async("uint8array");
                promise.then(function (result) {//console.log(result);
                    var dicom = dicomLocalCoverUint8(result, onLoadView);//console.log(dicom);
                    if (dicom) {
                        dvStruct.addDicom(dicom,{});
                    }
                })
            } catch (error) {
                console.error(error);
            }
        } else {
            var promise = zip.file(fileContainedInZipFile.name).async("blob");
            promise.then(function (blob) {
                var reader = new FileReader();
                reader.onload = io.File.zipReaderOnload;
                reader.readAsArrayBuffer(blob);
            })
        }
    }

    io.File.dcmReader.onload = function (e) {
        //try {
        var onLoadView = function (dataSet) {
        };
        // console.log(e, e.target, e.target.result);
        var dicom = dicomLocalCovert(e.target.result, onLoadView);
        if (dicom) {
            dvStruct.addDicom(dicom,{});
        }
        //} catch (error) {
        //    console.error(error);
        //    alert('解析异常');
        //}
    };

}catch(e){console.error(e);}

 
/**
 * Created by admin on 2016/3/29.
 */

var dvStruct = dvStruct||{};
dvStruct.dragToCanv = {
    suid:undefined,
    clear:function(){
        var o = dvStruct.dragToCanv;
        o.suid = undefined;
        var div = o.getDiv();
        $(div).css('visibility', 'hidden');
    },
    pos:{
        top:0,left:0,
        x:0,y:0,
        lastX:0,lastY:0
    },
    divSize:{
        w:0,h:0
    },
    on:function(suid,pos,imageId,e){
        var o = dvStruct.dragToCanv;
        o.suid = suid;
        var div = o.getDiv();
        var w = $(div).width();
        o.pos.top = pos.top;o.pos.left = pos.left;
        o.pos.x = e.pageX;o.pos.y =e.pageY;
        o.pos.lastX = o.pos.x;o.pos.lastY = o.pos.y;
        $(div).css({
            top: (pos.top) + 'px',left: (pos.left) + 'px'
        });
        $(div).css('visibility', 'visible');
        o.dragOn();
    },
    getDiv:(function(){
        var dragToCanvDiv;
        return function(){
            return dragToCanvDiv||(function(){
                    var tmp = '<div style="visibility: hidden" id="js-dragToCanvDiv" class="dragToCanvDiv"></div>';
                    $(document.body).append(tmp);
                    dragToCanvDiv = document.getElementById('js-dragToCanvDiv');
                    var o = dvStruct.dragToCanv;
                    var size = o.divSize;
                    size.w = $(dragToCanvDiv).outerWidth();
                    size.h = $(dragToCanvDiv).outerHeight();
                    return dragToCanvDiv;
                })()
        }
    })(),
    drawDiv:function (imageId) {
        var element=$('#js-dragToCanvDiv').get(0);
        if (imageId != undefined) {
            cornerstone.disable(element);//清除上一次使用时留下的信息
            cornerstone.enable(element);
            cornerstoneTools.mouseInput.enable(element);
            cornerstone.loadImage(imageId).then(function (image) {
                cornerstone.displayImage(element, image);
            });
        }
    },
    dragOn:function(){
        $(document.body).on('mousemove',function(e){
            var x=  e.pageX,y= e.pageY;
            var pos =  dvStruct.dragToCanv.pos;
            var ofsX = x - pos.x;
            var ofsY = y - pos.y;
            var div = dvStruct.dragToCanv.getDiv();
            $(div).css({
                top: (pos.top+ofsY) + 'px',left: (pos.left + ofsX) + 'px'
            });
            pos.lastX = x;pos.lastY = y;
        });
        $(document.body).on('mouseup mouseleave',function(e){
            $(document.body).off('mouseleave');
            $(document.body).off('mousemove');
            $(document.body).off('mouseup');
            var o  = dvStruct.dragToCanv;
            var win = o.checkOn();//console.log(win);
            if(win){
                dvStruct.viewer.bindSeries(win,dvStruct.dragToCanv.suid);
                btnShowCheck();//检查按钮的显示与否
            }
            o.clear();
        });
    },
    checkOn:function(){
        //只是点一下
        var pos =  dvStruct.dragToCanv.pos;//console.log(pos);
        if(Math.abs(pos.lastX-pos.x)<4&&Math.abs(pos.lastY-pos.y)<4){
            var checkedWin  = dvStruct.viewer.getCheckedWin();//console.log(checkedWin);
            if(checkedWin){
                return checkedWin;
            }
            return undefined;
        }
        //拖拽判定
        var vArea = $(dvStruct.container).find('.js-imageViewer');
        var ofs = $(vArea).offset();
        var w = $(vArea).width();
        var h = $(vArea).height();
        var minx = ofs.left,miny=ofs.top,maxx=ofs.left+ w,maxy=ofs.top+h;
        //-------------------------------
        var div = dvStruct.dragToCanv.getDiv();
        var divOfs = $(div).offset();
        var divW = $(div).outerWidth();
        var divH = $(div).outerHeight();
        var divminX = divOfs.left,divminY = divOfs.top,divmaxX = divOfs.left+divW,divmaxY = divOfs.top+divH;
        if(!(divmaxX<=minx||divminX>=maxx||divmaxY<=miny||divminY>=maxy)){
            var centerx = (divminX+divmaxX)/2;
            var centery = (divminY+divmaxY)/2;
            var cols = Math.ceil((centerx - ofs.left)/dvStruct.viewer.eachW);
            var rows = Math.ceil((centery - ofs.top)/dvStruct.viewer.eachH);
            var No = dvStruct.viewer.col * (rows-1) + cols -1;
            return dvStruct.viewer.getWinByNo(No);
        }
        return undefined;
    }
};

function bindDragToCanv(){
    $('.leftGallery').mousedown(function(e){
        var ele = e.target;
        var dragAble = false;var imgNode;
        if($(ele).hasClass('js-dragToCanv')){
            dragAble=true;imgNode = $(ele);
        }
        if(!dragAble&&$(ele).parents('.js-dragToCanv').length>0){
            dragAble=true;imgNode = $(ele).parents('.js-dragToCanv');
        }
        if(dragAble){
            var pos = $(imgNode).offset();
            var suid = $(imgNode).attr('suid');
            var imageId=$(imgNode).attr('imageId');
            dvStruct.dragToCanv.on(suid,pos,imageId,e);

        }
    });
    //缩略图收缩
    $(document).on('click', '.folder .folderIn', function (e) {

        $(this).hide();
        $(this).parent().find('.folderOut').show();

        $(this).parents('.patientName').find('.imgBox').each(function (k,val) {
            if(k>0){
                $(this).hide();
            }
        });

    });
    $(document).on('click', '.folder .folderOut', function (e) {
        $(this).hide();
        $(this).parent().find('.folderIn').show();
        $(this).parents('.patientName').find('.imgBox').each(function (k,val) {
            $(this).show();
        });


    });
}
/**
 * Created by admin on 2016/4/26.
 */
/*! FileSaver.js
 *  A fileSaveAs() FileSaver implementation.
 *  2014-01-24
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
//fileSaveAs

var fileSaveAs = fileSaveAs
        // IE 10+ (native fileSaveAs)
    || (typeof navigator !== "undefined" &&
    navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
        // Everyone else
    || (function(view) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof navigator !== "undefined" &&
            /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = view.document
        // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
            , get_URL = function() {
                return view.URL || view.webkitURL || view;
            }
            , URL = view.URL || view.webkitURL || view
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = !view.externalHost && "download" in save_link
            , click = function(node) {
                var event = doc.createEvent("MouseEvents");
                event.initMouseEvent(
                    "click", true, false, view, 0, 0, 0, 0, 0
                    , false, false, false, false, 0, null
                );
                node.dispatchEvent(event);
            }
            , webkit_req_fs = view.webkitRequestFileSystem
            , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
            , throw_outside = function(ex) {
                (view.setImmediate || view.setTimeout)(function() {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            , fs_min_size = 0
            , deletion_queue = []
            , process_deletion_queue = function() {
                var i = deletion_queue.length;
                while (i--) {
                    var file = deletion_queue[i];
                    if (typeof file === "string") { // file is an object URL
                        URL.revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                }
                deletion_queue.length = 0; // clear queue
            }
            , dispatch = function(filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , FileSaver = function(blob, name) {
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , blob_changed = false
                    , object_url
                    , target_view
                    , get_object_url = function() {
                        var object_url = get_URL().createObjectURL(blob);
                        deletion_queue.push(object_url);
                        return object_url;
                    }
                    , dispatch_all = function() {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                // on any filesys errors revert to saving with object URLs
                    , fs_error = function() {
                        // don't create more object URLs than needed
                        if (blob_changed || !object_url) {
                            object_url = get_object_url(blob);
                        }
                        if (target_view) {
                            target_view.location.href = object_url;
                        } else {
                            window.open(object_url, "_blank");
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                    }
                    , abortable = function(func) {
                        return function() {
                            if (filesaver.readyState !== filesaver.DONE) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    , create_if_not_found = {create: true, exclusive: false}
                    , slice
                    ;
                filesaver.readyState = filesaver.INIT;


                if (!name) {
                    name = "download";
                }
                if (can_use_save_link) {

                    object_url = get_object_url(blob);

                    // FF for Android has a nasty garbage collection mechanism
                    // that turns all objects that are not pure javascript into 'deadObject'
                    // this means `doc` and `save_link` are unusable and need to be recreated
                    // `view` is usable though:
                    doc = view.document;
                    save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
                    save_link.href = object_url;
                    save_link.download = name;
                    var event = doc.createEvent("MouseEvents");
                    event.initMouseEvent(
                        "click", true, false, view, 0, 0, 0, 0, 0
                        , false, false, false, false, 0, null
                    );
                    save_link.dispatchEvent(event);
                    filesaver.readyState = filesaver.DONE;

                    dispatch_all();

                    return;
                }

                // Object and web filesystem URLs have a problem saving in Google Chrome when
                // viewed in a tab, so I force save with application/octet-stream
                // http://code.google.com/p/chromium/issues/detail?id=91158
                if (view.chrome && type && type !== force_saveable_type) {
                    slice = blob.slice || blob.webkitSlice;
                    blob = slice.call(blob, 0, blob.size, force_saveable_type);
                    blob_changed = true;
                }
                // Since I can't be sure that the guessed media type will trigger a download
                // in WebKit, I append .download to the filename.
                // https://bugs.webkit.org/show_bug.cgi?id=65440
                if (webkit_req_fs && name !== "download") {
                    name += ".download";
                }
                if (type === force_saveable_type || webkit_req_fs) {
                    target_view = view;
                }
                if (!req_fs) {
                    fs_error();
                    return;
                }
                fs_min_size += blob.size;
                req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {

                    fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {

                        var save = function() {
                            console.log(dir);
                            dir.getFile(name, create_if_not_found, abortable(function(file) {
                                file.createWriter(abortable(function(writer) {
                                    writer.onwriteend = function(event) {
                                        target_view.location.href = file.toURL();
                                        deletion_queue.push(file);
                                        filesaver.readyState = filesaver.DONE;
                                        dispatch(filesaver, "writeend", event);
                                    };
                                    writer.onerror = function() {
                                        var error = writer.error;
                                        if (error.code !== error.ABORT_ERR) {
                                            fs_error();
                                        }
                                    };
                                    "writestart progress write abort".split(" ").forEach(function(event) {
                                        writer["on" + event] = filesaver["on" + event];
                                    });
                                    writer.write(blob);
                                    filesaver.abort = function() {
                                        writer.abort();
                                        filesaver.readyState = filesaver.DONE;
                                    };
                                    filesaver.readyState = filesaver.WRITING;
                                }), fs_error);
                            }), fs_error);
                        };
                        dir.getFile(name, {create: false}, abortable(function(file) {
                            // delete file if it already exists
                            file.remove();
                            save();
                        }), abortable(function(ex) {
                            if (ex.code === ex.NOT_FOUND_ERR) {
                                save();
                            } else {
                                fs_error();
                            }
                        }));
                    }), fs_error);
                }), fs_error);

            }
            , FS_proto = FileSaver.prototype
            , fileSaveAs = function(blob, name) {
                return new FileSaver(blob, name);
            }
            ;
        FS_proto.abort = function() {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE;
            dispatch(filesaver, "abort");
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
            FS_proto.onwritestart =
                FS_proto.onprogress =
                    FS_proto.onwrite =
                        FS_proto.onabort =
                            FS_proto.onerror =
                                FS_proto.onwriteend =
                                    null;

        view.addEventListener("unload", process_deletion_queue, false);
        fileSaveAs.unload = function() {
            process_deletion_queue();
            view.removeEventListener("unload", process_deletion_queue, false);
        };
        return fileSaveAs;
    }(
        typeof self !== "undefined" && self
        || typeof window !== "undefined" && window
        || this.content
    ));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined") module.exports = fileSaveAs;

/**
 * Created by Administrator on 2016/11/24.
 */


var getPrintURL = getPrintURL
    // IE 10+ (native fileSaveAs)
    || (typeof navigator !== "undefined" &&
    navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
    // Everyone else
    || (function(view) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof navigator !== "undefined" &&
            /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = view.document
            // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
            , get_URL = function() {
                return view.URL || view.webkitURL || view;
            }
            , URL = view.URL || view.webkitURL || view
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = !view.externalHost && "download" in save_link
            , click = function(node) {
                var event = doc.createEvent("MouseEvents");
                event.initMouseEvent(
                    "click", true, false, view, 0, 0, 0, 0, 0
                    , false, false, false, false, 0, null
                );
                node.dispatchEvent(event);
            }
            , webkit_req_fs = view.webkitRequestFileSystem
            , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
            , throw_outside = function(ex) {
                (view.setImmediate || view.setTimeout)(function() {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            , fs_min_size = 0
            , deletion_queue = []
            , process_deletion_queue = function() {
                var i = deletion_queue.length;
                while (i--) {
                    var file = deletion_queue[i];
                    if (typeof file === "string") { // file is an object URL
                        URL.revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                }
                deletion_queue.length = 0; // clear queue
            }
            , dispatch = function(filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , FileSaver = function(blob, name) {
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , blob_changed = false
                    , object_url
                    , target_view
                    , get_object_url = function() {
                        var object_url = get_URL().createObjectURL(blob);
                        deletion_queue.push(object_url);
                        return object_url;
                    }
                    , dispatch_all = function() {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                    // on any filesys errors revert to saving with object URLs
                    , fs_error = function() {
                        // don't create more object URLs than needed
                        if (blob_changed || !object_url) {
                            object_url = get_object_url(blob);
                        }
                        if (target_view) {
                            target_view.location.href = object_url;
                        } else {
                            window.open(object_url, "_blank");
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                    }
                    , abortable = function(func) {
                        return function() {
                            if (filesaver.readyState !== filesaver.DONE) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    , create_if_not_found = {create: true, exclusive: false}
                    , slice
                    ;
                filesaver.readyState = filesaver.INIT;
                if (!name) {
                    name = "download";
                }
                if (can_use_save_link) {
                    object_url = get_object_url(blob);
                    filesaver.printURL=object_url;
                    return;//获取到需要的URL就不继续执行了，返回，此处返回不会下载数据
                    // FF for Android has a nasty garbage collection mechanism
                    // that turns all objects that are not pure javascript into 'deadObject'
                    // this means `doc` and `save_link` are unusable and need to be recreated
                    // `view` is usable though:
                    doc = view.document;
                    save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
                    save_link.href = object_url;
                    save_link.download = name;


                   /* var event = doc.createEvent("MouseEvents");
                    event.initMouseEvent(
                        "click", true, false, view, 0, 0, 0, 0, 0
                        , false, false, false, false, 0, null
                    );
                   save_link.dispatchEvent(event);*/
                    filesaver.readyState = filesaver.DONE;

                  //  dispatch_all();
                    return;
                }

               /* // Object and web filesystem URLs have a problem saving in Google Chrome when
                // viewed in a tab, so I force save with application/octet-stream
                // http://code.google.com/p/chromium/issues/detail?id=91158
                if (view.chrome && type && type !== force_saveable_type) {
                    slice = blob.slice || blob.webkitSlice;
                    blob = slice.call(blob, 0, blob.size, force_saveable_type);
                    blob_changed = true;
                }
                // Since I can't be sure that the guessed media type will trigger a download
                // in WebKit, I append .download to the filename.
                // https://bugs.webkit.org/show_bug.cgi?id=65440
                if (webkit_req_fs && name !== "download") {
                    name += ".download";
                }
                if (type === force_saveable_type || webkit_req_fs) {
                    target_view = view;
                }
                if (!req_fs) {
                    fs_error();
                    return;
                }
                fs_min_size += blob.size;
                req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                    fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                        var save = function() {
                            dir.getFile(name, create_if_not_found, abortable(function(file) {
                                file.createWriter(abortable(function(writer) {
                                    writer.onwriteend = function(event) {
                                        target_view.location.href = file.toURL();
                                        deletion_queue.push(file);
                                        filesaver.readyState = filesaver.DONE;
                                        dispatch(filesaver, "writeend", event);
                                    };
                                    writer.onerror = function() {
                                        var error = writer.error;
                                        if (error.code !== error.ABORT_ERR) {
                                            fs_error();
                                        }
                                    };
                                    "writestart progress write abort".split(" ").forEach(function(event) {
                                        writer["on" + event] = filesaver["on" + event];
                                    });
                                    writer.write(blob);
                                    filesaver.abort = function() {
                                        writer.abort();
                                        filesaver.readyState = filesaver.DONE;
                                    };
                                    filesaver.readyState = filesaver.WRITING;
                                }), fs_error);
                            }), fs_error);
                        };
                        dir.getFile(name, {create: false}, abortable(function(file) {
                            // delete file if it already exists
                            file.remove();
                            save();
                        }), abortable(function(ex) {
                            if (ex.code === ex.NOT_FOUND_ERR) {
                                save();
                            } else {
                                fs_error();
                            }
                        }));
                    }), fs_error);
                }), fs_error);*/

            }
            , FS_proto = FileSaver.prototype
            , getPrintURL = function(blob, name) {
                 return new FileSaver(blob, name);

            }
            ;
        FS_proto.abort = function() {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE;
            dispatch(filesaver, "abort");
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;
        FS_proto.error =
            FS_proto.onwritestart =
                FS_proto.onprogress =
                    FS_proto.onwrite =
                        FS_proto.onabort =
                            FS_proto.onerror =
                                FS_proto.onwriteend =
                                    null;

        view.addEventListener("unload", process_deletion_queue, false);
        getPrintURL.unload = function() {
            process_deletion_queue();
            view.removeEventListener("unload", process_deletion_queue, false);
        };
        return getPrintURL;
    }(
        typeof self !== "undefined" && self
        || typeof window !== "undefined" && window
        || this.content
    ));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined") module.exports = getPrintURL;
/**
 * Created by admin on 2016/4/26.
 */
if(!dvStruct){
    var dvStruct={}
}

dvStruct.enableSaveDownloaded = true;

dvStruct.downloadedDcmFiles=[];

commEventHandler.addEventListener('dicomDownloaded',function(event){
    if(!dvStruct.enableSaveDownloaded)return;
    dvStruct.downloadedDcmFiles.push({
        name:event.name,
        data:event.data,
        infoAfterAnalysised:event.infoAfterAnalysised
    });
});

dvStruct.saveDownloaded = function(print,flagArr){
    if(dvStruct.share)//如果为分享状态则不允许下载dcm格式，但可以下载为jpg
    {
        // alert ("注：分享模式下，无法下载原dicom文件，请您选择下载jpg文件!");
        $('.tipsText').text("注：分享模式下，无法下载原dicom格式文件，请您选择下载jpg格式文件!");
        $('#tipsBoxs').show();
      //  pop_up({title: "下载提示", message: "分享模式下，无法下载原dicom格式文件，请您选择下载jpg格式文件!", yesName: "确定", noName: "取消"});
      //  return;

    }
    var zip = new JSZip();
    var folder = zip.folder("dicoms");
    // console.log(dvStruct.downloadedDcmFiles);
    // for(var i=0;i<dvStruct.downloadedDcmFiles.length;i++){
    //     var fl = dvStruct.downloadedDcmFiles[i];
    //     folder.file(fl.name, fl.data);
    // }

    //sj change
    for(var i=0,len1=dvStruct.seriesArr.length;i<len1;i++)//遍历所有序列
    {
        for(var j=0,len2=dvStruct.seriesArr[i].dicomArr.length;j<len2;j++)//遍历单个序列的所有文件
        {
            var f1=dvStruct.seriesArr[i].dicomArr[j].dataSet;
            var fileName=i.toString()+"_"+j.toString()+".dcm";//文件名
            folder.file(fileName,f1.byteArray );
        }
    }
    //sj change end
    if(print){
        var printObj;

        if (JSZip.support.blob) {

                zip.generateAsync({type:"blob"}).then(function (blob) {console.log(blob);
                printObj=  getPrintURL(blob, "dicoms.zip");
                getUrlFlag=true;
                flagArr.push(printObj.printURL);
                return printObj.printURL;
            }, function (err) {
                console.error(err);
            });
        }

    }
    else {
        if (JSZip.support.blob) {
            zip.generateAsync({type:"blob"}).then(function (blob) {
                // console.log(blob);
                 fileSaveAs(blob, "dicoms.zip");
                // saveAs(blob, "dicoms.zip");
            }, function (err) {
                console.error(err);
            });
            return false;
        }
    }

};//

function browseFolder(path) {
    try {
        var Message = "\u8bf7\u9009\u62e9\u6587\u4ef6\u5939"; //选择框提示信息
        var Shell = new ActiveXObject("Shell.Application");
        var Folder = Shell.BrowseForFolder(0, Message, 64, 17); //起始目录为：我的电脑
        //var Folder = Shell.BrowseForFolder(0, Message, 0); //起始目录为：桌面
        if (Folder != null) {
            Folder = Folder.items(); // 返回 FolderItems 对象
            Folder = Folder.item(); // 返回 Folderitem 对象
            Folder = Folder.Path; // 返回路径
            if (Folder.charAt(Folder.length - 1) != "\\") {
                Folder = Folder + "\\";
            }
            document.getElementById(path).value = Folder;
            return Folder;
        }
    }
    catch (e) {
        alert(e.message);
    }
}
(function($, cornerstone, cornerstoneTools) {

    'use strict';
    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
        while(n--){
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {type:mime});
    }
    //下载调窗后的JPG
    function getViewportWWWL(){

    }
    function saveAllAs(filename,opts) {
        var canvasDiv = document.createElement('div');
        var opts = opts||{};
        var size = opts.size||500;
        canvasDiv.style.width = size;canvasDiv.style.height = size;

        cornerstone.enable(canvasDiv);
        var canvas = $(canvasDiv).find('canvas').get(0);canvas.width = size;canvas.height=size;canvas.style.width = size;canvas.style.height = size;

        var zip = new JSZip();
        var folder = zip.folder(filename);

    /*    for(var i=0;i<dvStruct.imgObjArr.length;i++){
            var imagePromise = dvStruct.imgObjArr[i].imagePromise;
            imagePromise.then(function(image){
                cornerstone.displayImage(canvasDiv,image);
            });
            if( opts.type=='png'){
                var picurl = canvas.toDataURL('image/png');
                var picblob = dataURLtoBlob(picurl);
                folder.file(i+'.png',picblob);
            }else{
                var picurl = canvas.toDataURL('image/jpeg');
                var picblob = dataURLtoBlob(picurl);
                folder.file(i+'.jpg',picblob);
            }
        }*/
        //sj change
        var imagePromise;
        for(var i=0,len1=dvStruct.seriesArr.length;i<len1;i++)//遍历所有序列
        {
            for(var j=0,len2=dvStruct.seriesArr[i].dicomArr.length;j<len2;j++)//遍历单个序列的所有文件
            {
                var targetImageId =  dvStruct.seriesArr[i].dicomArr[j].imageId ;
                //通过targetImageId找到对应的imagePromise
                for(var k=0,len3=dvStruct.imgObjArr.length;k<len3;k++) {
                    if(dvStruct.imgObjArr[k].imageId===targetImageId)
                    {
                        imagePromise = dvStruct.imgObjArr[k].imagePromise ;
                        imagePromise.then(function(image){
                            // cornerstone.displayImage(canvasDiv,image);
                            cornerstone.displayImageForJpg(canvasDiv,image);//调用专门的函数绘制jpg保存图像
                            return;
                        });//绘制图像
                        //保存图像
                        if( opts.type=='png'){
                            var picurl = canvas.toDataURL('image/png');
                            var picblob = dataURLtoBlob(picurl);
                            folder.file(i.toString()+"_"+j.toString()+'.png',picblob);
                        }else{
                            var picurl = canvas.toDataURL('image/jpeg');
                            var picblob = dataURLtoBlob(picurl);
                            folder.file(i.toString()+"_"+j.toString()+'.jpg',picblob);
                        }
                        k=0;
                        break;
                    }
                }
            }
        }
        //sj change end


        if (JSZip.support.blob) {
            zip.generateAsync({type:"blob"}).then(function (blob) {
                fileSaveAs(blob, filename+".zip");
            }, function (err) {
                console.error(err);
            });
            return false;
        }
    }

    cornerstoneTools.saveAllAs = saveAllAs;

})($, cornerstone, cornerstoneTools);

/**
 * Created by Administrator on 2016/9/18.
 */

function getObj( imgPlaneData)
{
    var obj={
        space:new Array(imgPlaneData.rowPixelSpacing,imgPlaneData.columnPixelSpacing),

        size:new Array(imgPlaneData.rows,imgPlaneData.columns),
        o:imgPlaneData.imagePositionPatient,
        vecR:imgPlaneData.rowCosines,
        vecC:imgPlaneData.columnCosines
    };
    return obj;
}
// (function($, cornerstone, cornerstoneTools) {
//
//     'use strict';

var xloc = {

    //显示版本号
    version: function() {
        return "xloc v0.1 by xteam 2015-06-08";
    },

    //向量点乘法
    VecDot: function(v1, v2) {
        var ret = 0.0;
        for (var i = 0; i < 3; i++) {
            ret += v1[i] * v2[i];
        }
        return ret;
    },
    //向量叉乘法:u x v = { u2v3-v2u3 , u3v1-v3u1 , u1v2-u2v1 }
    VecCross: function(v1, v2, pVecOut) {
        pVecOut[0] = v1[1] * v2[2] - v1[2] * v2[1];
        pVecOut[1] = v1[2] * v2[0] - v1[0] * v2[2];
        pVecOut[2] = v1[0] * v2[1] - v1[1] * v2[0];
    },
    //向量模长
    VecMode: function(v) {
        var mode;
        mode = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        return mode;
    },

    //根据2个点得到向量
    VecPoint: function(p1, p2, pVecOut) {
        for (var i = 0; i < 3; i++) {
            pVecOut[i] = p2[i] - p1[i];
        }
    },

    //进行定位线计算
    LocalCalc: function(locStrIn, axStrIn) {
        var retObj = {
            flag: 0,
            value: " ",
            xp1: new Array("a", "a"),
            xp2: new Array("a", "a")
        }; //用于返回相交两点的坐标；

         var V_ZERO = 0.0001;
        //进行输入参数分解,定位图
        //var imgLoc = new TDicomInfo();
        var imgLoc = {
            space: new Array(0, 0),
            size: new Array(0, 0),
            o: new Array(0, 0, 0),
            vecR: new Array(0, 0, 0),
            vecC: new Array(0, 0, 0),
            n: new Array(0, 0, 0),
            p1: new Array(0, 0, 0),
            p2: new Array(0, 0, 0),
            p3: new Array(0, 0, 0)
        };
        imgLoc.space=locStrIn.space;
        imgLoc.size=locStrIn.size;

        imgLoc.vecR[0]=locStrIn.vecR.x;
        imgLoc.vecR[1]=locStrIn.vecR.y;
        imgLoc.vecR[2]=locStrIn.vecR.z;
        imgLoc.vecC[0]=locStrIn.vecC.x;
        imgLoc.vecC[1]=locStrIn.vecC.y;
        imgLoc.vecC[2]=locStrIn.vecC.z;

        imgLoc.o[0] = locStrIn.o.x;
        imgLoc.o[1] = locStrIn.o.y;
        imgLoc.o[2] = locStrIn.o.z;



        //进行输入参数分解,切片图
        //var imgAx = new TDicomInfo();

        var imgAx = {
            space: new Array(0, 0),
            size: new Array(0, 0),
            o: new Array(0, 0, 0),
            vecR: new Array(0, 0, 0),
            vecC: new Array(0, 0, 0),
            n: new Array(0, 0, 0),
            p1: new Array(0, 0, 0),
            p2: new Array(0, 0, 0),
            p3: new Array(0, 0, 0)
        };

        imgAx.space=axStrIn.space;
        imgAx.size=axStrIn.size;
        imgAx.vecR[0]=axStrIn.vecR.x;
        imgAx.vecR[1]=axStrIn.vecR.y;
        imgAx.vecR[2]=axStrIn.vecR.z;
        imgAx.vecC[0]=axStrIn.vecC.x;
        imgAx.vecC[1]=axStrIn.vecC.y;
        imgAx.vecC[2]=axStrIn.vecC.z;
        imgAx.o[0] = axStrIn.o.x;
        imgAx.o[1] = axStrIn.o.y;
        imgAx.o[2] = axStrIn.o.z;




        //进行行列方向矢量规范

        for (var i = 0; i < 3; i++) {
            imgLoc.vecR[i] = Math.abs(imgLoc.vecR[i]) < V_ZERO ? 0 : imgLoc.vecR[i];
            imgLoc.vecC[i] = Math.abs(imgLoc.vecC[i]) < V_ZERO ? 0 : imgLoc.vecC[i];

            imgAx.vecR[i] = Math.abs(imgAx.vecR[i]) < V_ZERO ? 0 : imgAx.vecR[i];
            imgAx.vecC[i] = Math.abs(imgAx.vecC[i]) < V_ZERO ? 0 : imgAx.vecC[i];
        }
        //计算定位图和切片图的法向量
        xloc.VecCross(imgLoc.vecR, imgLoc.vecC, imgLoc.n);
        xloc.VecCross(imgAx.vecR, imgAx.vecC, imgAx.n);


        //计算定位图和切片图的P1，P2，P3
        for (var i = 0; i < 3; i++) {
            //P1点
            imgLoc.p1[i] = imgLoc.o[i];
            imgAx.p1[i] = imgAx.o[i];

            //P2点
            imgLoc.p2[i] = imgLoc.p1[i] + imgLoc.vecR[i] * imgLoc.space[0] * imgLoc.size[1];
            imgAx.p2[i] = imgAx.p1[i] + imgAx.vecR[i] * imgAx.space[0] * imgAx.size[1];

            //计算P3点
            imgLoc.p3[i] = imgLoc.p1[i] + imgLoc.vecC[i] * imgLoc.space[0] * imgLoc.size[1];
            imgAx.p3[i] = imgAx.p1[i] + imgAx.vecC[i] * imgAx.space[0] * imgAx.size[1];
        }



        // 判断直线P1P2P3P4是否和定位图相交
        var t12 = 0,
            t13 = 0,
            t24 = 0,
            t34 = 0;
        for (var i = 0; i < 3; i++) {
            t12 += imgLoc.n[i] * imgAx.vecR[i];
            t13 += imgLoc.n[i] * imgAx.vecC[i];
            t24 += imgLoc.n[i] * imgAx.vecC[i];
            t34 += imgLoc.n[i] * imgAx.vecR[i];
        }

        //判断是否平行
        if (Math.abs(t12) + Math.abs(t13) + Math.abs(t24) + Math.abs(t34) < V_ZERO) {
            //printf("[0:0]-[0:0]\n");
            retObj.value = "定位图和切面平行";
            return retObj;
            // return;
        }




        //P12 P34平行，计算P13 P24交点
        if (Math.abs(t12) < V_ZERO) {
            //计算实际
            //t13 = dot(a1-p1, n1);
            //t24 = dot(a1-p2, n1);
            t13 = 0.0;
            t24 = 0.0;
            for (var i = 0; i < 3; i++) {
                t13 += (imgLoc.p1[i] - imgAx.p1[i]) * imgLoc.n[i];
                t24 += (imgLoc.p1[i] - imgAx.p2[i]) * imgLoc.n[i];
            }

            //计算实际p13,p24
            var p13 = new Array(0.0, 0.0, 0.0),
                p24 = new Array(0.0, 0.0, 0.0);

            //p13 = p1 + t13*c2;
            //p24 = p2 + t24*c2;
            for (var i = 0; i < 3; i++) {
                p13[i] = imgAx.p1[i] + t13 * imgAx.vecC[i];
                p24[i] = imgAx.p2[i] + t24 * imgAx.vecC[i];

            }


            var vecP13A1 = new Array(0.0, 0.0, 0.0),
                vecP24A1 = new Array(0.0, 0.0, 0.0),
                vecA2A1 = new Array(0.0, 0.0, 0.0),
                vecA3A1 = new Array(0.0, 0.0, 0.0),
                tmp = 0.0;
            var cc13 = 0,
                rr13 = 0,
                cc24 = 0,
                rr24 = 0;
            xloc.VecPoint(imgLoc.p1, p13, vecP13A1);
            xloc.VecPoint(imgLoc.p1, p24, vecP24A1);
            xloc.VecPoint(imgLoc.p1, imgLoc.p2, vecA2A1);
            xloc.VecPoint(imgLoc.p1, imgLoc.p3, vecA3A1);
            //取得第一个交点
            tmp = (xloc.VecDot(vecP13A1, vecA2A1) / (xloc.VecMode(vecP13A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP13A1)) / xloc.VecMode(vecA2A1);
            cc13 = parseInt(tmp * imgLoc.size[0]);
            tmp = (xloc.VecDot(vecP13A1, vecA3A1) / (xloc.VecMode(vecP13A1) * xloc.VecMode(vecA3A1)) * xloc.VecMode(vecP13A1) / xloc.VecMode(vecA3A1));
            rr13 = parseInt(tmp * imgLoc.size[1]);
            tmp = (xloc.VecDot(vecP24A1, vecA2A1) / (xloc.VecMode(vecP24A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP24A1)) / xloc.VecMode(vecA2A1);
            cc24 = parseInt(tmp * imgLoc.size[0]);
            tmp = (xloc.VecDot(vecP24A1, vecA3A1) / (xloc.VecMode(vecP24A1) * xloc.VecMode(vecA3A1)) * xloc.VecMode(vecP24A1) / xloc.VecMode(vecA3A1));
            rr24 = parseInt(tmp * imgLoc.size[1]);


            retObj.xp1[0] = cc13;
            retObj.xp1[1] = rr13;
            retObj.xp2[0] = cc24;
            retObj.xp2[1] = rr24;
            retObj.flag = 1;
            retObj.value = "得到定位坐标";
            // return retObj;


            return {
                start: {x:cc13,
                    y:rr13
                } ,
                end:{x:cc24,
                    y:rr24
                }
            };

        } else //if (Math.abs(t13) < V_ZERO) //P13 P24平行，计算P12 P34交点
        {
            t12 = 0.0;
            t34 = 0.0;
            for (var i = 0; i < 3; i++) {
                t13 += (imgLoc.p1[i] - imgAx.p1[i]) * imgLoc.n[i];
                t24 += (imgLoc.p1[i] - imgAx.p3[i]) * imgLoc.n[i];
            }
            //计算实际p12,p34
            var p12 = new Array(0.0, 0.0, 0.0),
                p34 = new Array(0.0, 0.0, 0.0);

            //p12 = p1 + t12*c2;
            //p34 = p3 + t34*c2;
            for (var i = 0; i < 3; i++) {
                p12[i] = imgAx.p2[i] + t12 * imgAx.vecR[i];
                p34[i] = imgAx.p3[i] + t34 * imgAx.vecR[i];

            }

            var vecP12A1 = new Array(0.0, 0.0, 0.0),
                vecP34A1 = new Array(0.0, 0.0, 0.0);
            vecA2A1 = new Array(0.0, 0.0, 0.0),
                vecA3A1 = new Array(0.0, 0.0, 0.0),
                tmp = 0.0;
            cc13 = 0;
            rr13 = 0;
            cc24 = 0;
            rr24 = 0;
            xloc.VecPoint(imgLoc.p1, p12, vecP12A1);
            xloc.VecPoint(imgLoc.p1, p34, vecP34A1);
            xloc.VecPoint(imgLoc.p1, imgLoc.p2, vecA2A1);
            xloc.VecPoint(imgLoc.p1, imgLoc.p3, vecA3A1);
            //取得第一个交点
            tmp = (xloc.VecDot(vecP12A1, vecA2A1) / (xloc.VecMode(vecP12A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP12A1)) / xloc.VecMode(vecA2A1);
            cc13 = parseInt(tmp * imgLoc.size[0]);
            tmp = (xloc.VecDot(vecP12A1, vecA3A1) / (xloc.VecMode(vecP12A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP12A1) / xloc.VecMode(vecA3A1));
            rr13 = parseInt(tmp * imgLoc.size[1]);
            //取得第二个交点
            tmp = (xloc.VecDot(vecP34A1, vecA2A1) / (xloc.VecMode(vecP34A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP34A1)) / xloc.VecMode(vecA2A1);
            cc24 = parseInt(tmp * imgLoc.size[0]);
            tmp = (xloc.VecDot(vecP34A1, vecA3A1) / (xloc.VecMode(vecP34A1) * xloc.VecMode(vecA2A1)) * xloc.VecMode(vecP34A1) / xloc.VecMode(vecA3A1));
            rr24 = parseInt(tmp * imgLoc.size[1]);

            retObj.xp1[0] = cc13;
            retObj.xp1[1] = rr13;
            retObj.xp2[0] = cc24;
            retObj.xp2[1] = rr24;
            retObj.flag = 1;
            retObj.value = "已计算出两个面的交点。";


            return {
                start: {x:cc13,
                    y:rr13
                } ,
                end:{x:cc24,
                    y:rr24
                }
            };

        }

        //	printf("[0:0]-[0:0]\n");
        retObj.value = " 传入两个面平行，不存在定位线";
        return retObj;

    },
    //****************************************************

}
//     cornerstoneTools.calcRenferenceLineSup = xloc.LocalCalc ;//定位线补充计算方法绑定到cornerstoneTools上
// })($, cornerstone, cornerstoneTools);

/**
 * Created by admin on 2016/5/30.
 */
function helperIniSave(){
    function addBtnHelper($node, title, opts) {
        if(!opts)opts={};
        if(!opts.txt){
            var txt=''
        }else{var txt = opts.txt;}
        var w = Math.max(title.length,txt.length)*14+20;
        w = w>150?150:w;
        var html = '<div class="help" style="width: '+w+'px">';
        html += '<div class="triangle"></div>';
        html += '<span class="title">' + title + '</span><br/>';
        if (opts.txt)html += '<p class="gray" style="width: '+(w-20)+'px">' + opts.txt + '</p>';
        html += '</div>';
        $node.append(html);
    }

    addBtnHelper($('.js-default'), '默认鼠标');
    addBtnHelper($('.js-wwwl'), '调窗');
    addBtnHelper($('.js-wwwldiy'), '数值调窗');
    addBtnHelper($('.js-invert'), '反显');
    addBtnHelper($('.js-fakecolor'), '伪彩');
    addBtnHelper($('.js-zoom'), '缩放');
    addBtnHelper($('.js-ccw'), '左旋');
    addBtnHelper($('.js-cw'), '右旋');
    addBtnHelper($('.js-pan'), '移动');
    addBtnHelper($('.js-reference'), '定位线');
    addBtnHelper($('.js-probe'), '点测量');
    addBtnHelper($('.js-probeUnSave'), '点测量',{txt: '图像上不保留点'});
    addBtnHelper($('.js-length'), '线测量');
    addBtnHelper($('.js-twolines'), '心胸比');
    addBtnHelper($('.js-heartScale'), '心胸比');
    addBtnHelper($('.js-angle'), '角度测量');
    addBtnHelper($('.js-ellipse'), '椭圆测量');
    addBtnHelper($('.js-rect'), '矩形测量');
    addBtnHelper($('.js-clearToolState'), '清空测量');
    addBtnHelper($('.js-play'), '播放');
    addBtnHelper($('.js-stop'), '停止');
    addBtnHelper($('.js-layoutSelector'), '窗口布局', {txt: '一个窗口对应一个序列'});
    addBtnHelper($('.js-innerlayoutSelector'), '序列布局', {txt: '即子窗口布局改变'});
    addBtnHelper($('.js-scrollAll'), '翻页联动');
    addBtnHelper($('.js-infoVisible'), '显示信息');
    addBtnHelper($('.js-fileSave'), '下载保存', {txt:'仅下载已从服务端发到浏览器的dicom集'});
    addBtnHelper($('.js-fileSaveJpg'), '下载保存为jpg');//sj add
    addBtnHelper($('.js-syn'), '图像联动');
    addBtnHelper($('.js-mpr'), 'mpr');
    addBtnHelper($('.js-dcmPrint'), '胶片打印');
    addBtnHelper($('.js-downloadset'), '图像下载' , {txt:'包括dcm下载，jpg下载，dcm浏览器下载'});
//帮助
    var helpTiming;
    $(".btnArea").hover(function () {
        var _this = this;
        helpTiming = setTimeout(function () {
            //console.log(node);console.log('timing');
            $(_this).find(".help").show();
        }, 1000);
    }, function () {
        $(this).find(".help").hide();
        try {
            clearTimeout(helpTiming);
        } catch (e) {
        }
    });
};
function helperIni(){

};
var initWebSocket = function(localIP) {
console.log("localIP:"+localIP);
  try{
      if(localIP!=undefined&&localIP!=null){
          socket = new WebSocket(localIP);
      }
      else{
          socket = new WebSocket('ws://localhost:8181');
      }


  }
  catch(e){
  alert("服务连接失败,请检查服务是否正确安装，或打开。如未按照服务请点击下载安装。再进入胶片打印页面");
  }
};


var initWebSocketVR = function(localIP) {
    console.log("localIP:"+localIP);
    try{
        if(localIP!=undefined&&localIP!=null){
            socket = new WebSocket(localIP);
        }
        else{
            socket = new WebSocket('ws://localhost:8286');
        }

    }
    catch(e){
        alert("服务连接失败,请检查服务是否正确安装，或打开。如未按照服务请点击下载安装，再使用VR服务！");
    }
};

var convertImgDataToBlob = function (base64Data) {
                var format = "image/jpeg";
                var base64 = base64Data;
                var code = window.atob(base64.split(",")[1]);
                var aBuffer = new window.ArrayBuffer(code.length);
                var uBuffer = new window.Uint8Array(aBuffer);
                for(var i = 0; i < code.length; i++){
                    uBuffer[i] = code.charCodeAt(i) & 0xff ;
                }
             //   console.info([aBuffer]);
             //   console.info(uBuffer);
             //  console.info(uBuffer.buffer);
             //   console.info(uBuffer.buffer==aBuffer); //true
                var blob=null;
                try{
                    blob = new Blob([uBuffer], {type : format});
                }
                catch(e){
                    window.BlobBuilder = window.BlobBuilder ||
                    window.WebKitBlobBuilder ||
                    window.MozBlobBuilder ||
                    window.MSBlobBuilder;
                    if(e.name == 'TypeError' && window.BlobBuilder){
                        var bb = new window.BlobBuilder();
                        bb.append(uBuffer.buffer);
                        blob = bb.getBlob("image/jpeg");

                    }
                    else if(e.name == "InvalidStateError"){
                        blob = new Blob([aBuffer], {type : format});
                    }
                    else{

                    }
                }
               // alert(blob.size);
                return blob;
               
            };







/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.11 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.11',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite and existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part, length = ary.length;
            for (i = 0; i < length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = name.split('/');
                    lastIndex = name.length - 1;

                    // If wanting node ID compatibility, strip .js from end
                    // of IDs. Have to do this here, and not in nameToUrl
                    // because node allows either .js or non .js to map
                    // to same file.
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                        name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                    }

                    name = normalizedBaseParts.concat(name);
                    trimDots(name);
                    name = name.join('/');
                } else if (name.indexOf('./') === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return  getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if(args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

/**
 * Created by SongJing on 2017/8/15.
 */
dvStruct.mprOpenFlag = false;

// MPR参数传递全局对象
dvStruct.mprDataInfo = {
    wc: 1,
    ww: 1,
    intercept: 1.0,
    slope: 1.0,
    patientName: "mpr",
    studyDate: "mpr",
    studyTime: "mpr",
    sex: "mpr" 

};



//显示窗位窗宽
function getQuickWwwc(modalityVal, code) {
    dvStruct.mprDataInfo.wwwcQuick=[];
    console.log(modalityVal, code);
    $.ajax({
        type: 'post',
        data: {
            opt: 'GetWSet',
            code: code,
            modality: modalityVal
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            // console.log(data);
            var json = eval('(' + data + ')');
            if (json.result == true) {
                $.each(json.message, function (key, val) {
                    var obj={
                        name:val.Name,
                        wc:val.WL,
                        ww:val.WW
                    };
                    dvStruct.mprDataInfo.wwwcQuick.push(obj);
                });
            }
        }
    });
}
/**
 * Created by SongJing on 2017/4/13.
 * 全局适用变量
 */
//全局变量

//信息字典
var infoDic = new Array();
infoDic["序列编号"]="print-info-SeNo";
infoDic["图像序号"]="print-info-nowNo";
infoDic["窗位窗宽"]="print-info-wwwl";
infoDic["机构名称"]="print-info-InstitutionName"; 
infoDic["患者姓名"]="print-info-PatientName";
infoDic["患者ID号"]="print-info-PatientID";
infoDic["患者年龄/性别"]="print-info-PatientAgeSex";
infoDic["患者出生日期"]="print-info-PatientBirthDate";
infoDic["检查部位"]="print-info-ProtocolName";
infoDic["检查描述"]="print-info-StudyDescription";
infoDic["千伏/毫安"]="print-info-mAkvp";
infoDic["FOV"]="print-info-fov";
infoDic["FS"]="print-info-MagneticFieldStrength";
infoDic["TR/TE"]="print-info-TrTe";
infoDic["检查日期"]="print-info-studyDate";
infoDic["层厚/实际相对位置"]="print-TL";
infoDic["层间距"]="print-info-SpacingBetweenSlices";
infoDic["图像位置"]="print-info-imgPosition";
infoDic["检查模态"]="print-info-modality";
infoDic["图像方位"]="print-info-imgOriention";
infoDic["检查时间"]="print-info-studyTime";
infoDic["采样率"]="print-info-samplesP";
infoDic["登记编号"]="print-info-accessionNum";


//    打印页面的四角信息设置  显示时按设置的显示
var infoScreenArr={
    ltInfo:["print-info-nowNo","print-info-SeNo","print-info-ProtocolName","print-info-StudyDescription"],
    lbInfo:["print-info-zoom","print-info-wwwl","print-info-TL"],
    rtInfo:["print-info-accessionNum","print-info-InstitutionName","print-info-PatientName","print-info-PatientID","print-info-PatientBirthDate","print-info-PatientAgeSex"],
    rbInfo:["print-info-kvp","print-info-mAkvp","print-info-MagneticFieldStrength","print-info-TrTe","print-info-studyDate"]
};
//清空屏幕信息显示的控制对象infoScreenArr
function emptyInfoScreenArr() {
    infoScreenArr.ltInfo.length=0;
    infoScreenArr.lbInfo.length=0;
    infoScreenArr.rtInfo.length=0;
    infoScreenArr.rbInfo.length=0;
}

//socket
var enableStateVR=true;//VR处理状态

//本地测试地址
//          var urlInit ="61.190.254.59:8080";
// var urlInit ="192.168.2.14:8888";
//线上地址
 var urlInit =window.location.host;


 


/**
 * Created by SongJing on 2017/3/28.
 * 一些可公用的方法
 */

/*
 * 判断字符串的字节数
 * */
function getByte(str){
    var char = str.replace(/[^\x00-\xff]/g, '**');
    return char.length;
}

/*
 * 使用js截取前len字节的字符串，

 str 要截取的字符穿

 len要截取的长度，根据字节计算

 suffix截取前len个后，其余的字符的替换字符一般用“…”
 */
function cutString(str,len,suffix){
    if(!str) return "";
    if(len<= 0) return "";
    if(!suffix) suffix = "";
    var templen=0;
    for(var i=0,len1=str.length;i<len1;i++){
        if(str.charCodeAt(i)>255){
            templen+=2;
        }else{
            templen++
        }
        if(templen == len){
            return str.substring(0,i+1)+suffix;
        }else if(templen >len){
            return str.substring(0,i)+suffix;
        }
    }
    return str;
}

/*
 * 判断:当前元素是否是被筛选元素的子元素
 * */
jQuery.fn.isChildOf = function (b) {
    return (this.parents(b).length > 0);
};
/*
 * 判断:当前元素是否是被筛选元素的子元素或者本身
 * */
jQuery.fn.isChildAndSelfOf = function (b) {
    return (this.closest(b).length > 0);
};
/*
 * 深拷贝对象Obj
 * */
var deepCopy1 = function (source) {
    var result = {};
    for (var key in source) {
        result[key] = typeof source[key] === 'object' ? deepCopy1(source[key]) : source[key];
    }
    return result;
};
/*
 * 获取指定字体和字号获取字体高度 单位px
 * */
function getFontHeight(fontSize, fontType) {
    var fontHeight;
    var dd = document.createElement("div");
    dd.id = "fontHeight";
    // dd.style.cssText="padding:0;visibility:hidden;font:微软雅黑;font-size:7px";
    dd.style.cssText = "padding:0;visibility:hidden;font-family:" + fontType + ";font-size:" + fontSize + "px";//pictos
    dd.innerHTML = '测试';
    document.body.appendChild(dd);
    // alert(dd.offsetHeight);
    fontHeight = dd.offsetHeight;
    $("#fontHeight").remove();
    return fontHeight;
}



/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面样式清除，数据清空操作
 */
/*
 * 清除右侧缩略图图像的选中样式
 * */
function clearLeftboxSelecCss() {
    printStruct.drag.dragImageArr.seNo.length = 0;
    printStruct.drag.dragImageArr.imageId.length = 0;
    $('.imgLiSelected').each(function () {
        $(this).removeClass('imgLiSelected');
    });
}
/*
 * 清除打印区域所有的imgBox选中样式
 * */
function clearSelecImgBoxCss() {
    $('.imgBoxSelected').each(function () {
        $(this).removeClass("imgBoxSelected");
    });
}
/*
 * 清除打印区域所有的imgViewport选中样式
 * */
function clearSelecImgViewportCss() {
    $('.imgViewportSelected').each(function () {
        $(this).removeClass("imgViewportSelected");
    });
}
/*
 * 图像同步的基图像标识清除
 * */
function emptyBaseImgCss() {
    $('.procHandle').each(function () {
        $(this).removeClass("procHandle");
    });
}
/*
 * 清空打印操作中的临时图像记录
 * （printStruct.viewportArr用完后记得调用此方法）
 * */
function clearImgRecord() {
    printStruct.viewportArr.imageId.length = 0;
    printStruct.viewportArr.seNo.length = 0;
    printStruct.viewportArr.viewport.length = 0;
}
/*
 * 关闭拖动时的相关参数和标志
 * */
function clearDragPara() {
    printStruct.drag.dragFlag = false;//关闭拖动
    printStruct.drag.dragImageArr.imageId.length = 0;
    printStruct.drag.dragImageArr.seNo.length = 0;
}
/*
 * 关闭打印页面时的数据清空
 * */
function emptyImgData() {
    printStruct.openFlag = false;//标志胶片打印页面是否打开
    printStruct.lineBlank = 2;//控制图像间的间隔
    printStruct.procObj = "procImg";//默认处理对象为当前选中图像
    printStruct.procType = "null";
    printStruct.procType2 = "null";
    printStruct.printpage.pageIndex = 0;
    printStruct.printpage.pagetotal = 0;
    printStruct.printpage.row = 1;
    printStruct.printpage.col = 1;
    //清空打印页面
    $('.printPage').each(function (k, val) {
        if (k > 0) {
            $(this).remove();
        }
    });
    describe();
    $("#layoutRadio1").attr('checked');
    var layoutStr = "胶片布局" + "(" + 1 + "X" + 1 + ")";
    $('.filmLayout').text(layoutStr);
    $("input[name='way']").removeAttr('checked');
    $("input[name='way']").eq(0).prop('checked', 'checked');
    $("#printArea").remove();//移除本地打印的临时iframe
//   清空拼接相关参数
    joinOutputIndex = 0;//拼接图像的图像索引编号
    joinOutputObj = [];//拼接图像的图像数据与图像信息
    joinObj = [];//参与拼接的对象,即一张拼接图像的子图集合
}
/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的图像拖动的相关方法
 */


if (!printStruct) {
    var printStruct = {};
}

/*
 * 拖动时的相关参数，定义为一个对象方便修改和访问
 * */
printStruct.drag = {
    dragFlag: false,
    dragObj: "",
    mousedown: false,
    mousemove: false,
    mouseup: false,
    seNo: "",
    dragImageArr: {
        seNo: [],
        imageId: []
    }
};

/*
 * 响应胶片打印页面的图像拖动
 * */
printStruct.dragToPrint = {
    /*
     * 创建拖动时的div块
     * */
    getDiv: (function () {
        var dragToPrintDiv;
        return function () {
            return dragToPrintDiv || (function () {
                    var tmp = '<div style="visibility: hidden;width: 50px;height:50px" id="js-dragToPrintDiv" class="dragToPrintDiv" ></div>';//拖动的缩略图
                    $(document.body).append(tmp);
                    dragToPrintDiv = document.getElementById('js-dragToPrintDiv');
                    var o = printStruct.dragToPrint;
                    var size = o.divSize;
                    size.w = $(dragToPrintDiv).outerWidth();
                    size.h = $(dragToPrintDiv).outerHeight();
                    return dragToPrintDiv;
                })()
        }
    })(),
    suid: undefined,
    /*
     * 隐藏拖动时的div块
     * */
    clear: function () {
        var o = printStruct.dragToPrint;
        o.suid = undefined;
        var div = o.getDiv();
        $(div).css('visibility', 'hidden');
    },
    pos: {
        top: 0, left: 0,
        x: 0, y: 0,
        lastX: 0, lastY: 0
    },
    divSize: {
        w: 0, h: 0
    },
    /*
     * 绘制拖动的div块
     * */
    on: function (suid, pos, e, imageId) {
        var o = printStruct.dragToPrint;
        o.suid = suid;
        var div = o.getDiv();
        //把图给你画进去再让你拖动
        var element = $('#js-dragToPrintDiv').get(0);
        //展开窗口 绘制选中的那张，拖动单张图像
        if (imageId != undefined) {
            cornerstone.disable(element);//清除上一次使用时留下的信息
            cornerstone.enable(element);
            cornerstoneTools.mouseInput.enable(element);
            cornerstone.loadImage(imageId).then(function (image) {
                cornerstone.displayImage(element, image);
            });
        }
        var w = $(div).width();
        o.pos.top = pos.top;
        o.pos.left = pos.left;
        o.pos.x = e.pageX;
        o.pos.y = e.pageY;
        o.pos.lastX = o.pos.x;
        o.pos.lastY = o.pos.y;
        $(div).css({
            top: ( e.pageY-55) + 'px', left: (e.pageX-55) + 'px'
        });//div的位置与鼠标位置保持相对位置
        $(div).css('visibility', 'visible');
        o.dragOn();
    },
    /*
     * 更新拖动div块的位置
     * */
    dragOn: function () {
        $(document.body).on('mousemove', function (e) {
            var x = e.pageX, y = e.pageY;
            var pos = printStruct.dragToPrint.pos;
            var div = printStruct.dragToPrint.getDiv();
            $(div).css({
                top: (e.pageY - 55) + 'px', left: (e.pageX-55) + 'px'
            });
            pos.lastX = x;
            pos.lastY = y;//最后拖动到的位置

        });
        $(document.body).on('mouseup mouseleave', function (e) {
            $(document.body).off('mouseleave');
            $(document.body).off('mousemove');
            $(document.body).off('mouseup');
            var o = printStruct.dragToPrint;
            var win = o.checkOn();//console.log(win);
            if (win) {
                // dvStruct.viewer.bindSeries(win,dvStruct.dragToPrint.suid);//把图像放进该窗口
            }
            o.clear();
        });
    },
    /*
     * 拖动检查
     * */
    checkOn: function () {
        //只是点一下
        var pos = printStruct.dragToPrint.pos;//console.log(pos);
        if (Math.abs(pos.lastX - pos.x) < 4 && Math.abs(pos.lastY - pos.y) < 4) {
            return undefined;
        }
        //拖拽判定
        var vArea = $('.contentBox');
        var ofs = $(vArea).offset();
        var w = $(vArea).width();
        var h = $(vArea).height();
        var minx = ofs.left, miny = ofs.top, maxx = ofs.left + w, maxy = ofs.top + h;
        //-------------------------------
        var div = printStruct.dragToPrint.getDiv();
        var divOfs = $(div).offset();
        var divW = $(div).outerWidth();
        var divH = $(div).outerHeight();
        var divminX = divOfs.left, divminY = divOfs.top, divmaxX = divOfs.left + divW, divmaxY = divOfs.top + divH;
        if (!(divmaxX <= minx || divminX >= maxx || divmaxY <= miny || divminY >= maxy)) {
            var centerx = (divminX + divmaxX) / 2;
            var centery = (divminY + divmaxY) / 2;
            var curPageID = "page" + $('.currentPageIndex').val();


            var row, col;
            row = $("#" + curPageID).attr('row');
            col = $("#" + curPageID).attr('col');
            var perW, perH;
            var pageWidth, pageHeight;
            pageWidth = $("#" + curPageID).width();
            pageHeight = $("#" + curPageID).height();
            perW = (pageWidth - row * 2 * printStruct.lineBlank + (row - 1) * printStruct.lineBlank) / row;
            perH = (pageHeight - col * 2 * printStruct.lineBlank + (col - 1) * printStruct.lineBlank) / col;

        }
        return undefined;
    }
};

var blankBox = true;//标记当前选中的imgBox是否有图像填充

/*
 * 响应拖动操作
 * 以拖动到图像上时，全部重新布局的方式;响应点击时的样式添加
 * */
function bindPrintDrag() {
    var dragState = {
        mousedown: false,
        mousemove: false,
        mouseup: false,
        seNo: 0,
        dragImageObj: {
            seNo: [],
            imageId: []
        }
    };
    /*
     * 判断拖动的对象是图像还是序列
     * */
    $(document).on('click', '.imgLi', function (e) {
        var clickDivID = $(e.target).parents('.imgUl').attr('id');//获取点击所在的Div
        dragState.seNo = parseInt(clickDivID.substr(9, clickDivID.length));//获取点击图像的序列编号

        if ($(this).parents('.orderUl').hasClass('expansionstate')) {//判断右侧图像是否为状态展开
            // console.log("拖图像=================================");        
            if ($(e.target).isChildAndSelfOf(".imgBox") == true) {//imgBox的子节点

                dragState.mousedown = true;
                if (dragState.mousedown == true && e.which == 1) {
                    var pos = $(this).offset();
                    printStruct.drag.dragFlag = true;
                    printStruct.drag.dragObj = "image";
                    var imageId = $(this).attr('imageid');
                    printStruct.dragToPrint.on(dragState.seNo, pos, e, imageId);
                    printStruct.drag.dragImageId = imageId;
                }
                if (printStruct.key.ctrlDown == true) {
                    $(this).addClass('imgLiSelected');
                }
                else if (printStruct.key.shiftDown == true) {
                    $(this).addClass('imgLiSelected');
                    multiSelecLeftbox();
                }
                else {
                    clearLeftboxSelecCss();
                    $(this).addClass('imgLiSelected');
                }
            }
        }
        else {
            if ($(e.target).isChildAndSelfOf(".imgBox") == true) {  //是imgBox的子节点，是允许拖动的元素
                var firstImgId=$(e.target).parents('.imgLi').attr('imageid');
                dragState.mousedown = true;
                if (dragState.mousedown == true && e.which == 1) {
                    var pos = $("#" + clickDivID).children(0).offset();
                    printStruct.dragToPrint.on(dragState.seNo, pos, e,firstImgId);
                    printStruct.drag.dragFlag = true;
                    printStruct.drag.dragObj = "series";
                }
            }
        }
       
    });
    /*
     * 判断拖动的位置
     * 拖动到有效位置
     * */
    $(document).on('click', '.printViewport ', function (e) {
        //拖放到有效位置
        var curPageID;
        var curPageIndex;
        var curViewportID;
        //拖动到无图像的位置，默认从第一空白位置开始填充
        if ($(e.target).attr('imgIn') == "false") {
            if (printStruct.drag.dragFlag == true) {
                clearSelecImgBoxCss();//清除样式
                clearSelecImgViewportCss();
                printStruct.drag.dragFlag = false;
                curPageID = $(e.target).parents('.printPage').attr('id');//当前page的id
                curPageIndex =parseInt(curPageID.substring(4, curPageID.length));
                curViewportID = $("div[imgIn=false]").attr('id'); //从最后的空白处开始填充图像
                var dragImgTotal;
                //拖动对象为图像
                if (printStruct.drag.dragObj == "image") {
                    //获取选择的图像（可多选，单选）
                    $('.imgLiSelected').each(function () {
                        var imageId0 = $(this).attr("imageid");
                        var seNo0 = $(this).attr('serino');
                        printStruct.drag.dragImageArr.imageId.push(imageId0);
                        printStruct.drag.dragImageArr.seNo.push(seNo0);
                        $(this).removeClass('imgLiSelected');
                    });
                    dragImgTotal = printStruct.drag.dragImageArr.imageId.length;
                }
                //拖动对象为序列
                else if (printStruct.drag.dragObj == "series") {
                    if(isNaN(dragState.seNo)){
                        dragImgTotal = joinOutputObj.length;//要插入的图像总数
                    }else{
                        dragImgTotal = dvStruct.seriesArr[dragState.seNo].dicomArr.length;//要插入的图像总数
                    }
                }
                // 无效的拖动
                else {
                    dragImgTotal = 0;
                }
                //判定拖动的图像总数大于0后，开始填充图像
                if (dragImgTotal > 0) {
                    var pagefillInID = curPageID;//当前页是装图像的初始页
                    var viewportfillInID = curViewportID;//当前viewportId是装图像的初始viewport
                    viewportfillInID = $("div[imgIn=false]").attr('id');
                    if (printStruct.drag.dragObj == "image") {
                        var fillCount = 0;
                        //循环填充图像
                        while (fillCount < dragImgTotal) {
                            while (viewportfillInID !== undefined && fillCount < dragImgTotal) {
                                var imageId = printStruct.drag.dragImageArr.imageId[fillCount];
                                var seNo = printStruct.drag.dragImageArr.seNo[fillCount];
                                fillImage(viewportfillInID, imageId, seNo);//填充图像
                                fillInfoOnLay(viewportfillInID);//填充图像信息
                                viewportfillInID = $("div[imgIn=false]").attr('id');//获取下一个viewportId
                                fillCount++;//记录绘制的图像数
                                //如果viewportfillInID无效，则添加新的布局页
                                if (fillCount < dragImgTotal && viewportfillInID == undefined) {
                                    pagefillInID = addSameLayoutPage(pagefillInID);//添加相同布局的新页
                                    viewportfillInID = $("div[imgIn=false]").attr('id');//获取下一个有效viewportId
                                }
                            }
                        }
                    }
                    else if (printStruct.drag.dragObj == "series") {
                        var fillCount = 0;
                        //循环填充图像
                        while (fillCount < dragImgTotal) {
                            while (viewportfillInID !== undefined && fillCount < dragImgTotal) {
                                var imageId ;
                                if(isNaN(dragState.seNo)){
                                    imageId= joinOutputObj[fillCount].imageId;
                                }
                                else {
                                    imageId= dvStruct.seriesArr[dragState.seNo].dicomArr[fillCount].imageId;
                                }
                                if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                                    $("div[imgIn=false]").parents('.printPage').show();
                                }
                                fillImage(viewportfillInID, imageId, dragState.seNo);//填充图像
                                fillInfoOnLay(viewportfillInID);//填充图像信息
                                viewportfillInID = $("div[imgIn=false]").attr('id');//获取下一个viewportId
                                fillCount++;//记录绘制的图像数
                                //如果viewportfillInID无效，则添加新的布局页
                                if (fillCount < dragImgTotal && viewportfillInID == undefined) {
                                    pagefillInID = addSameLayoutPage(pagefillInID);//添加相同布局的新页
                                    viewportfillInID = $("div[imgIn=false]").attr('id');//获取下一个有效viewportId
                                }
                            }
                        }
                    }
                }
                 printStruct.printpage.pageIndex = curPageIndex;
                $('.currentPageIndex').val(printStruct.printpage.pageIndex);
                showPageId(curPageID);//显示拖入初始页
                describe();
                infoLayShow(); 
                // $("#firstPage").click();//转到第一页
            }
            clearImgRecord();//清空记录，释放无用的数据对象
            removeInnerboxNo();//移除组合图像的格子编号
            clearDragPara();//关闭拖动时的相关参数和标志
        }
        // 拖动到有图像的位置
        else if ($(e.target).parents('.printViewport').attr('imgIn') == "true") {
            if (printStruct.drag.dragFlag == true) {
                clearSelecImgBoxCss();//清除样式
                clearSelecImgViewportCss();
                printStruct.drag.dragFlag = false;
                curPageID = $(e.target).parents('.printPage').attr('id');//当前page的id
                curPageIndex = parseInt(curPageID.substring(4, curPageID.length));
                curViewportID = $(e.target).parent('.printViewport').attr('id');//当前viewport的id
                $(e.target).parent('.printViewport').addClass('dragInLocal');//标记点击位置
                //记录图像从点击位置开始记录，开始填充图像，
                $('.printViewport').each(function ( ) {
                    if ($(this).attr('imgIn') == "true") {//确保box中有图
                        //先记录拖入的图像
                        if ($(this).hasClass('dragInLocal')) {
                            if (printStruct.drag.dragObj == "image") {
                                //获取选择的图像
                                $('.imgLiSelected').each(function () {
                                    var imageId0 = $(this).attr("imageid");
                                    var seNo0 = $(this).attr('serino');
                                    $(this).removeClass('imgLiSelected');
                                    printStruct.viewportArr.imageId.push(imageId0);
                                    printStruct.viewportArr.seNo.push(seNo0);
                                });
                            }
                            else if (printStruct.drag.dragObj == "series") {
                                var dragLength=0;
                                if(isNaN(dragState.seNo)){
                                    dragLength= joinOutputObj.length;
                                }
                                else{
                                    dragLength = dvStruct.seriesArr[dragState.seNo].dicomArr.length;
                                }
                                for (var i = 0; i < dragLength; i++) {
                                    var imageId;
                                    if(isNaN(dragState.seNo)){
                                        imageId= joinOutputObj[i].imageId;
                                    }
                                    else{
                                        imageId = dvStruct.seriesArr[dragState.seNo].dicomArr[i].imageId;
                                    }
                                    printStruct.viewportArr.imageId.push(imageId);
                                    printStruct.viewportArr.seNo.push(dragState.seNo);
                                }
                            }
                            $(this).removeClass("dragInLocal");//移除样式
                        }
                        var elementId = $(this).attr('id');     //记录原有图像
                        var element = $("#" + elementId).get(0);
                        printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                        printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                        cornerstone.disable(element);//关闭使能
                        $(this).attr('imageId', "");//移除相关属性
                        $(this).attr('seNo', "");
                        $(this).attr('imgIn', "false");
                    }
                });
                //填充图像
                if (printStruct.viewportArr.imageId.length > 0) {
                    dragImgTotal = printStruct.viewportArr.imageId.length;
                    var fillCount = 0;
                    var viewportfillInID = $("div[imgIn=false]").attr('id');
                    //循环填充图像
                    while (fillCount < dragImgTotal) {
                        while (viewportfillInID !== undefined && fillCount < dragImgTotal) {
                            var imageId = printStruct.viewportArr.imageId[fillCount];
                            var seNo =   printStruct.viewportArr.seNo[fillCount];
                            if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                                $("div[imgIn=false]").parents('.printPage').show();
                            }
                            fillImage(viewportfillInID, imageId, seNo);//填充图像
                            fillInfoOnLay(viewportfillInID);//添加图像信息
                            viewportfillInID = $("div[imgIn=false]").attr('id');
                            fillCount++;//记录绘制的图像数
                            if (fillCount < dragImgTotal && viewportfillInID == undefined) {
                                var pagefillInID = "page" + printStruct.printpage.pagetotal;
                                pagefillInID = addSameLayoutPage(pagefillInID);//添加相同布局的新页
                                viewportfillInID = $("div[imgIn=false]").attr('id');
                            }
                        }
                    }
                }
                clearImgRecord();//清空记录
                // $("#firstPage").click();//转到第一页
                printStruct.printpage.pageIndex = curPageIndex;
                $('.currentPageIndex').val(printStruct.printpage.pageIndex);
                showPageId(curPageID);//显示拖入初始页
                describe();
                infoLayShow();
            }
            clearImgRecord();//清空记录
            removeInnerboxNo();//移除组合图像的格子编号
            clearDragPara();//关闭拖动时的相关参数和标志
        }
        //选中状态处理
        if (printStruct.drag.dragFlag == false) {
            if ($(e.target).attr('imgIn') == "false") {
                blankBox = true;
                if (printStruct.key.ctrlDown == true) {
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).addClass("imgViewportSelected");
                }
                else if (printStruct.key.shiftDown == true) {
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).addClass("imgViewportSelected");
                    multiSelected(printStruct.procType2);
                }
                else {
                    clearSelecImgBoxCss();
                    clearSelecImgViewportCss();
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).addClass("imgViewportSelected");
                }
            }
            else if ($(e.target).parents('.printViewport').attr('imgIn') == "true") {
                blankBox = false;
                if (printStruct.key.ctrlDown == true) {
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).parents('.printViewport').addClass("imgViewportSelected");
                }
                else if (printStruct.key.shiftDown == true) {
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).parents('.printViewport').addClass("imgViewportSelected");
                    emptyBaseImgCss();
                    $(e.target).addClass("procHandle");
                    multiSelected(printStruct.procType2);
                }
                else {
                    emptyBaseImgCss();
                    if ($(e.target).parents('.printViewport').hasClass('imgViewportSelected') &&
                        (printStruct.procType2 != "null" && printStruct.procType2 != undefined)) {
                        $(e.target).parents('.printViewport').addClass("procHandle");//procHandle 图像操作同步时的基窗口标志
                        openProcEnable(printStruct.procType2);
                    }
                    else {
                        clearSelecImgBoxCss();
                        clearSelecImgViewportCss();
                    }
                    $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
                    $(e.target).parents('.printViewport').addClass("imgViewportSelected");
                }
                if (printStruct.procType2 != "null" && printStruct.procType2 != undefined) {
                    mainProcess(printStruct.procObj, printStruct.procType2);
                    openProcEnable(printStruct.procType2);
                }
            }
        }
    });

    /*
     *点击位置不是拖动有效范围时的标志清空
     * */
    $(document).on('click', function (e) {
        if ($(e.target).isChildAndSelfOf(".printWrapper") == false && $(e.target).isChildAndSelfOf(".imgBox") == false) {
            clearDragPara();//关闭拖动时的相关参数和标志
        }
    });
}


/**
 * Created by admin on 2016/3/21.
 * 主页面的相关操作 效果 初始化
 */


/*
 * resize监听
 * */
(function ($, h, c) {
    var a = $([]), e = $.resize = $.extend($.resize, {}), i, k = "setTimeout", j = "resize", d = j + "-special-event", b = "delay", f = "throttleWindow";
    e[b] = 250;
    e[f] = true;
    $.event.special[j] = {
        setup: function () {
            if (!e[f] && this[k]) {
                return false
            }
            var l = $(this);
            a = a.add(l);
            $.data(this, d, {w: l.width(), h: l.height()});
            if (a.length === 1) {
                g()
            }
        },
        teardown: function () {
            if (!e[f] && this[k]) {
                return false
            }
            var l = $(this);
            a = a.not(l);
            l.removeData(d);
            if (!a.length) {
                clearTimeout(i)
            }
        },
        add: function (l) {
            if (!e[f] && this[k]) {
                return false
            }
            var n;

            function m(s, o, p) {
                var q = $(this), r = $.data(this, d);
                r.w = o !== c ? o : q.width();
                r.h = p !== c ? p : q.height();
                n.apply(this, arguments)
            }

            if ($.isFunction(l)) {
                n = l;
                return m
            } else {
                n = l.handler;
                l.handler = m
            }
        }
    };
    function g() {
        i = h[k](
            function () {
                a.each(function () {
                    var n = $(this), m = n.width(), l = n.height(), o = $.data(this, d);
                    if (m !== o.w || l !== o.h) {
                        n.trigger(j, [o.w = m, o.h = l])
                    }
                });
                g()
            }, e[b])
    }
})(jQuery, this);

function build_dicom_imgViewer_templates(dicom_imgViewer_tmps) {
    dicom_imgViewer_tmps.container = _.template($('#dvContainerTemp').text());
    dicom_imgViewer_tmps.viewportWrapper = _.template($('#viewportWrapperTemp').text());
    dicom_imgViewer_tmps.preview = _.template($('#dvPreviewTemp').text());
    dicom_imgViewer_tmps.seriesWindow = _.template($('#seriesWindowTemp').text());
}

var get_dicom_imgViewer_templates = (function () {
    var dicom_imgViewer_tmps;
    return function (name) {
        if (_.isUndefined(name)) {
            return dicom_imgViewer_tmps || (function (name) {
                    dicom_imgViewer_tmps = {};
                    build_dicom_imgViewer_templates(dicom_imgViewer_tmps);
                    return dicom_imgViewer_tmps;
                })();
        } else {
            if (_.isObject(dicom_imgViewer_tmps)) {
                return dicom_imgViewer_tmps[name];
            } else {
                return (function (name) {
                    dicom_imgViewer_tmps = {};
                    build_dicom_imgViewer_templates(dicom_imgViewer_tmps);
                    return dicom_imgViewer_tmps[name];
                })();
            }
        }
    }
})();

/*
 * 影像页面窗口刷新
 * */
function onViewportUpdated(e) {
    // console.log(e);
    var viewport = cornerstone.getViewport(e.target);//element能找到。。然后current Image
    var wrapper = dvStruct.viewer.getWrapperById($(e.target).attr('id'));//cornerstone的内置的一种对象
    var wrapperBox = $(e.target).parent();//这个是一个jquery找的dom的对象

    $(wrapperBox).find('.js-info-wwwl').text("WL/WW: " + Math.round(viewport.voi.windowCenter) + "/" + Math.round(viewport.voi.windowWidth));
    //$(wrapperBox).find('.js-info-zoom').text("Zoom: " + viewport.scale.toFixed(2));

    var toolData = cornerstoneTools.getToolState(wrapper.element, 'stack');
    if (toolData === undefined || toolData.data === undefined || toolData.data.length === 0) {
        return;
    }
    var stack = toolData.data[0];
    // Update Image number overlay
    $(wrapperBox).find('.js-info-nowNo').text('Im: ' + (parseInt(stack.currentImageIdIndex) + 1));
    var imageId = cornerstone.getImage(e.target).imageId;
    //console.log(imageId);
    var suid = wrapper.suid;
    if (imageId.indexOf("loadJoinImg") >= 0) {
        return;//imageJoin
    }

    var info = dvStruct.viewer.findOriInfoByIds(imageId, suid);//console.log(info);
    if (info) {
        var theT = info.SeriesInfo.SliceThickness.val, theL = info.SeriesInfo.SliceLocation.val;
        if (theT || theL) {
            try {
                theT = theT ? parseFloat(theT).toFixed(1) : theT;
                theL = theL ? parseFloat(theL).toFixed(1) : theL;
            } catch (e) {
                console.error(e);
            }
            $(wrapperBox).find('.js-TL').text('T: ' + theT + 'mm L: ' + theL + 'mm');//这个跟专业软件显示得不一样呢，这个要算吧
        }
    }
}

//绘制方向标志设置参数
var config = {
    drawAllMarkers: true
};

/*
 * 绘制图像的R L H A标志
 * */
cornerstoneTools.orientationMarkers.setConfiguration(config);

/*
 * 检查窗口同步
 * */
function checkAndSynByWinId(winId) {
    if (dvStruct.synposition.enable) {
        var win = dvStruct.viewer.findWin(winId);
        var wrapper = win.wrappers[0];
        var stack = wrapper.stack;
        var imageId = stack.imageIds[stack.currentImageIdIndex];
        dvStruct.synposition.findAndSyn(imageId, wrapper);
    }
}

/*
 * 响应主页面的点击操作
 * */
(function ($) {
    //取名短点
    var tmps;
    //默认参数
    var defaults = {
        viewer: dvStruct.viewer
    };

    /*
     * 响应页面高宽变化
     * dvResize 方法 sj
     * */
    function dvResize() {
        var h = this.find('.dvContainer').height();
        var w = this.find('.js-imageViewer').width();
        var th = this.find('.js-topPannel').height();
        this.find('.js-imageViewer').height(h - th);
        // this.find('.js-imageViewer').width( $('.js-topPannel').width()-$('.toolV').width()-this.opts.viewer.col);//sjadd
        this.find('.js-imageViewer').width($('.js-topPannel').width() - $('.logo').width());//sjadd
        var vh = this.find('.js-imageViewer').height();
        var vw = this.find('.js-imageViewer').width();
        var eachW, eachH;
        if (dvStruct.dblclickFlag.winNo != 16) {//双击操作情况
            eachW = parseInt(vw);
            eachH = parseInt(vh);
            dvStruct.viewer.eachW = eachW;//用于计算子窗
            dvStruct.viewer.eachH = eachH;

            this.find("[class='seriesWindow checked']").css({'height': eachH + 'px', 'width': eachW + 'px'});//外框
            this.find('.seriesWindow checked').css({'height': eachH + 'px', 'width': eachW + 'px'});//canvas
            this.find("[class='seriesWindow']").css({'height': 0 + 'px', 'width': 0 + 'px'});
            this.find("[class='seriesWindow']").hide();

            //子窗的size
            this.find("[class='seriesWindow']").each(function () {
                var wid = $(this).attr('id');
                var size = dvStruct.viewer.calInnerEachSize(wid);
                $(this).find('.viewportWrapper').css({'height': 0 + 'px', 'width': 0 + 'px'});
            });
            this.find("[class='seriesWindow checked']").each(function () {
                var wid = $(this).attr('id');
                var size = dvStruct.viewer.calInnerEachSize(wid);
                $(this).find('.viewportWrapper').css({'height': size[1] + 'px', 'width': size[0] + 'px'});
            });
            //画布要重新处理
            dvStruct.viewer.eachElement({
                callback: function (element) {
                    cornerstone.resize(element, true);
                }
            });
        }
        else {//非双击操作情况
            eachW = parseInt(vw / this.opts.viewer.col);
            eachH = parseInt(vh / this.opts.viewer.row);
            //大窗的size
            this.find("[class='seriesWindow']").show();
            this.find('.seriesWindow').css({'height': eachH + 'px', 'width': eachW + 'px'});
            dvStruct.viewer.eachW = eachW;
            dvStruct.viewer.eachH = eachH;
            //只有一个窗时选中
            if (dvStruct.viewer.row == 1 && dvStruct.viewer.col == 1) {
                $(".seriesWindow:first").click();
            }

            //子窗的size
            this.find('.seriesWindow').each(function () {
                var wid = $(this).attr('id');
                var size = dvStruct.viewer.calInnerEachSize(wid);
                $(this).find('.viewportWrapper').css({'height': size[1] + 'px', 'width': size[0] + 'px'});
            });

            //画布要重新处理
            dvStruct.viewer.eachElement({
                callback: function (element) {
                    //  console.log(element);
                    cornerstone.resize(element, true);
                }
            });
        }

        $('.viewportWrapper').each(function () {
            if($(this).attr('rulerInfo')){
                // $(this).find('.RulerBoxV').show();
                // $(this).find('.RulerBoxH').show();
                var rulerInfo=JSON.parse($(this).attr('rulerInfo'));
                // console.log("1======reset==========");
                // console.log(rulerInfo);
                drawRuler($(this),rulerInfo,1);
            }
            else{
                $(this).find('.RulerBoxV').hide();
                $(this).find('.RulerBoxH').hide();
            }

        });
    }

    dvStruct.dvResize = dvResize;
    /*
     * 隐藏右侧图像预览栏时影像窗口的高宽变化 sj add
     * */
    function leftResize(viewerW) {
        var h = $('.dvContainer').height();
        var w = $('.js-imageViewer').width();
        var th = $('.js-topPannel').height();
        $('.js-imageViewer').height(h - th);
        $('.js-imageViewer').width(viewerW - dvStruct.viewer.col);
        var vh = $('.js-imageViewer').height();
        var vw = $('.js-imageViewer').width();
        var eachW, eachH;

        eachW = parseInt(vw / dvStruct.viewer.col);
        eachH = parseInt(vh / dvStruct.viewer.row);
        // eachW = parseInt(vw / this.opts.viewer.col);
        // eachH = parseInt(vh / this.opts.viewer.row);
        //大窗的size
        $("[class='seriesWindow']").show();
        $('.seriesWindow').css({'height': eachH + 'px', 'width': eachW + 'px'});
        dvStruct.viewer.eachW = eachW;
        dvStruct.viewer.eachH = eachH;
        //只有一个窗时选中
        if (dvStruct.viewer.row == 1 && dvStruct.viewer.col == 1) {
            $(".seriesWindow:first").click();
        }
        //子窗的size
        //子窗的size
        $('.seriesWindow').each(function () {
            var wid = $(this).attr('id');
            var size = dvStruct.viewer.calInnerEachSize(wid);
            $(this).find('.viewportWrapper').css({'height': size[1] + 'px', 'width': size[0] + 'px'});
        });
        // this.find("[class='seriesWindow']").each(function () {
        //     var wid = $(this).attr('id');
        //     var size = dvStruct.viewer.calInnerEachSize(wid);
        //     $(this).find('.viewportWrapper').css({'height': size[1] + 'px', 'width': size[0] + 'px'});
        // });
        //画布要重新处理
        dvStruct.viewer.eachElement({
            callback: function (element) {
                //  console.log(element);
                cornerstone.resize(element, true);
            }
        });
    }

    /*
     *影像页面操作的相关事件
     * */
    var containerId = 'dv'; //容器id
    $.fn.extend({
        "dv": function (options) {
            // checkLegal();
            //this----jquery对象
            //console.log(this);
            //覆盖默认参数
            var opts = this.opts = $.extend({}, defaults, options);//console.log(opts);
            //模板
            tmps = get_dicom_imgViewer_templates();
            dvStruct.container = this;
            //html生成
            this.append(tmps.container({'containerId': containerId}));//容器
            topScrollX();//top_tool滚动条 主页面顶部工具栏滚动条示否

            var viewerNode = this.find('.js-imageViewer');
            for (var i = 0,len0= opts.viewer.maxCol * opts.viewer.maxRow; i <len0; i++) {
                var id = guid(8, 'win');
                //外窗html
                viewerNode.append(tmps.seriesWindow({
                    no: i, id: id
                }));
                //外窗对象
                var newWin = dvStruct.viewer.addNewWin(id, i);
                //小窗----实际窗
                var winNode = document.getElementById(id);
                for (var j = 0,len1=opts.viewer.maxInnerCol * opts.viewer.maxInnerRow; j < len1; j++) {
                    var eid = guid(8, 'ele');
                    var iid = guid(8, 'view');
                    //内窗html
                    $(winNode).append(tmps.viewportWrapper({
                        no: j, id: iid, eid: eid
                    }));
                    //内窗对象
                    var arg = {
                        pid: id,
                        eid: eid,
                        element: document.getElementById(eid)
                    };
                    cornerstone.enable(arg.element);//先enable了
                    var wrapper = dvStruct.viewer.createWrapper(arg, j);
                    newWin.wrappers.push(wrapper);
                }
            }
            //初始展示的布局数目
            if (_.isObject(opts.defaultShow)) {
                if (opts.defaultShow.num <= 1) {
                } else if (opts.defaultShow.num <= 2) {
                    dvStruct.viewer.col = 2;
                    dvStruct.viewer.row = 1;
                } else if (opts.defaultShow.num <= 4) {
                    dvStruct.viewer.col = 2;
                    dvStruct.viewer.row = 2;
                } else if (opts.defaultShow.num <= 6) {
                    dvStruct.viewer.col = 3;
                    dvStruct.viewer.row = 2;
                } else if (opts.defaultShow.num <= 9) {
                    dvStruct.viewer.col = 3;
                    dvStruct.viewer.row = 3;
                } else if (opts.defaultShow.num <= 12) {
                    dvStruct.viewer.col = 4;
                    dvStruct.viewer.row = 3;
                } else {
                    dvStruct.viewer.col = 4;
                    dvStruct.viewer.row = 4;
                }
                var len = Math.min(opts.defaultShow.suidArr.length, 16);
                for (var i = 0; i < len; i++) {
                    dvStruct.addWaitingBind(opts.defaultShow.suidArr[i], dvStruct.viewer.winArr[i]);
                }
            }

            //布局ready
            dvResize.call(this);
            dvStruct.viewer.initBtnDiy();//按钮状态初始化
            //画布元素初始化
            dvStruct.viewer.eachWin({
                callback: function (win) {
                    for (var j = 0,len=win.wrappers.length; j < len; j++) {
                        var ele = win.wrappers[j].element;
                        var wrapper = win.wrappers[j];
                        cornerstoneTools.addStackStateManager(ele, ['stack', 'playClip', 'referenceLines']);
                        cornerstoneTools.addToolState(ele, 'stack', wrapper.stack);

                        $(ele).on("CornerstoneImageRendered", onViewportUpdated);
                    }
                }
            });
            //可拖放图像
            bindDragToCanv();
            //可识别鼠标在布局区域
            dvStruct.init.checkMouseOnViewpoint();
            //窗口变化
            $(dvStruct.container).resize(function () {
                dvResize.call(dvStruct.container);
            });
            //快捷键
            try {
                var listener = new window.keypress.Listener();
                var my_combos = listener.register_many([
                    {
                        "keys": "pageup",
                        "is_exclusive": true,
                        "on_keydown": function () {
                            console.log('pageup');
                            dvStruct.fun.prevPage();
                        },
                        "on_keyup": function (e) {
                        },
                    },
                    {
                        "keys": "pagedown",
                        "is_exclusive": true,
                        "on_keydown": function () {
                            dvStruct.fun.nextPage();
                        },
                        "on_keyup": function (event) {
                            // Normally because we have a keyup event handler,
                            // event.preventDefault() would automatically be called.
                            // But because we're returning true in this handler,
                            // event.preventDefault() will not be called.
                            //return true
                        },
                    }
                ]);
            } catch (e) {
                console.error(e);
            }

            /*
             * 滑轮翻页
             * 上下翻页滚动
             * 不能绑dvStruct.container，不然影响左边
             * */
            $(dvStruct.container).find('.viewer').on('mousewheel DOMMouseScroll', function (e) {
                // Firefox e.originalEvent.detail > 0 scroll back, < 0 scroll forward
                // chrome/safari e.originalEvent.wheelDelta < 0 scroll back, > 0 scroll forward
                if (e.originalEvent.wheelDelta < 0 || e.originalEvent.detail > 0) {
                    dvStruct.fun.nextPage();
                } else {
                    dvStruct.fun.prevPage();
                }
                //prevent page fom scrolling
                return false;
            });

            unit.speedSlider.ini();//播放速度滑竿

            /*
             * 鼠标按下时检查按下的是哪个键
             * */
            function mouseDownCheckE(e, _this, filter) {
                if (filter && filter != e.which)return -1;
                var d = 0;//避免重复
                if ($(_this).hasClass('rightBtnActive')) {
                    d = 4;
                    $(_this).removeClass('rightBtnActive');
                    dvStruct.viewer.rightBtnDisable();//
                }
                if ($(_this).hasClass('leftBtnActive')) {
                    d = 1;
                    $(_this).removeClass('leftBtnActive');
                    dvStruct.viewer.leftBtnDisable();//
                }
                if ($(_this).hasClass('middleBtnActive')) {
                    d = 2;
                    $(_this).removeClass('middleBtnActive');
                    dvStruct.viewer.middleBtnDisable();//
                }
                if (3 == e.which) {//右键
                    $('.btnArea').removeClass('rightBtnActive');
                    $(_this).addClass('rightBtnActive');
                    var type = 4;
                    if (d != 4)dvStruct.viewer.rightBtnDisable();//
                } else if (2 == e.which) {//中键
                    $('.btnArea').removeClass('middleBtnActive');
                    $(_this).addClass('middleBtnActive');
                    var type = 2;
                    if (d != 2)dvStruct.viewer.middleBtnDisable();
                } else {
                    $('.btnArea').removeClass('leftBtnActive');
                    $(_this).addClass('leftBtnActive');
                    var type = 1;
                    if (d != 1)dvStruct.viewer.leftBtnDisable();
                }
                return type;
            }
            console.log("counter:" + AuthorizeDateCheck);
            if (AuthorizeDateCheck < 15 && AuthorizeDateCheck > 0) {
                var tips = "您的授权还有" + AuthorizeDateCheck + "天过期，请尽快联系工作人员!";
                $(".dateTips").text(tips);
            }

            /*
             * 选中图像
             * 添加图像框选中样式
             * */
            $('.seriesWindow').click(function (e) {//console.log(e);
                //同步工具栏中播放按钮的状态
                var playState = $(this).attr('playState');
                if (playState == "play") {
                    $('.js-play').hide();
                    $('.js-stop').show();
                } else {
                    $('.js-stop').hide();
                    $('.js-play').show();
                }
                if (!$(this).hasClass('checked')) {
                    $('.seriesWindow').removeClass('checked');
                    $(this).addClass('checked');
                    //判断同步
                    checkAndSynByWinId($(this).attr('id'));
                    //如果选中了定位线
                    if ($('.js-reference').find('.btn').hasClass('btnActive')) {
                        //定位线关开
                        $('.js-reference').click();
                        $('.js-reference').click();
                    }
                }
            });

            /*
             * 取消图像框选中样式----右键
             * */
            $(".seriesWindow").on('contextmenu', function (e) {//console.log(e);

                $(".seriesWindow").removeClass('checked');
                $(this).addClass('checked');
                if ($('.btnArea.rightBtnActive').length == 0 || $('.btnArea.rightBtnActive').hasClass('js-default')) {
                    //同步工具栏中播放按钮的状态
                    var playState = $(this).attr('playState');
                    if (playState == "play") {
                        $('.js-play').hide();
                        $('.js-stop').show();
                    } else {
                        $('.js-stop').hide();
                        $('.js-play').show();
                    }
                    /*
                     * 屏蔽样式取消功能
                     * */
                    /*  if ($(this).hasClass('checked')) {
                     $(this).removeClass('checked');
                     } else {
                     $(".seriesWindow").removeClass('checked');
                     $(this).addClass('checked');
                     }*/

                    var type = mouseDownCheckE(e, this);
                    dvStruct.viewer.saveDiyStat('js-wwwl', type);
                    dvStruct.viewer.btnStates.wwwc.enable = true;
                    dvStruct.viewer.btnStates.wwwc.type = type;
                    setAllEle(function (element) {
                        //cornerstoneTools.wwwc.activate(element, type);
                        dvStruct.fun.checkAndSetActive(element);
                    });


                }
            });

            // 窗口中的双击操作
            /*
             * 对选定窗口进行缩放处理达到双击放大当前窗口的效果
             * */
            $('.js-imageViewer').dblclick(function () {
                // console.log(dvStruct.dblclickFlag.clickState);
                if (dvStruct.dblclickFlag.clickState === false) {
                    $('.js-fulScreen').hide();
                    $('.js-restore').show();
                    dvStruct.dblclickFlag.winNo = $('.js-imageViewer .checked').attr('no');//获取点击窗口的窗口编号
                    if (dvStruct.dblclickFlag.winNo != 16) {
                        dvStruct.dvResize.call(dvStruct.container);//更新窗口
                        dvStruct.dblclickFlag.clickState = true;//设置双击状态标志
                    }
                }
                else {
                    $('.js-fulScreen').show();
                    $('.js-restore').hide();
                    // console.log("恢复");
                    dvStruct.dblclickFlag.winNo = 16;
                    dvStruct.dvResize.call(dvStruct.container);//更新窗口
                    dvStruct.dblclickFlag.clickState = false;//设置双击状态标志
                }
            });

            //窗口最大化
            $('.js-fulScreen').click(function () {
                $('.js-fulScreen').hide();
                $('.js-restore').show();
                if (!$(this).parents('.seriesWindow').hasClass('checked')) {
                    $('.seriesWindow').removeClass('checked');
                    $(this).parents('.seriesWindow').addClass('checked');
                    //判断同步
                    checkAndSynByWinId($(this).parents('.seriesWindow').attr('id'));
                    //如果选中了定位线
                    if ($('.js-reference').find('.btn').hasClass('btnActive')) {
                        //定位线关开
                        $('.js-reference').click();
                        $('.js-reference').click();
                    }
                }
                dvStruct.dblclickFlag.winNo = $(this).parents('.seriesWindow').attr('no'); //获取点击窗口的窗口编号
                if (dvStruct.dblclickFlag.winNo != 16) {
                    dvStruct.dvResize.call(dvStruct.container);//更新窗口
                    dvStruct.dblclickFlag.clickState = true;//设置双击状态标志
                }

            });
            //恢复窗口
            $('.js-restore').click(function () {
                $('.js-fulScreen').show();
                $('.js-restore').hide();
                dvStruct.dblclickFlag.winNo = 16;
                dvStruct.dvResize.call(dvStruct.container);//更新窗口
                dvStruct.dblclickFlag.clickState = false;//设置双击状态标志
            });


            //顶部工具栏按钮响应begin
            /*
             * 屏蔽右键
             * */
            $(".js-default,.tool_btn ,.tool_window ,.js-clearToolState,.js-zoom,.js-pan,.js-wwwl,.js-probeUnSave,.js-probe,.js-length,.js-angle,.js-ellipse,.js-rect,.js-heartScale,.js-cw,.js-ccw,.js-reference,.js-refresh").on('contextmenu', function (e) {
                e.preventDefault();
                return false;
            });


            /*
             * 鼠标样式
             * */
            $(".viewport canvas").mouseenter(function () {

                if ($('.imgTool .btnActive').parent().hasClass("js-wwwl")) {
                    $(this).parent().css({cursor: "url(ipacsdv/css/img/pointer/wwwl.cur),auto"});
                    // $(this).parent().css({cursor:"not-allowed"});
                }
                if ($('.imgTool .btnActive').parent().hasClass("js-pan")) {
                    $(this).parent().css({cursor: "move"});
                }
                if ($('.imgTool .btnActive').parent().hasClass("js-zoom")) {
                    $(this).parent().css({cursor: "zoom-in"});
                }
                if ($('.imgTool .btnActive').parent().hasClass("js-zoomPart")) {
                    $(this).parent().css({cursor: "cell"});
                }
                if ($('.js-browseSeries .btn').hasClass("btnActive")) {
                    $(this).parent().css({cursor: "ns-resize"});//row-resize
                    // $(this).parent().css({cursor:"url(ipacsdv/css/img/pointer/seriesbrowse.ico),auto"});
                }
            });

            //默认右键调窗
            $(".viewport canvas").mousedown(function (e) {
                if (3 == e.which) {
                    $(this).parent().css({cursor: "url(ipacsdv/css/img/pointer/wwwl.cur),auto"});
                }
            });
            $(".viewport canvas").mouseup(function (e) {
                if (3 == e.which) {
                    $(this).parent().css({cursor: "default"});
                }
            });
            $(".viewport canvas").mouseout(function () {
                $(this).parent().css({cursor: "default"});
            });
            /*
             * 按钮点中样式
             * 图像测量操作及鼠标翻页
             * 同一时间只能有一个操作开关打开
             * */
            $('.imgTool ').click(function () {
                $('.js-browseSeries').find('.btn').removeClass('btnActive');
                disablePaging();//关闭翻页功能
                if ($(this).find('.btn').hasClass('btnActive')) {
                    //$(this).find('.btn').removeClass('btnActive');
                }
                else {
                    $('.imgTool').each(function () {
                        $(this).find('.btn').removeClass('btnActive');
                    });
                    $(this).find('.btn').addClass('btnActive');
                }
                browseSeriesObj.state = false;//图像翻页关闭
            });

            /*
             * 鼠标默认状态
             * 关闭图像测量开关
             * */
            $('.js-default').mousedown(function (e) {
                //关闭图像测量开关
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-default', type);
                setAllEle(function (element) {
                    dvStruct.fun.checkAndSetActive(element);
                });
                //清除按钮样式
                $('.imgTool').each(function () {
                    $(this).find('.btn').removeClass('btnActive');
                });
            });

            /*
             * 页面刷新时关闭测绘开关
             * */
            window.onbeforeunload = function () {
                dvStruct.viewer.saveDiyStat('js-default', 1);
                setAllEle(function (element) {
                    dvStruct.fun.checkAndSetActive(element);
                });
            };


            /*
             * 刷新
             * 图像重置
             * */
            $('.js-refresh').click(function (e) {
                dvStruct.fun.reset();
            });

            /*
             *可改变布局
             * 最大4*4
             * */
            $('.js-layoutSelector').click(function (e) {
                dvStruct.dblclickFlag.winNo = 16;//屏蔽双击情况 sj add
                var ofs = $(this).offset();
                var h = $(this).height();
                var w = $(this).width();
                var place = {
                    x: parseInt(ofs.left + w / 2),
                    y: parseInt(ofs.top + h)
                };
                unit.layoutSelector.show(place, 'left');
                btnShowCheck();//检查按钮的显示与否
            });

            /*
             * 子分格
             * 最大2*2
             * */
            $('.js-innerlayoutSelector').click(function () {
                var ofs = $(this).offset();
                var h = $(this).height();
                var w = $(this).width();
                var place = {
                    x: parseInt(ofs.left + w / 2),
                    y: parseInt(ofs.top + h)
                };
                unit.innerLayoutSelector.show(place, 'left');
                //预防万一
                $('.js-stop').click();
            });

            /*
             * 鼠标移动翻页状态开启、关闭
             * */
            $('.js-browseSeries').mousedown(function (e) {
                //关闭img测绘功能
                $('.imgTool').each(function () {
                    $(this).find('.btn').removeClass('btnActive');
                });
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-default', type);
                setAllEle(function (element) {
                    dvStruct.fun.checkAndSetActive(element);
                });
                if ($(this).find('.btn').hasClass('btnActive')) {
                    $(this).find('.btn').removeClass('btnActive');
                    browseSeriesObj.state = false;
                    disablePaging();
                } else {
                    $(this).find('.btn').addClass('btnActive');
                    browseSeriesObj.state = true;
                }
            });

            /*
             * 鼠标移动翻页相关控制参数
             * */
            var browseSeriesObj = {
                state: false,//按钮开关
                start: false,//开始拖动
                H: 0,//当前点击canvas的高度
                imgSliderH: 0,
                imgSliderTop: 0,
                imgSliderBottom: 0
            };

            //鼠标按下开始鼠标拖动翻页
            $('.viewport canvas').on('mousedown', function (e) {
                if ($('.js-browseSeries').find('.btn').hasClass('btnActive')) {
                    browseSeriesObj.state = true;
                }
                if (browseSeriesObj.state) {
                    /*使用库中封装的方法翻页*/
                    var win = dvStruct.whereIsMouse;
                    console.log(win);
                    dvStruct.fun.elementPaging(win);
                    dvStruct.fun.synPagingCheck(win);
                    if (_.isObject(win)) {
                        for (var i = 0; i < win.col * win.row; i++) {
                            var wrapper = win.wrappers[0];
                            var stack = wrapper.stack;
                            var element = wrapper.element;//$(this).parent().get(0);
                            var imageId = stack.imageIds[stack.currentImageIdIndex];
                            cornerstone.enable(element);
                            cornerstoneTools.mouseInput.enable(element);
                            cornerstone.loadImage(imageId).then(function (image) {
                                // display this image
                                cornerstone.displayImage(element, image);
                                // set the stack as tool state
                                cornerstoneTools.addStackStateManager(element, ['stack']);
                                cornerstoneTools.addToolState(element, 'stack', stack);
                                // Enable all tools we want to use with this element
                                cornerstoneTools.stackScroll.activate(element, 1);
                            });
                        }
                    }

                    /*使用库中封装的方法翻页 end*/
                    if (!browseSeriesObj.start) {
                        browseSeriesObj.start = true;
                        var blockH = $(this).parents('.seriesWindow').find('.imgblock').height();
                        var sliderH = $(this).parents('.seriesWindow').find('.imgSlider').height();
                        var sliderTop = $(this).parents('.seriesWindow').find('.imgSlider').css('top');
                        browseSeriesObj.imgSliderH = sliderH;
                        browseSeriesObj.imgSliderBottom = sliderH - blockH;
                    }
                }
            });

            /*
             * 鼠标拖动翻页
             * 同步滚动条位置与标签信息
             * */
            $('.viewport canvas').on('mousemove', function (e) {


                if (browseSeriesObj.state) {
                    if (browseSeriesObj.start) {
                        $(this).parents('.seriesWindow').find('.imgSlider').css("opacity", "1");//显示出滚动条
                        var seriesIndex = parseInt($(this).parents('.seriesWindow').find('.js-info-nowNo').text().slice(4)) - 1;
                        var seriesLength = parseInt($(this).parents('.seriesWindow').find('.js-info-totalNo').text().slice(1));
                        /*同步滚动条位置*/
                        var lastScale = seriesIndex / seriesLength;//文件最后
                        var top = parseInt(browseSeriesObj.imgSliderH * (lastScale));
                        if (top < 0) {
                            top = 0;
                        }
                        if (top > browseSeriesObj.imgSliderBottom) {
                            top = browseSeriesObj.imgSliderBottom;
                        }
                        $(this).parents('.seriesWindow').find('.imgblock').css("top", top);//显示出滚动条
                    }
                }
            });

            /*
             * 停止翻页
             * */
            $('.viewport canvas').on('mouseup', function (e) {
                browseSeriesObj.start = false;
                if (browseSeriesObj.state) {
                    $(this).parents('.seriesWindow').find('.imgSlider').css("opacity", "0");//显示出滚动条
                }
            });

            /*
             * 停止翻页
             * */
            $('.viewport canvas').on('mouseleave', function (e) {
                browseSeriesObj.start = false;
                if (browseSeriesObj.state) {
                    $(this).parents('.seriesWindow').find('.imgSlider').css("opacity", "0");//显示出滚动条
                }
            });

            /*
             * 播放设置
             * 以前的播放设置，暂时放着，可以同时调节所有图像的播放速度，按钮已经删除
             * */
            $('.playSpeedSetBtn').click(function (e) {
                e.preventDefault();
                unit.speedSlider.show();
            });

            /*
             * 播放开始
             * 播放开始的播放停止只显示一个按钮，根据按选定图像框的播放状态自动更快显示内容
             * */
            $('.js-play').click(function () {
                var checkedWin = dvStruct.viewer.getCheckedWin();
                if (checkedWin) {
                    dvStruct.fun.play();
                    $('.seriesWindow.checked').attr('playState', 'play');
                    $('.js-play').hide();
                    $('.js-stop').show();
                    if (checkedWin.imgObjArr.length > 1) {
                        $('.seriesWindow.checked').find('.playcontrol').show();
                    }
                    else {
                        $('.seriesWindow.checked').find('.playcontrol').hide();
                    }
                    $('.seriesWindow.checked').find('.playStart').hide();
                    $('.seriesWindow.checked').find('.playStop').show();
                }

            });

            /*
             * 播放停止
             * 停止所有序列的播放
             * 单个序列的停止为 .playStop
             * */
            $('.js-stop').click(function () {
                dvStruct.fun.stop();
                $('.seriesWindow').attr('playState', 'stop');
                $('.js-play').show();
                $('.js-stop').hide();
                $('.playStart').show();
                $('.playStop').hide();
                $('.playcontrol').hide();
            });

            /*
             * 联动
             * 所有图像一起翻页
             * */
            $('.js-scrollAll').click(function () {
                if ($(this).find('.btn').hasClass('btnActive')) {
                    $(this).find('.btn').removeClass('btnActive');
                } else {
                    $(this).find('.btn').addClass('btnActive');
                }
                dvStruct.viewer.scrollAll = ~dvStruct.viewer.scrollAll;
                if ($(this).hasClass('checked')) {
                    $(this).removeClass('checked')
                } else {
                    $(this).addClass('checked')
                }
            });

            /*
             * 信息文字的显示、隐藏
             * */
            $('.js-infoVisible').click(function () {
                if ($(this).find('.btn').hasClass('btnActive')) {
                    $(this).find('.btn').removeClass('btnActive');
                    $('.js-info').hide();
                } else {
                    $(this).find('.btn').addClass('btnActive');
                    $('.js-info').show();
                }
            });

            /*
             * 定位线的显示、隐藏
             * */
            $('.js-reference').click(function () {
                cornerstoneTools.handleR = 1;
                if ($(this).find('.btn').hasClass('btnActive')) {
                    $(this).find('.btn').removeClass('btnActive')
                } else {
                    $(this).find('.btn').addClass('btnActive')
                }
                if (dvStruct.viewer.btnStates.referenceLines.enable) {
                    dvStruct.viewer.btnStates.referenceLines.enable = false;
                    setAllEle(function (element) {
                        dvStruct.fun.disableReferenceLines(element);
                    })
                } else {
                    dvStruct.viewer.btnStates.referenceLines.enable = true;
                    setAllEle(function (element) {
                        dvStruct.fun.enableReferenceLines(element);
                    })
                }
            });

            /*
             * 左旋
             * */
            $('.js-ccw').click(function () {
                dvStruct.fun.rotate2();
            });

            /*
             * 右旋
             * */
            $('.js-cw').click(function () {
                dvStruct.fun.rotate();
                //不用它自带的了----为了保证不出问题，只做90度旋转
                //$('.btnArea').removeClass('leftBtnActive');
                //$(this).addClass('leftBtnActive');
                //dvStruct.viewer.leftBtnDisable();
                //dvStruct.viewer.btnStates.rotate.enable = true;
                //setAllEle(function(element){
                //    cornerstoneTools.rotate.activate(element, 1);
                //})
            });

            /*
             * 垂直镜像
             * */
            $('.js-vRev').click(function () {
                dvStruct.fun.rev('v');
            });
            /*
             * 水平镜像
             * */
            $('.js-hRev').click(function () {
                dvStruct.fun.rev('h');
            });

            /*
             * 移动
             * */
            $('.js-pan').mousedown(function (e) {
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-pan', type);
                dvStruct.viewer.btnStates.pan.enable = true;
                dvStruct.viewer.btnStates.pan.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.pan.activate(element,type);
                    dvStruct.fun.checkAndSetActive(element);
                });
            });

            /*
             * 缩放
             * */
            $('.js-zoom').mousedown(function (e) {
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-zoom', type);
                dvStruct.viewer.btnStates.zoom.enable = true;
                dvStruct.viewer.btnStates.zoom.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.zoom.activate(element,type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 局部放大镜
             * */
            $('.js-zoomPart').mousedown(function (e) {
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-zoomIn', type);
                dvStruct.viewer.btnStates.magnify.enable = true;
                dvStruct.viewer.btnStates.magnify.type = type;
                /* dvStruct.viewer.btnStates.magnifyTouchDrag.enable = true;
                 dvStruct.viewer.btnStates.magnifyTouchDrag.type = type;*/
                setAllEle(function (element) {
                    //cornerstoneTools.zoom.activate(element,type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 放大镜单击bug修复
             * */
            $('.viewport').on('mouseup', function (e) {
                $('.magnifyTool').hide();
                document.body.style.cursor = 'default';//恢复鼠标
            });

            /*
             * 根据设定值调窗
             * */
            $('.widthInput, .centerInput').bind('keypress', function (event) {
                if (event.keyCode == "13") {
                    var ww = $('.widthInput').val();
                    var wc = $('.centerInput').val();
                    if (!isNaN(ww) && !isNaN(wc)) {
                        dvStruct.fun.wwwc(ww, wc);
                    }
                    // 确定调窗之后使其失去焦点
                    $('.widthInput').blur();
                    $('.centerInput').blur();
                }
            });

            /*
             * 鼠标拖动调窗
             * */
            $('.js-wwwl').mousedown(function (e) {
                var type = mouseDownCheckE(e, this);
                dvStruct.viewer.saveDiyStat('js-wwwl', type);
                dvStruct.viewer.btnStates.wwwc.enable = true;
                dvStruct.viewer.btnStates.wwwc.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.wwwc.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             *  快捷调窗
             *  自定义快捷调窗
             *  增册改
             *  */
            $('.js-quickwwwl').click(function () {
                $('.wwwlBox').css('z-index', 10000);
                // dvStruct.userCode='gly';
                if (dvStruct.userCode != undefined && dvStruct.userCode != null) {
                    if (dvStruct.userCode.length > 0) {
                        //初始快捷调窗信息
                        getModality();
                        if (Modality != "none") {
                            wwwlShow(Modality, dvStruct.userCode);
                            $('.device').val(Modality);
                            typeChange(dvStruct.userCode);
                        }
                        $('.wwwlBox').show();
                    }
                    else {
                        pop_up({title: "用户提示", message: "您现在未登录，使用该功能请先登录！", yesName: "确定", noName: "取消"});
                    }
                }
            });

            /*
             * 反显
             * */
            $('.js-invert').click(function () {
                dvStruct.fun.invert();
                //if($(this).hasClass('checked')){
                //    $(this).removeClass('checked')
                //}else{
                //    $(this).addClass('checked')
                //}
            });

            /*
             * 伪彩
             * */
            $('.js-fakecolor').click(function () {
                dvStruct.fun.fake();
            });

            /*
             * 打开本地dcm文件，
             * 打开文件选择框
             * */
            $('.js-putFileBtn').click(function () {
                $('#putFile').click();
            });

            /*
             *打开本地dcm文件
             * */
            $('#putFile').change(function (e) {
                var files = e.target.files;
                if (files.length !== 0) {
                    io.File.load(files);
                }
            });

            /*
             * 下载选择框
             * */
            $('.js-downloadset').click(function (e) {
                unit.mask.show();
                $('#downloadBox').show();
            });

            /*
             * 关闭下载框
             * */
            $('#downloadBox').find('.closeBtn').on('mousedown', function (e) {
                unit.mask.hide();
                $('#downloadBox').hide();
            });

            /*
             * 下载dcm原文件
             * */
            $('#dcmDownload').on('mousedown', function (e) {
                dvStruct.saveDownloaded();
                $('#dcmDownload').css('color', '#blue');
            });

            /*
             * 下载jpg
             * 固定大小512*512
             * */
            $('#jpgDownload').on('mousedown', function (e) {
                var obj = {
                    size: 512,
                    type: 'jpg'
                };
                cornerstoneTools.saveAllAs('dcm2jpg', obj);
                $('#jpgDownload').css('color', '#blue');
            });

            /*
             * 下载dcmViewer
             * */
            $('#dcmViewerDownload').on('mousedown', function (e) {
                $('#dcmViewerDownload').css('color', '#blue');
                //跳转到DCM浏览器下载的目录
                var triggerDownload = $("<a>").attr("href", "ipacsdv/dcmViewer/dcmViewer.rar").attr("download", "dcmViewer.rar").appendTo("body");
                triggerDownload[0].click();
                triggerDownload.remove();
            });

            /*
             * 胶片打印
             * */
            $('.js-dcmPrint').click(function () {
                initinfoScreenArr(dvStruct.userCode);//初始化页面显示四角信息
                var serviceType = "FILMPRINT";//调用服务类型
                // dvStruct.hospitalCode='gly';
                dvStruct.localIP;
                if (dvStruct.hospitalCode != undefined && dvStruct.hospitalCode != null) {
                    if (dvStruct.hospitalCode.length > 0) {
                        var socketState = 0;
                        if ("WebSocket" in window) {
                            try {
                                // socket = new WebSocket('ws://localhost:8181');
                                if (dvStruct.localIP != undefined && dvStruct.localIP != null) {
                                    socket = new WebSocket(dvStruct.localIP);
                                }
                                else {
                                    //socket = new WebSocket('ws://localhost:8181');
                                    socket = new WebSocket('ws://localhost:8181');
                                    console.log(socket);
                                }
                                socket.onopen = function () {
                                    if (socket.readyState == 1) {
                                        printStruct.openFlag = true;
                                        //生成打印页面
                                        getWWWL();//获取快捷调窗信息
                                        $('#printMain').show();
                                        initSelec();//对胶片大小和打印机设置初始化

                                        var initpaperSize = $('#paperSize').val();
                                        var initpaperDirct = $('.paperDirection').val();
                                        // getprinPapertSize('14INX17IN', '1');//初始化页面
                                        getprintPaperSize(initpaperSize, initpaperDirct);//初始化打印纸张打印方向
                                        initImgBoxL();//打印页面左侧布局初始化（）先初始化，再显示打印页面，图像多时，造成打开慢的问题
                                        initPage();//打印页面初始化布局
                                        initPatientInfo();//打印页面病人信息显示初始化
                                        orderPageId();//整理id
                                        //initImgBoxL();//打印页面左侧布局初始化(先显示打印页面，再初始化)
                                        initShowTag(dvStruct.userCode);//四角信息设置弹出框初始化
                                    }
                                };
                                socket.onmessage = function (evt) {
                                };
                                socket.onclose = function () {
                                };
                                socket.error = function () {
                                };
                            }
                            catch (e) {
                                // alert("服务连接失败,请检查服务是否正确安装，或打开。如未按照服务请点击下载安装。再进入胶片打印页面");
                                socketState = 3;
                                console.log(e);
                            }
                        }
                        else {
                            //浏览器不支持
                            socketState = -1;
                        }
                        if (socket) {
                            socketState = 2;
                        }
                        setTimeout(function () {
                            if (socket.readyState != 1) {
                                console.log(socket);
                                socketConnectionTips(socketState);
                            }
                        }, 3000);
                    }
                    else {
                        pop_up({title: "用户提示", message: "您现在未登录，使用该功能请先登录！", yesName: "确定", noName: "取消"});
                    }
                }
            });

            $('.js-dcmJoin').click(function () {
                joinStruct.openWay = true;
                $("#printMain").find('.txt').hide();
                $('.joinMainBox').show();
                $('.joinDiv').show();
                $('.joinHelpBox').show();
                $('.js-dcmPrint').click();
                setTimeout(function () {
                    $('.joinDiv').show();
                }, 1000);
                setTimeout(function () {
                    $('.joinDiv').show();//确保可以刷新出来
                }, 3000);
                $('.joinTitleBox').show();
                $('.joinCutToolBox').show();
                hideTool("joinPageS", 2);

            });

            /*
             * 关闭胶片打印页面
             * */
            $('#closePrintMain').click(function () {
                printStruct.openFlag = false;
                emptyImgData();//每次退出后清空之前的打印数据
            });

            //图像拼接


            // $("#imgjoin").click(function () {
            //     $('.joinMainBox').show();
            //     $('.joinDiv').show();
            // });
            // $('.joinBtn').click(function () {
            //     $('.joinMainBox').hide();
            //     $('.joinDiv').hide();
            //     $(".joinBox").empty();
            // });

            // $( ".joinBox.joinImg " ).draggable({ stack: ".joinBox.joinImg" });
            /*
             * 打开VR端口号配置设置弹出框
             * 以后可扩展为公用设置及配置
             * */
            $('.js-sets').click(function () {
                unit.mask.show();
                $("#commonSet").show();
            });

            /*
             * 关闭VR端口号配置设置弹出框
             * */
            $('#commonSet').find('.closeBtn').on('mousedown', function (e) {
                unit.mask.hide();
                $('#commonSet').hide();
            });

            /*
             * 保存
             * 如果需要保存到cookie或者后台时的确定按钮
             * */
            $('#commonSet').find('#portSetOK').on('click', function (e) {
                var msgCom = $("#msgPort").val();
                var dataCom = $("#dataPort").val();
                //首次还是要在配置文件里面设置
                //设置端口号要不同
                //要检查该端口号是否被占用
               console.log(msgCom, dataCom);
                /* unit.mask.hide();
                 $('#commonSet').hide(); */
            });

            //顶部工具栏按钮响应end

            //垂直工具栏的按钮响应begin------------corner这货的实现有问题，测量只能左键

            /*
             * 点探针
             * */
            $('.js-probe').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-probe', type);
                dvStruct.viewer.btnStates.probe.enable = true;
                dvStruct.viewer.btnStates.probe.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.probe.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 点探针
             * 点测量
             * */
            $('.js-probeUnSave').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-probeUnSave', type);
                dvStruct.viewer.btnStates.probeUnSave.enable = true;
                dvStruct.viewer.btnStates.probeUnSave.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.probe.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });
            /*
             * 测量画线
             * 长度测量
             * */
            $('.js-length').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-length', type);
                dvStruct.viewer.btnStates.length.enable = true;
                dvStruct.viewer.btnStates.length.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.length.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 心胸比
             * */
            $('.js-heartScale').click(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-heartScale', type);
                dvStruct.viewer.btnStates.heartScale.enable = true;
                dvStruct.viewer.btnStates.heartScale.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.length.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                });
            });

            /*
             * 两条线 双线
             * 按钮已经删除
             * */
            $('.js-twolines').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-twolines', type);
                dvStruct.viewer.btnStates.twolines.enable = true;
                dvStruct.viewer.btnStates.twolines.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.length.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 角度测量
             * 始终一个点重合
             * simpleAngle
             * */
            $('.js-angle').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-simpleAngle', type);
                dvStruct.viewer.btnStates.simpleAngle.enable = true;
                dvStruct.viewer.btnStates.simpleAngle.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.angle.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             *测量角度
             *两条线可分离无重合点
             * angle
             * 按钮已删除
             * */
            /*  $('.js-angle').mousedown(function (e) {
             var type = mouseDownCheckE(e, this, 1);
             if (type == -1)return;

             dvStruct.viewer.saveDiyStat('js-angle', type);
             dvStruct.viewer.btnStates.angle.enable = true;
             dvStruct.viewer.btnStates.angle.type = type;
             setAllEle(function (element) {
             //cornerstoneTools.angle.activate(element, type);
             dvStruct.fun.checkAndSetActive(element);
             })
             });*/

            /*
             * 测量椭圆
             * 统计该区域的均值 方差 面积
             * */
            $('.js-ellipse').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-ellipse', type);
                dvStruct.viewer.btnStates.ellipticalRoi.enable = true;
                dvStruct.viewer.btnStates.ellipticalRoi.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.ellipticalRoi.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                })
            });

            /*
             * 测量矩形
             * 统计该区域的均值 方差 面积
             * */
            $('.js-rect').mousedown(function (e) {
                var type = mouseDownCheckE(e, this, 1);
                if (type == -1)return;
                dvStruct.viewer.saveDiyStat('js-rect', type);
                dvStruct.viewer.btnStates.rectangleRoi.enable = true;
                dvStruct.viewer.btnStates.rectangleRoi.type = type;
                setAllEle(function (element) {
                    //cornerstoneTools.rectangleRoi.activate(element, type);
                    dvStruct.fun.checkAndSetActive(element);
                });
            });

            /*
             * 清空测量，但不关闭测量功能
             * */
            $('.js-clearToolState').click(function () {
                dvStruct.fun.clearToolState();
            });

            /*
             * 隐藏右边图像缩略图区域
             * */
            $('.js-hideLeft').click(function () {
                var state = $('.js-hideLeft').attr('state');
                console.log(state);
                if (state == "hide") {
                    $(this).find('.icon').addClass('rotate');
                    $(this).find('.icon').removeClass('rotate1');
                    $('.js-hideLeft').attr('state', 'show');
                    $('.leftGallery').css('left', -$('.leftGallery').width());
                    // $('.logo').css('left',0);
                    $('.toolV').css('left', 0);
                    $('.dvContainer').css('padding-left', 0);
                    leftResize($('.js-topPannel').width() - $('.toolV').width());
                }
                else {
                    $(this).find('.icon').addClass('rotate1');
                    $(this).find('.icon').removeClass('rotate');
                    $('.js-hideLeft').attr('state', 'hide');
                    $('.leftGallery').css('left', 0);
                    // $('.logo').css('left',0);
                    $('.toolV').css('left', $('.leftGallery').width());
                    $('.dvContainer').css('padding-left', $('.leftGallery').width());
                    leftResize($('.js-topPannel').width() - $('.logo').width());
                }

            });
            //垂直工具栏的按钮响应end


            //图像框按钮响应begin

            /*
             * 同步
             * 同一检查的图像切层同步
             * */
            $('.js-syn').click(function () {

                   if ($(this).find('.btn').hasClass('btnActive')) {
                 $(this).find('.btn').removeClass('btnActive');

                 } else {
                 $(this).find('.btn').addClass('btnActive');

                 }

                dvStruct.synposition.enable = !dvStruct.synposition.enable;
                if (dvStruct.synposition.enable) {
                    $(this).addClass('checked');
                    //判断同步
                    var checkedWin = dvStruct.viewer.getCheckedWin();
                    if (checkedWin) {
                        checkAndSynByWinId(checkedWin.winId);
                    }
                } else {
                    $(this).removeClass('checked');
                }
            });


            dvStruct.seriesForMpr = [];//用于mpr的数据容器
            /*
             * 打开mpr窗口
             * 有的浏览器版本不兼容css的隐藏属性，在html页面  $(document).ready 后加$("#papaFrame").hide();强行隐藏
             * */
            $('.js-mpr').click(function () {
                var seriesIndex =parseInt( $(this).parents('.seriesWindow').attr('seriesIndex'));
                var seriesLength = $(this).parents('.seriesWindow').attr('seriesLength');
                $('.seriesWindow').removeClass('checked');
                $(this).parents('.seriesWindow').addClass('checked');
                dvStruct.seriesForMpr = [];
                var checkedWin = dvStruct.viewer.getCheckedWin();
                if (checkedWin) {
                    if (checkedWin.wrappers[0].suid) {
                        dvStruct.mprOpenFlag = true;
                        var _suid = checkedWin.wrappers[0].suid;
                        console.log(_suid);
                        dvStruct.seriesForMpr = _.filter(dvStruct.downloadedDcmFiles, function (o) {
                            return _suid == o.infoAfterAnalysised.suid;
                        });
                        var ww = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('ww');
                        var wc = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('wc');
                        var intercept = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('intercept');
                        var slope = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('slope');
                        var studyDate = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('studyDate');
                        var studyTime = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('studyTime');
                        var sex = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('sex');
                        var patientName = $(this).parents('.seriesWindow').find('.viewportWrapper').attr('patientName');

                        // 参数传递
                        dvStruct.mprDataInfo.wc = parseInt(wc);
                        dvStruct.mprDataInfo.ww = parseInt(ww);
                        dvStruct.mprDataInfo.intercept = parseFloat(intercept);
                        dvStruct.mprDataInfo.patientName = parseFloat(slope);
                        dvStruct.mprDataInfo.studyDate = studyDate;
                        dvStruct.mprDataInfo.studyTime = studyTime;
                        dvStruct.mprDataInfo.sex = sex;
                        dvStruct.mprDataInfo.patientName = patientName;
                        console.log(dvStruct.mprDataInfo);
                        $('#papaFrame').css('visibility', 'visible');
                        $('#papaFrame').show();

                        dvStruct.mprOpen = true;
                        if ($('#mprFrame').attr('src') == '') {
                            $('#mprFrame').attr('src', 'papa_gai/html/main.html');
                        }
                        var f = mprFrame;
                        if (f.window.checkAndLoad) {
                            f.window.checkAndLoad();
                        }
                        return;
                    }
                }
                alert('请选中图像窗');
            });


            /*
             * 肺结节AI诊断
             * */
            $('.js-lungAI').click(function () {
                var paraObj={
                    username:"uploaderuser",
                    password:"uploaderuser",
                    vendorCode:"linkdemo",
                    userCode:"linkdev",
                    bucket:"lk-demo",
                    hosId:"pacs02",
                    cloudSync:1,
                    extension:"dcm",
                    aiEngine:"lungai02",
                    requestId:"",
                    serverUrl:"https://pacs.link-imaging.com:7194",
                    ViewerUrl:"http://ai.link-imaging.com",
                    targetApp:"lungai",
                    dicomPathList:[]
                };
                var seriesIndex =parseInt( $(this).parents('.seriesWindow').attr('seriesIndex'));
                $.each(dvStruct.outputSeriesArr[seriesIndex].dicoms,function (k,val) {
                    paraObj.dicomPathList.push(val.theUrl);
                });
                $('.seriesWindow').removeClass('checked');
                $(this).parents('.seriesWindow').addClass('checked');
                uploadLungAI(paraObj);
            });

            /*
             * 关闭mpr页面
             * */
            $('.js-mprClose').click(function () {
                $('#papaFrame').css('visibility', 'hidden');
                $('#papaFrame').hide();
                dvStruct.mprOpen = false;
                dvStruct.seriesForMpr = [];
                var f = mprFrame;
                if (f.window.clearAll) {
                    f.window.clearAll();
                }
            });
            //$('.js-mprHide').click(function(){
            //    $('#papaFrame').css('visibility','hidden');
            //    dvStruct.mprOpen = false;
            //});

            /*
             * 调用3D重建应用程序
             * 调用后统一隐藏该按钮，数据传输完毕后统一显示
             * */
            $('.js-VR').click(function () {
                sendState();//隐藏按钮
                var seriesIndex = $(this).parents('.seriesWindow').attr('seriesIndex');
                var seriesLength = $(this).parents('.seriesWindow').attr('seriesLength');
                dvStruct.localIP;
                if (dvStruct.hospitalCode != undefined && dvStruct.hospitalCode != null) {
                    if (dvStruct.hospitalCode.length > 0) {
                        var socketState = 0;
                        if ("WebSocket" in window) {
                            try {
                                var msgCom = $("#msgPort").val();
                                socketMsg = new WebSocket('ws://localhost:' + msgCom);
                                socketMsg.onopen = function () {
                                    //    发送启动Viewer的命令
                                    setTimeout(function () {
                                        var serviceType = "VR";
                                        var strTemp = "serviceType:" + serviceType;
                                        socketMsg.send(strTemp);// 启动Viewer的命令
                                    }, 300);
                                };
                                socketMsg.onmessage = function (evt) {
                                    var message = evt.data;
                                    console.log("message:", message);
                                    if (message == "0")//Viewer启动失败
                                    {
                                        pop_up({
                                            title: "VR提示", message: "三维处理应用程序打开失败，请联系工程人员！（5秒后自动关闭该窗口）",
                                            yesName: "确定",
                                            noName: "取消"
                                        });
                                        alreadyState();//VR功能就绪状态
                                        tipsClose(5);
                                    }
                                    if (message == "1")//Viewer启动成功
                                    {
                                        //计算参数
                                        var port = $("#dataPort").val();
                                        var dataLength = Math.ceil(seriesLength / dataSize_VR);
                                        process3D.series = dvStruct.seriesArr[seriesIndex].dicomArr.slice(0, dvStruct.seriesArr[seriesIndex].dicomArr.length);
                                        process3D.paraVR.seriesLength = seriesLength;
                                        process3D.paraVR.dataLength = dataLength;
                                        //发送数据
                                        setTimeout(function () {
                                            callServiceVR.socketConnect(port, seriesIndex, seriesLength, dataLength);
                                        }, 300);

                                        return;
                                    }
                                    if (message == "2")//超声点击返回
                                    {
                                    }
                                    enableStateVR = true;
                                };
                                socketMsg.onclose = function () {
                                };
                                socketMsg.error = function () {
                                    sendState();//隐藏按钮
                                    $('.wmf-confirm').empty();
                                    $('.wmf-confirm').hide();
                                    $('.overlay_pop').hide();
                                    pop_up({
                                        title: "VR提示",
                                        message: "数据解析出错，请联系工程人员！（10秒后自动关闭该窗口）",
                                        ok: alreadyState(),
                                        yesName: "确定",
                                        noName: "取消"
                                    });
                                    tipsClose(10);
                                };
                            }
                            catch (e) {
                                socketState = 3;
                                console.log(e);
                            }
                        }
                        else {
                            //浏览器不支持
                            socketState = -1;
                        }
                        if (socketMsg) {
                            socketState = 2;
                        }
                        setTimeout(function () {
                            //服务启动状态检查
                            if (socketMsg.readyState == 1) {
                                //判断是否支持jszip
                                if (!JSZip.support.blob) {
                                    pop_up({title: "VR提示", message: "浏览器不支持数据解析", yesName: "确定", noName: "取消"});
                                    alreadyState();//VR功能就绪状态
                                    return false;
                                }
                            }
                            else {
                                socketConnectionTipsVR(socketState);
                                alreadyState();//VR功能就绪状态
                            }
                        }, 3000);
                    }
                    else {
                        pop_up({title: "用户提示", message: "您现在未登录，使用该功能请先登录！", yesName: "确定", noName: "取消"});
                        return false;
                    }
                }

            });
            //图像框按钮响应end

            //快捷调空设置弹出框相关事件 begin
            //窗位窗宽确定按钮
            $('#addWwwlBtn').bind('click', function () {
                var id = '';
                var code = dvStruct.userCode;
                addwwwlInfo('AddWSet', id, code)
            });
            $('#modifyWwwlBtn').bind('click', function () {
                var id = $('.activeLi').attr('data-id');
                var code = dvStruct.userCode;
                addwwwlInfo('UpdWSet', id, code);
            });
            //添加窗位窗宽设置弹出框
            $('#addwwwl').bind('click', function () {
                show($('.wwwlSetBox'));
                $('#modifyWwwlBtn').hide();
                $('#addWwwlBtn').show();
            });
            //删除窗位窗宽
            $('#deletewwwl').bind('click', function () {
                var id = $('.activeLi').attr('data-id');
                var code = dvStruct.userCode;
                deletewwwlInfo(id, code);
            });
            //修改窗位窗宽
            $('#modifywwwl').bind('click', function () {
                var name = $('.activeLi td').eq(0).text();
                $('.modifyName').val(name);
                var wl = $('.activeLi td').eq(1).text();
                $('.wlInput').val(wl);
                var ww = $('.activeLi td').eq(2).text();
                $('.wwInput').val(ww);
                var modify = $('.device').val();
                $('.device1').val(modify);
                show($('.wwwlSetBox'));
                $('#modifyWwwlBtn').show();
                $('#addWwwlBtn').hide();
            });

            //窗位 值加减
            $('.wlBtnAdd').bind('click', function () {
                var add = $('.wlInput').val();
                add++;
                $('.wlInput').val(add);
            });
            $('.wlBtnReduce').bind('click', function () {
                var add = $('.wlInput').val();
                if (add != 1) {
                    add--;
                }
                $('.wlInput').val(add);
            });
            //窗宽 值加减
            $('.wwBtnAdd').bind('click', function () {
                var add = $('.wwInput').val();
                add++;
                $('.wwInput').val(add);
            });
            $('.wwBtnReduce').bind('click', function () {
                var add = $('.wwInput').val();
                if (add != 1) {
                    add--;
                }
                $('.wwInput').val(add);
            });
            //快捷调空设置弹出框相关事件 end
        }
    });
})(jQuery);


/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的图像填充相关方法
 */

/*
 * 向指定targetID元素中填入指定imageId图像
 * 同时增加属性  imageId seNo
 * 同步之前的图像操作
 * */
function fillImageSyn(targetID, imageId, seNo, viewport) {
    var element = $("#" + targetID).get(0);
    //增加两个属性
    $("#" + targetID).attr('imageId', imageId);
    $("#" + targetID).attr('seNo', seNo);
    $("#" + targetID).attr('imgIn', "true");
    cornerstone.disable(element);//清除上一次使用时留下的信息
    cornerstone.enable(element);
    cornerstoneTools.mouseInput.enable(element);
    cornerstone.loadImage(imageId).then(function (image) {
        cornerstone.displayImage(element, image);
        if (imageId.indexOf("loadJoinImg")<0) {
            cornerstoneTools.orientationMarkers.enable(element);//方位标签
        }
    });
    if (viewport == "dragin" || viewport == "merge") {
    }
    else {
        cornerstone.setViewport(element, viewport);
    }
}

/*
 * 向指定targetID元素中填入指定imageId图像
 * 同时增加属性  imageId seNo
 * */
function fillImage(targetID, imageId, seNo) {
    var element = $("#" + targetID).get(0);
    //增加两个属性
    $("#" + targetID).attr('imageId', imageId);
    $("#" + targetID).attr('seNo', seNo);
    $("#" + targetID).attr('imgIn', 'true');//标志有图像装入
    cornerstone.disable(element);//清除上一次使用时留下的信息
    cornerstone.enable(element);
    cornerstoneTools.mouseInput.enable(element);
    cornerstone.loadImage(imageId).then(function (image) {

        cornerstone.displayImage(element, image);

        if (imageId.indexOf("loadJoinImg")<0) {
            cornerstoneTools.orientationMarkers.enable(element);//方位标签
        }

    });
}

/*
 * 绘制图像并同步实时操作
 * */
function fillImageKeep(sourceID, targetID, imageId, seNo) {

    var element = $("#" + targetID).get(0);
    //增加两个属性
    $("#" + targetID).attr('imageId', imageId);
    $("#" + targetID).attr('seNo', seNo);
    cornerstone.disable(element);//清除上一次使用时留下的信息
    cornerstone.enable(element);
    cornerstoneTools.mouseInput.enable(element);
    cornerstone.loadImage(imageId).then(function (image) {
        cornerstone.displayImage(element, image);
        if (imageId.indexOf("loadJoinImg")<0) {
            cornerstoneTools.orientationMarkers.enable(element);//方位标签
        }


    });
    var element2 = $("#" + sourceID).get(0);
    var viewport = deepCopy1(cornerstone.getViewport(element2));
    cornerstone.setViewport(element, viewport);
}



/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的打印数据处理
 * 信息填充分为前端绘制和后台绘制
 * 现在全部统一用的前端绘制
 */


/*
 * 打印当前页
 * 在前端绘制信息的方式
 * */
function getCurFilmDataWeb() {
    var baseFontsize = $('#tagFontsize').val();//用户设置字号
    console.log("前端绘制图像信息。胶片打印当前页");
    var serviceType = "FILMPRINT";//预留服务类型参数

//只处理需要打印的页
    var curPageId = "page" + printStruct.printpage.pageIndex;
    $('.printPage').each(function (k, val) {
        var portSetObj = getPrintSet();//获取打印机设置参数
        if ($(this).attr('id') === "page0") {
        }
        else if ($(this).attr('id') === curPageId) {
            console.log("打印第几页：" + $(this).attr('id'));
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            // console.log("pageTop--pageLeft:"+pageTop+"---"+pageLeft);
            //胶片设置参数对象
            var filmData = {
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {},
                imgData: []
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');

            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;//以两倍大小进行绘制
            filmPageOut.height = filmData.paperSize.height * 2;

            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);
            console.time('time90');
            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }
                    var infoData = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取标识字符串  //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();
                    // console.log("imgTop--imgLeft:"+imgTop+"---"+imgLeft);

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    // xend=xstrat+scaleWidth*filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    // yend=ystart+scaleHeight*filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;
                    var actulH = scaleHeight * filmPageOut.height;

                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制

                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);//?

                    $('#equalRationDraw').children(0).attr('id', 'xxx');
                    var canvId = 'xxx';
                    // var fontSize = calcFontsize(actulW, actulH);

                    var fontSize = calcFontsizeAsSet(actulW, actulH, baseFontsize);

                    drawInfoOnFilm(infoData, canvId, fontSize);//在canvas中绘制图像信息
                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();
                    // console.log(xstrat+'---'+ystart+'---'+actulW+'---'+actulH);
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }
            });
            console.timeEnd('time90');
            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");
            var printdrct;
            if (filmData.paperDirect == "1")
                printdrct = "PORTRAIT";
            else
                printdrct = "LANDSCAPE";
            var data = convertImgDataToBlob(image.src);
            sendDataPrint(socket, data, filmData.row, filmData.col, printdrct, filmData.paperType, portSetObj.copys, portSetObj.IP, portSetObj.port, portSetObj.AET, portSetObj.AETLocal, portSetObj.filmObj, portSetObj.filmType, portSetObj.quality, portSetObj.grayEnable, portSetObj.magnifyType);
            $('#canvas4PrintOut').hide();

            //本地测试 保存胶片为jpg
            /* var page2jpgURL = filmPageOut.toDataURL("image/jpeg");
             var triggerDownload = $("<a>").attr("href", page2jpgURL).attr("download", "printPage.jpg").appendTo("body");
             triggerDownload[0].click();
             triggerDownload.remove();*/


            if (socket.readyState == 1) {
                pop_up({
                    title: "打印提示",
                    message: "打印文件传输完毕！(点击确定退出打印页面)",
                    ok: closePrintMain,
                    yesName: "确定",
                    noName: "取消"
                });
            }
            return;
        }
    });
}
/*
 * 打印所有页，生成一页打印一页
 * * 在前端绘制信息的方式
 * */
function getAllFilmDataWeb() {
    console.log("前端绘制图像信息。胶片打印所有页");
    var baseFontsize = $('#tagFontsize').val();//用户设置字号

    //遍历需要打印的页
    $('.printPage').each(function (k, val) {
        var portSetObj = getPrintSet();//获取打印机设置参数

        if ($(this).attr('id') === "page0") {

        }
        else {
            clearSelecImgBoxCss();
            clearSelecImgViewportCss();
            showPageId($(this).attr('id'));

            // console.log("打印第几页："+$(this).attr('id'));
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            // console.log("pageTop--pageLeft:"+pageTop+"---"+pageLeft);

            var filmData = {
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {},
                imgData: []
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');

            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;
            filmPageOut.height = filmData.paperSize.height * 2;

            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);


            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    // var seNo = getseNo(imageId);//根据imageid找seno
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }

                    // var imageInfoObj = getImgInfoAsSet(imageId, wwwlObj.ww, wwwlObj.wl);   //获取标识字符串  //按照四角信息设置来输出信息

                    var infoData = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取标识字符串  //按照四角信息设置来输出信息


                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();


                    // console.log("imgTop--imgLeft:"+imgTop+"---"+imgLeft);

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    xend = xstrat + scaleWidth * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    yend = ystart + scaleHeight * filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;
                    var actulH = scaleHeight * filmPageOut.height;

                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制

                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);//?
                    $('#equalRationDraw').children(0).attr('id', 'xxx');

                    var canvId = 'xxx';
                    // var fontSize = calcFontsize(actulW, actulH);

                    var fontSize = calcFontsizeAsSet(actulW, actulH, baseFontsize);

                    drawInfoOnFilm(infoData, canvId, fontSize);//在canvas中绘制图像信息


                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();

                    // console.log(xstrat+'---'+ystart+'---'+actulW+'---'+actulH);
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }

            });


            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");


            var printdrct;
            if (filmData.paperDirect == "1")
                printdrct = "PORTRAIT";
            else
                printdrct = "LANDSCAPE";
            var data = convertImgDataToBlob(image.src);
            sendDataPrint(socket, data, filmData.row, filmData.col, printdrct, filmData.paperType, portSetObj.copys, portSetObj.IP, portSetObj.port, portSetObj.AET, portSetObj.AETLocal, portSetObj.filmObj, portSetObj.filmType, portSetObj.quality, portSetObj.grayEnable, portSetObj.magnifyType);


            $('#canvas4PrintOut').hide();


            //本地测试 保存胶片为jpg
            /* var page2jpgURL = filmPageOut.toDataURL("image/jpeg");
             var triggerDownload = $("<a>").attr("href", page2jpgURL).attr("download", "printPage.jpg").appendTo("body");
             triggerDownload[0].click();
             triggerDownload.remove();*/


        }

        if (k == $('.printPage').length - 1) {
            if (socket.readyState == 1) {
                pop_up({
                    title: "打印提示",
                    message: "打印文件传输完毕！(点击确定退出打印页面)",
                    ok: closePrintMain,
                    yesName: "确定",
                    noName: "取消"
                });
            }
        }
    });
    showPrintPage(printStruct.printpage.pageIndex);//回到操作的那一页

}


/*
 *  打印当前页
 *  在后台绘制信息的方式
 * */
function getCurFilmDataBackground() {
    console.log("后台绘制图像信息。胶片打印当前页");
    var serviceType = "FILMPRINT";//预留服务类型参数

    var curPageId = "page" + printStruct.printpage.pageIndex;
    //返回给后台的数据对象，用于绘制图像信息
    var film = {
        img: "",
        data: []
    };

    $('.printPage').each(function (k, val) {
        var portSetObj = getPrintSet();//获取打印机设置参数

        if ($(this).attr('id') === "page0") {

        }
        else if ($(this).attr('id') === curPageId) {

            console.log("打印第几页：" + $(this).attr('id'));
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            // console.log("pageTop--pageLeft:"+pageTop+"---"+pageLeft);


            var filmData = {  //胶片参数
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {}
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');

            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;
            filmPageOut.height = filmData.paperSize.height * 2;

            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);

            console.time('time90');
            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像

                if ($(this).attr('imgIn') == "true") {

                    //每张小图的相应信息
                    var data = {
                        position: {//位置信息
                            xstart: 0,
                            ystart: 0,
                            xend: 1,
                            yend: 1,
                            W: 1,
                            H: 1
                        },
                        info: {//图像信息
                            lb: [],
                            lt: [],
                            rb: [],
                            rt: []
                        }
                    };


                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    //var seNo = getseNo(imageId);//根据imageid找seno
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }

                    data.info = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取图像信息 //按照四角信息设置来输出信息


                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();
                    // console.log("imgTop--imgLeft:"+imgTop+"---"+imgLeft);

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    // xend=xstrat+scaleWidth*filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    // yend=ystart+scaleHeight*filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;
                    var actulH = scaleHeight * filmPageOut.height;

                    data.position.xstart = xstrat;
                    data.position.ystart = ystart;
                    data.position.xend = xend;
                    data.position.yend = yend;
                    data.position.xend = xstrat + actulW;
                    data.position.yend = ystart + actulH;
                    data.position.W = actulW;
                    data.position.H = actulH;

                    film.data.push(data);//将单张图像的信息push到返回后台的数据对象中

                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制

                    var element = $("#equalRationDraw").get(0);

                    enableAllMeasureTools(element, elementId);//同步图像的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');

                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();

                    // console.log(xstrat+'---'+ystart+'---'+actulW+'---'+actulH);

                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }

            });

            console.timeEnd('time90');

            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");

            film.img = image.src.substring(23, image.src.length);

            var str = JSON.stringify(film); 
            // console.log(str);
            console.time('time91');
            $.ajax({
                type: 'post',
                data: {
                    data: str
                },
                url: 'http://' + urlInit + '/GetDicomPrinterPic',
                success: function (data) {
                    console.log("后台成功返回数据");
                    var imageOut = new Image();
                    imageOut.src = "data:image/jpeg;base64," + data;
                    var dataout = convertImgDataToBlob(imageOut.src);//转换数据格式
                    var printdrct;
                    if (filmData.paperDirect == "1")
                        printdrct = "PORTRAIT";
                    else
                        printdrct = "LANDSCAPE";
                    sendDataPrint(socket, dataout, filmData.row, filmData.col, printdrct, filmData.paperType, portSetObj.copys, portSetObj.IP, portSetObj.port, portSetObj.AET, portSetObj.filmObj, portSetObj.filmType, portSetObj.quality, portSetObj.grayEnable, portSetObj.magnifyType);

                    if (socket.readyState == 1) {
                        pop_up({
                            title: "打印提示",
                            message: "打印文件传输完毕！(点击确定退出打印页面)",
                            ok: closePrintMain,
                            yesName: "确定",
                            noName: "取消"
                        });
                    }

                },
                error: function () {
                    pop_up({title: "提示", message: "后台返回数据失败", yesName: "确定", noName: "取消"});
                }
            });

            console.timeEnd('time91');


            $('#canvas4PrintOut').hide();

            //以下代码为下载此图片功能  用于查看输出打印的图像的jpg格式 本地测试 保存胶片为jpg
            /*        var page2jpgURL = filmPageOut.toDataURL("image/jpeg");
             var triggerDownload = $("<a>").attr("href", page2jpgURL).attr("download", "printPage.jpg").appendTo("body");
             triggerDownload[0].click();
             triggerDownload.remove();*/


            return;


        }
    });

}
/*
 *生成一页打印一页 在后台绘制信息的方式
 * 打印所有页，
 * */
function getAllFilmDataBackground() {
    console.log("后台绘制图像信息。胶片打印所有页");

    //遍历需要打印的页
    $('.printPage').each(function (k, val) {
        var portSetObj = getPrintSet();//获取打印机设置参数

        if ($(this).attr('id') === "page0") {

        }
        else {
            //返回给后台的数据对象，用于绘制图像信息
            var film = {
                img: "",
                data: []
            };

            clearSelecImgBoxCss();
            clearSelecImgViewportCss();
            showPageId($(this).attr('id'));


            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            // console.log("pageTop--pageLeft:"+pageTop+"---"+pageLeft);

            var filmData = {//胶片参数
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {},
                imgData: []
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');

            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width;
            filmPageOut.height = filmData.paperSize.height;

            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);


            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {

                    //返回给后台的每张小图的相应信息
                    var data = {
                        position: {
                            xstart: 0,
                            ystart: 0,
                            xend: 1,
                            yend: 1,
                            W: 1,
                            H: 1
                        },
                        info: {
                            lb: [],
                            lt: [],
                            rb: [],
                            rt: []
                        }
                    };

                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    //var seNo = getseNo(imageId);//根据imageid找seno
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }


                    data.info = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);  //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();


                    // console.log("imgTop--imgLeft:"+imgTop+"---"+imgLeft);

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    xend = xstrat + scaleWidth * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    yend = ystart + scaleHeight * filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;
                    var actulH = scaleHeight * filmPageOut.height;

                    data.position.xstart = xstrat;
                    data.position.ystart = ystart;
                    data.position.xend = xend;
                    data.position.yend = yend;
                    data.position.xend = xstrat + actulW;
                    data.position.yend = ystart + actulH;
                    data.position.W = actulW;
                    data.position.H = actulH;

                    film.data.push(data);//将每张图像的信息push到返回后台的数据对象中


                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制

                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);// 同步图像的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');


                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();

                    // console.log(xstrat+'---'+ystart+'---'+actulW+'---'+actulH);
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }

            });


            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");//整张胶片的img
            film.img = image.src.substring(23, image.src.length);//返回给后台的图像数据

            var str = JSON.stringify(film);
            // console.log(str);
            console.time('time91');
            $.ajax({
                type: 'post',
                data: {
                    data: str
                },
                url: 'http://' + urlInit + '/GetDicomPrinterPic',
                success: function (data) {

                    var imageOut = new Image();
                    imageOut.src = "data:image/jpeg;base64," + data;
                    var dataout = convertImgDataToBlob(imageOut.src);
                    var printdrct;
                    if (filmData.paperDirect == "1")
                        printdrct = "PORTRAIT";
                    else
                        printdrct = "LANDSCAPE";

                    sendDataPrint(socket, dataout, filmData.row, filmData.col, printdrct, filmData.paperType, portSetObj.copys, portSetObj.IP, portSetObj.port, portSetObj.AET, portSetObj.filmObj, portSetObj.filmType, portSetObj.quality, portSetObj.grayEnable, portSetObj.magnifyType);


                    if (k == $('.printPage').length - 1) {
                        if (socket.readyState == 1) {
                            pop_up({
                                title: "打印提示",
                                message: "打印文件传输完毕！(点击确定退出打印页面)",
                                ok: closePrintMain,
                                yesName: "确定",
                                noName: "取消"
                            });
                        }
                    }

                },
                error: function () {
                    pop_up({title: "提示", message: "后台返回数据失败", yesName: "确定", noName: "取消"});
                }
            });

            console.timeEnd('time91');


            $('#canvas4PrintOut').hide();


            // //以下代码为下载此图片功能  用于查看输出打印的图像的jpg格式
            /* var page2jpgURL = filmPageOut.toDataURL("image/jpeg");
             var triggerDownload = $("<a>").attr("href", page2jpgURL).attr("download", "printPage.jpg").appendTo("body");
             triggerDownload[0].click();
             triggerDownload.remove();*/


        }
        // $('#canvas4PrintOut').hide();

    });
    showPrintPage(printStruct.printpage.pageIndex);//回到操作的那一页

}





/**
 * Created by SongJing on 2017/3/29.
 * 图像信息获取，绘制及处理的相关方法
 */

/*
 * 获取图像的信息
 * 按信息显示设置拼接信息
 * 返回拼接后的对象
 * 兼容拼接图像//0925
 * */
function imgInfoAsSet(seNo, imgId, ww, wl) {
    var imgInfo;
    imgInfo = printStruct.findOriInfoOnlyByOriId(imgId);//单张图像的信息
    var imgIdObj = {
        imgId: imgId,
        suid: 0,
        seriesLength: 0,//所属序列总共有多少张
        se: 0,//序列排序的序号
        imgIndex: 0//表示是序列中的第几张
    };
    //拼接信息字符串
    //1 清空装信息的数组
    //2 将需要的信息组装为字符串
    var imgInfoStrObj; //传入imgid 和窗口所对应的所有图像信息

    if ((imgId.indexOf("loadJoinImg") <0)){
        $.each(dvStruct.seriesArr, function (i) {
            var reFlag = false;
            $.each(dvStruct.seriesArr[i].dicomArr, function (j) {
                if (dvStruct.seriesArr[i].dicomArr[j].imageId === imgId) {
                    imgIdObj.suid = dvStruct.seriesArr[i].suid; //从dvStruct.seriesArr中找到匹配的序列号
                    imgIdObj.se = printStruct.countSNo(dvStruct.seriesArr[i].suid);
                    imgIdObj.seriesLength = dvStruct.seriesArr[i].dicomArr.length;
                    imgIdObj.imgIndex = j + 1;
                    // console.log(paraObj);
                    reFlag = true;
                    return;
                }
            });
            if (reFlag == true) {
                return;
            }
        });
        if (imgIdObj.suid != undefined && imgIdObj.imgIndex != undefined) {
            var printTags = getTagSet();
            imgInfoStrObj = creatInfoDataAsSet(imgInfo, imgIdObj, ww, wl, printTags.ltTagset, printTags.rtTagset, printTags.lbTagset, printTags.rbTagset);
        }
    }
    else{
        //填充拼接图像的信息
        var joinIndex = parseInt(imgId.substring(14));//根据图像ID得到图像索引编号
        var imgInfoStrObj = {
            ltInfo: [],
            lbInfo: [],
            rtInfo: [],
            rbInfo: []
        };

        imgInfoStrObj.ltInfo.push(joinOutputObj[joinIndex].hosName);

        imgInfoStrObj.rtInfo.push(joinOutputObj[joinIndex].name);
        imgInfoStrObj.rtInfo.push(joinOutputObj[joinIndex].age + ' ' + joinOutputObj[joinIndex].sex);
        imgInfoStrObj.rtInfo.push(joinOutputObj[joinIndex].birthDate.substr(0, 4) + '/' + joinOutputObj[joinIndex].birthDate.substr(4, 2) + '/' + joinOutputObj[joinIndex].birthDate.substr(6, 2));


        imgInfoStrObj.rbInfo.push(joinOutputObj[joinIndex].describe);
        imgInfoStrObj.rbInfo.push(joinOutputObj[joinIndex].studyDate.substr(0, 4) + '/' + joinOutputObj[joinIndex].studyDate.substr(4, 2) + '/' + joinOutputObj[joinIndex].studyDate.substr(6, 2));
        imgInfoStrObj.lbInfo.push("WW/WL:"+ww+"/"+wl);
    }
     // console.log("胶片信息==============");
     // console.log(imgInfoStrObj);
    return imgInfoStrObj;
}

/*
 * * 按信息显示设置拼接信息
 * 返回拼接后的对象
 * */
function creatInfoDataAsSet(imgInfo, imgIdObj, wl, ww, ltTags, rtTags, lbTags, rbTags) {
    var stringTemp;
    var imgInfoStrObj = {
        ltInfo: [],
        lbInfo: [],
        rtInfo: [],
        rbInfo: []
    };
    imgInfoStrObj.ltInfo.length = 0;
    imgInfoStrObj.lbInfo.length = 0;
    imgInfoStrObj.rtInfo.length = 0;
    imgInfoStrObj.rbInfo.length = 0;
    //lt  info
    for (var i = 0,len=ltTags.length; i < len; i++) {
        var tagsText = ltTags[i];

        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.ltInfo.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.ltInfo.push(stringTemp);

            }
        }
        if (tagsText == "机构编号") {

        }
        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.ltInfo.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.ltInfo.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.ltInfo.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.ltInfo.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }

        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }
        if (tagsText == "登记编号") {
            if (imgInfo.PatientInfo.AccessionNumber.val) {
                stringTemp =  imgInfo.PatientInfo.AccessionNumber.val;
                imgInfoStrObj.ltInfo.push(stringTemp);
            }
        }

    }

    //lb  info
    for (var i = 0,len=lbTags.length; i < len; i++) {
        var tagsText = lbTags[i];
        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.lbInfo.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }

        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.lbInfo.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.lbInfo.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.lbInfo.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();

            if (date) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }

        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.lbInfo.push(stringTemp);
            }

        }
        if (tagsText == "登记编号") {
            if (imgInfo.PatientInfo.AccessionNumber.val) {
                stringTemp =  imgInfo.PatientInfo.AccessionNumber.val;
                imgInfoStrObj.lbInfo.push(stringTemp);
            }
        }
    }

    //rt  info
    for (var i = 0,len=rtTags.length; i < len; i++) {
        var tagsText = rtTags[i];
        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.rtInfo.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "机构编号") {

        }
        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.rtInfo.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.rtInfo.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.rtInfo.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.rtInfo.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.rtInfo.push(stringTemp);
            }

        }
        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
        if (tagsText == "登记编号") {
            if (imgInfo.PatientInfo.AccessionNumber.val) {
                stringTemp = imgInfo.PatientInfo.AccessionNumber.val;
                imgInfoStrObj.rtInfo.push(stringTemp);
            }
        }
    }

    //rb  info
    for (var i = 0,len=rbTags.length; i < len; i++) {
        var tagsText = rbTags[i];

        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.rbInfo.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.rbInfo.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.rbInfo.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.rbInfo.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                stringTemp = 'T:' + theT + 'mm L:' + theL + 'mm';
                // stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.rbInfo.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
            }
            imgInfoStrObj.rbInfo.push(stringTemp);
        }
        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
        if (tagsText == "登记编号") {
            if (imgInfo.PatientInfo.AccessionNumber.val) {
                stringTemp =   imgInfo.PatientInfo.AccessionNumber.val;
                imgInfoStrObj.rbInfo.push(stringTemp);
            }
        }
    }
      console.log("************************************imgInfoAsSet******************************************");
      console.log(imgInfoStrObj);
    return imgInfoStrObj;
}


/*
 * 根据图像高宽设置字号
 * 没有根据比例，只是根据高宽分段设置字号
 * */
function calcFontsize(W, H) {
    var limit = Math.min(W, H);
    var fontsize = 10;
    if (limit < 300) {
        fontsize = 10;
    }
    else if ((limit >= 300 && limit < 500)) {
        fontsize = 12;
    }
    else if ((limit >= 500 && limit < 700)) {
        fontsize = 14;
    }
    else if ((limit >= 700 && limit < 900)) {
        fontsize = 16;
    }
    else if ((limit >= 900 && limit < 1000)) {
        fontsize = 18;
    }
    else if ((limit >= 1000) || (limit >= 1000)) {
        fontsize = 20;
    }
    else {
        fontsize = 22;
    }
    return fontsize;
}

/*
 * 根据图像高宽与用户选定字号计算实际使用字号
 * 根据比例进行计算
 * */
function calcFontsizeAsSet(W, H, baseFontsize) {
    var limit = Math.min(W, H);
    var fontsize;
    var scale = (limit - 800) / 800;
    if (scale < 0) {
        fontsize = parseInt((1 + scale / 2) * baseFontsize);
        if (fontsize < 10) {
            fontsize = 10;
        }

    }
    else {
        fontsize = parseInt((1 + scale / 2) * baseFontsize);
    }
    return fontsize;
}

/*
 * 在指定canvas 上绘制对应图像的信息
 * */
function drawInfoOnFilm(imageInfoObj, canvId, fontsize, fontType) {
    // console.log("在指定canvas 上绘制对应图像的信息===================================");
    // console.log(imageInfoObj);
    var canvas4Print = $("#" + canvId)[0];
    var context = canvas4Print.getContext('2d');
    var fontHeight = getFontHeight(fontsize, "pictos");
    var imgBlank = 3;
    context.fillStyle = "#fefefe";
    // context.font = fontsize+"px pictos"+fontType;
    context.font = fontsize + "px pictos";
    // console.log( context.font);

    //lt
    if (imageInfoObj.ltInfo.length > 0) {
        var initHeight = imgBlank + fontHeight / 2 + 3;
        for (var i = 0,len=imageInfoObj.ltInfo.length; i < len; i++) {
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.beginPath();
            context.scale(1, 1);
            context.textAlign = "start";
            context.fillText(imageInfoObj.ltInfo[i], 2, initHeight);//绘制截取部分
            initHeight += (fontHeight + imgBlank);
        }
    }
    //lb
    if (imageInfoObj.lbInfo.length > 0) {

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.beginPath();
        context.scale(1, 1);
        var ystart;
        var initHeight = imgBlank + fontHeight / 2;
        for (var i = 0,len=imageInfoObj.lbInfo.length; i < len; i++) {
            ystart = canvas4Print.height - initHeight;
            context.textAlign = "start";
            context.fillText(imageInfoObj.lbInfo[imageInfoObj.lbInfo.length - 1 - i], 2, ystart);//绘制截取部分
            initHeight += (fontHeight + imgBlank);
        }
    }

    //rt
    if (imageInfoObj.rtInfo.length > 0) {
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.beginPath();
        context.scale(1, 1);
        var initHeight = imgBlank + fontHeight / 2 + 3;
        for (var i = 0,len=imageInfoObj.rtInfo.length; i < len; i++) {
            context.textAlign = "end";
            context.fillText(imageInfoObj.rtInfo[i], canvas4Print.width, initHeight);//绘制截取部分
            initHeight += (fontHeight + imgBlank);

        }
    }

    //rb
    if (imageInfoObj.rbInfo.length > 0) {
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.beginPath();
        context.scale(1, 1);
        var xstart;
        var initHeight = imgBlank + fontHeight / 2;
        for (var i = 0,len=imageInfoObj.rbInfo.length; i < len; i++) {
            ystart = canvas4Print.height - initHeight;
            context.textAlign = "end";
            context.fillText(imageInfoObj.rbInfo[imageInfoObj.rbInfo.length - 1 - i], canvas4Print.width, ystart);//绘制截取部分
            initHeight += (fontHeight + imgBlank);
        }
    }
}




/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的显示设置和初始化
 */

/*
 * 胶片打印页面的高度获取
 * */
function boxH() {
    var boxH = $(document.body).height() - 30;
    $('.context').css("height", boxH + 'px');
}

/*
 * 对胶片大小，胶片布局和打印机设置进行初始化
 * 设置存在cookie中
 * */
function initSelec() {
    var paper = getCookie("paperSize");
    var printer = getCookie("printerName");
    var layout = getCookie("layout");
    console.log("read cookie");
    console.log(paper, printer, layout);
    //初始化打印机
    if (printer != "") {
        $('.printBoxSelect').val(printer);
    }
    //初始化布局
    if (layout != "") {
        var rowCol = layout.split("*");
        printStruct.printpage.row = parseInt(rowCol[0]);
        printStruct.printpage.col = parseInt(rowCol[1]);
    }
    else {
        printStruct.printpage.row = 1;
        printStruct.printpage.col = 1;
    }

    // $(".paperSize").find("option[value="+paper+"]").attr("selected",true);
    //初始化纸张大小
    var opts = document.getElementById("paperSize");
    if (paper != "") {
        for (var i = 0,len=opts.options.length; i < len; i++) {
            if (paper == opts.options[i].value) {
                opts.options[i].selected = 'selected';
                // alert(opts.options[i].value);
                break;
            }
        }
    }
    describe();//初始化描述

//    初始化字体设置
    var fontsize = getCookie("filmFontsize");
    // console.log("fontsize get:",fontsize);
    if (fontsize != "") {
        $('#tagFontsize').val(fontsize);
    }
}

/*
 * 进入胶片打印页面时根据胶片布局初始化打印页面
 * 初始化一些相关描述用信息
 * */
function initPage() {
    printStruct.printpage.pagetotal = 1;
    $('.totalImgNo').text(printStruct.printpage.pagetotal);
    var direct = $('.paperDirection').val();


    var type = $('#paperSize').val();

    addprintPage(direct, type);
    printStruct.printpage.pageIndex = printStruct.printpage.pagetotal;
    showPrintPage(printStruct.printpage.pageIndex);//增加后自动显示增加的那页
    $('.currentPageIndex').val(printStruct.printpage.pageIndex);

    // var layoutStr = "胶片布局" + "(" + printStruct.printpage.row + "X" + printStruct.printpage.col + ")";
    var layoutStr = "胶片布局" + "(" + printStruct.printpage.col + "X" + printStruct.printpage.row + ")";
    $('.filmLayout').text(layoutStr);

}

/*
 * 根据所有图像序列初始化胶片打印页面左侧缩略图图像布局
 * */
function initImgBoxL() {

    var leftImgBox = $('#printLeftImgBox');//最外层
    leftImgBox.empty();


    for (var i = 0,len=dvStruct.seriesArr.length; i < len; i++) {
        var imgInfo = printStruct.findOriInfoOnlyByOriId(dvStruct.seriesArr[i].dicomArr[0].imageId);
        var name = imgInfo.PatientInfo.PatientName.val;
        var date = imgInfo.StudyInfo.StudyDate.val.toString();
        var time = imgInfo.StudyInfo.StudyTime.val.toString();
        var datestr;
        if (date && time) {
            datestr = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
        }

        var patientNameShow=name;

        var byteLen=getByte(name);

        if(byteLen>8){
            patientNameShow=cutString(name,8,"...");
        } 

       /* if($("div[name="+name+"]").length==0){
            var title=$("<div class='infoTitle'>"+name+"</div>");
            var patientHtml=$("<div class='patientName' name='"+name+"'></div>");
            patientHtml.append(title);
            leftImgBox.append(patientHtml);
        }*/
        var boxId = "series" + i;
        var seriesBoxId = "seriesbox" + i;

        var seriesBoxhtml = "<ul class='orderUl'>" +
            "<li class='orderLi'>" +
              // " <span class='info' style='font-size: 10px'>" + name + "</span>" +
            // "<span class='info'  style='font-size: 10px'>" + datestr + "</span>" +
            " <div class='orderTitle font12' title='图像数：" +
            dvStruct.seriesArr[i].dicomArr.length +"'>" +

            " <div class='left'>" +
            " <span class='info' style='font-size: 10px' title='"+name+"'>" + patientNameShow + "</span>" +
              // "<span id='" + boxId + "' style='font-size: 10px;'>图像数：</span><span>" + dvStruct.seriesArr[i].dicomArr.length +"</span>"+
            "<span id='" + boxId + "' style='font-size: 10px; line-height: 15px;'>"+datestr+"</span>" +

            "<span id='" + boxId + "img'> </span>" +

            "</div>" +
            "<div class='right'>" +
            "<i class='fa fa-caret-down icon' style='display: none; line-height: 30px' aria-hidden='true'></i>" +
            "<i class='fa fa-caret-right icon' aria-hidden='true'></i>" +
            " </div>" +

            " </div>" +

            " <ul id='" + seriesBoxId + "' class='imgUl ui-widget-header'>" +
            " </ul>" +
            " </li>" +
            "</ul>";
        leftImgBox.append(seriesBoxhtml);
        // $("div[name="+name+"]").append(seriesBoxhtml);
        var imgParent = $("#" + seriesBoxId);
        for (var j = 0,len2=dvStruct.seriesArr[i].dicomArr.length; j <len2 ; j++) {
            var elementId = "leftImg" + i + "_" + j;
            var imageIdtemp = dvStruct.seriesArr[i].dicomArr[j].imageId;
            var seriNo = dvStruct.seriesArr[i].sNo;//添加 一个seNo
            var imghtml = $(" <li id='" + elementId + "' imageId='" + imageIdtemp + "' seriNo='" + seriNo + "' class='imgLi'></li>");
            imgParent.append(imghtml);

            //填充图像
            var element = $("#" + elementId).get(0);
            cornerstone.enable(element);
            // cornerstoneTools.mouseInput.enable(element);//会引起该元素屏蔽mousedown事件
            cornerstone.loadImage(dvStruct.seriesArr[i].dicomArr[j].imageId).then(function (image) {
                cornerstone.displayImage(element, image); //方位标签
            });
            //填充图像end

            var joinDiv=$("<div class='joinDiv'  onClick='event.cancelBubble = true'></div>");
            imghtml.append(joinDiv);
            imghtml.find('.joinDiv').draggable({
                appendTo: "body",
                helper: "clone",
                imageId: "",
                start: function () {
                    this.imageId = $(this).parent().attr('imageId');
                    // console.log(this.imageId);

                },
                drag: function () {
                    // console.log("drag");
                },
                stop: function (event) {
                    var position = getXAndY(event);
                    position.x -= 105;
                    position.y -= 105;
                    if (joinStruct._dragIn) {

                        var imgInfo = printStruct.findOriInfoOnlyByOriId(this.imageId);
                        var imgW=parseInt(imgInfo.ImageInfo.Columns.val);
                        var imgH=parseInt(imgInfo.ImageInfo.Rows.val);
                        // console.log(imgInfo);
                        var pixelSpacing=imgInfo.ImageInfo.PixelSpacing.val;
                        var spacing=pixelSpacing.split("\\");//图像间距
                        var size=joinImgSize(imgW, imgH);
                        var actualW=parseFloat(spacing[0])*imgW;
                        var actualH=parseFloat(spacing[1])*imgH;
                        // console.log("spacing===1===",imgW,imgH,spacing,actualW,actualH);
                        spacing[0]=actualW/size[0];
                        spacing[1]=actualH/size[1];//重新计算像素间距
                        // console.log("spacing===2===",spacing,size);

                        var name=imgInfo.PatientInfo.PatientName.val;
                        var studyDate=imgInfo.StudyInfo.StudyDate.val;
                        var sex=imgInfo.PatientInfo.PatientSex.val;
                        var age=imgInfo.PatientInfo.PatientsAge.val;
                        var birthDate=imgInfo.PatientInfo.PatientBirthDate.val;
                        var hosName=imgInfo.EquipmentInfo.InstitutionName.val;
                        var describe=imgInfo.StudyInfo.StudyDescription.val;
                        // console.log(imgInfo);
                        var patientID=imgInfo.PatientInfo.PatientID.val;
                        var studyTime=imgInfo.StudyInfo.StudyTime.val;
                        var modality=imgInfo.SeriesInfo.Modality.val;

                        if (this.imageId != null&& isImgExist(this.imageId)) {
                            // console.log("add image");
                            var html = $('<div class="joinImg draggable ui-widget-content " patientID="'+patientID+'" studyTime="'+studyTime+'" modality="'+modality+'" ' +
                                ' name="'+name+'" studyDate="'+studyDate+'" sex="'+sex+'" age="'+age+'" birthDate="'+birthDate+'" hosName="'+hosName+'" describe="'+describe+'" '   +
                                'actualW="'+actualW+'"  actualH="'+actualH+'"' +
                                'spacingX="'+spacing[0]+'"   spacingY="'+spacing[1]+'" ' +
                                'imageId="'+this.imageId +'"  W="'+imgW+'" H="'+imgH+'" ' +
                                'style="top: ' + position.y + 'px;left: ' + position.x + 'px; width:'+size[0]+'px; height:'+size[1]+'px; ">' +
                                '</div>');
                            $('.joinBox').append(html);
                            // html.width(parseInt( html.width()));
                            // html.height(parseInt( html.height()));
                            html.draggable({
                                containment: ".joinBox",//移动范围
                                stack: html,//重叠时的z-index
                                scroll: false,
                                start:function () {
                                    // console.log("start");
                                    html.css('opacity','0.5');
                                    // html.css('cursor',"move");
                                    // html.children().css('cursor',"move"); $('.joinBox').css('cursor',"move");
                                },
                                drag:function () {
                                    // console.log("drag888");
                                    //   html.css('cursor',"move");
                                    //   html.children().css('cursor',"move");
                                    //   $('.joinBox').css('cursor',"move");

                                },
                                stop:function () {
                                    // html.css('cursor',"default");
                                    // html.children().css('cursor',"default");
                                    // console.log("stop");
                                    html.css('opacity','1');
                                    // $('.joinBox').css('cursor',"default");
                                }
                            });
                            $( ".joinBox.joinImg " ).draggable({ stack: ".joinBox.joinImg" });
                            // $( ".joinBox.joinImg " ).resizable();




                            //绘制图像
                            var element = html.get(0);
                            cornerstone.disable(element);//清除上一次使用时留下的信息
                            cornerstone.enable(element);
                            cornerstone.loadImage(this.imageId).then(function (image) {
                                cornerstone.displayImage(element, image);
                            });
                            //绘制图像end


                            //大小可拖动改变
                         /*   html.resizable({
                                handles:"se",
                                aspectRatio: imgW/imgH
                            });
                            html.resize(function () {
                                var element = $(this).get(0);
                                cornerstone.resize(element, true);//图像显示大小同步更新
                            });*/

                            var adjustHtml=$('<div class="adjustDiv"><div class="btn join_delete " title="删除"><img src="ipacsdv/css/img/print/join_delete.png"></div><div class="btn join_adjust" title="裁剪"><img src="ipacsdv/css/img/print/join_cut.png"></div></div>');
                            html.append(adjustHtml);
                            html.hover(function () {
                                 $(adjustHtml).find('.btn').show();
                            },function () {
                                $(adjustHtml).find('.btn').hide();
                            });
                        }
                    }
                    joinStruct._dragFlag = false;
                    joinStruct._dragIn = false;
                    this.imageId = null;
                }
            });
        }
    }
  /*  $('.imgLi').each(function () {
        $(this).draggable({
            appendTo: "body",
            helper: "clone",
            imageId: "",
            start: function () {
                this.imageId = $(this).attr('imageId');
                // console.log(this.imageId);
                $('.joinBox').css('cursor','pointer');
            },
            drag: function () {
                // console.log("drag");
            },
            stop: function (event) {
                $('.joinBox').css('cursor','default');
                var position = getXAndY(event);
                position.x -= 105;
                position.y -= 105;
                if (joinStruct._dragIn) {
                    if (this.imageId != null&& isImgExist(this.imageId)) {
                        // console.log("add image");
                        var html = $('<div class="joinImg draggable ui-widget-content img-container " imageId="'+this.imageId +'" style="top: ' + position.y + 'px;left: ' + position.x + 'px;"></div>');
                        $('.joinBox').append(html);


                        //绘制图像
                        var element = html.get(0);
                        cornerstone.disable(element);//清除上一次使用时留下的信息
                        cornerstone.enable(element);
                        cornerstone.loadImage(this.imageId).then(function (image) {
                            cornerstone.displayImage(element, image);
                        });
                        //绘制图像end

                        html.draggable({
                            containment: ".joinBox",//移动范围
                            stack: html,//重叠时的z-index
                            scroll: false,
                            start:function () {
                                html.css('opacity','0.6');
                            },
                            drag:function () {

                                cornerstone.resize(element, true);//图像显示大小同步更新
                            },
                            stop:function () {
                                console.log(html.children(0));
                                html.css('opacity','1');
                            }
                        });
                        $( ".joinBox.joinImg " ).draggable({ stack: ".joinBox.joinImg"
                        });




                    }
                }
                joinStruct._dragFlag = false;
                joinStruct._dragIn = false;
                this.imageId = null;
            }
        });

    });*/

     //添加拖动层
     /*$('.imgLi').each(function () {
        // var joinDiv=$("<div class='joinDiv' onmousedown='joinDragEnable()'></div>");
        var joinDiv=$("<div class='joinDiv'  onClick='event.cancelBubble = true'></div>");
        $(this).append(joinDiv);
        $(this).find('.joinDiv').draggable({
            appendTo: "body",
            helper: "clone",
            imageId: "",
            start: function () {
                this.imageId = $(this).parent().attr('imageId');
                 // console.log(this.imageId);

            },
            drag: function () {
                // console.log("drag");
            },
            stop: function (event) {
                var position = getXAndY(event);
                position.x -= 105;
                position.y -= 105;
                if (joinStruct._dragIn) {

                    var imgInfo = printStruct.findOriInfoOnlyByOriId(this.imageId);
                    var imgW=parseInt(imgInfo.ImageInfo.Columns.val);
                    var imgH=parseInt(imgInfo.ImageInfo.Rows.val);
                     // console.log(imgInfo);
                    var pixelSpacing=imgInfo.ImageInfo.PixelSpacing.val;
                    var spacing=pixelSpacing.split("\\");//图像间距
                    var size=joinImgSize(imgW, imgH);
                    var actualW=parseFloat(spacing[0])*imgW;
                    var actualH=parseFloat(spacing[1])*imgH;
                    // console.log("spacing===1===",imgW,imgH,spacing,actualW,actualH);
                    spacing[0]=actualW/size[0];
                    spacing[1]=actualH/size[1];
                    // console.log("spacing===2===",spacing,size);

                    var name=imgInfo.PatientInfo.PatientName.val;
                    var studyDate=imgInfo.StudyInfo.StudyDate.val;
                    var sex=imgInfo.PatientInfo.PatientSex.val;
                    var age=imgInfo.PatientInfo.PatientsAge.val;
                    var birthDate=imgInfo.PatientInfo.PatientBirthDate.val;
                    var hosName=imgInfo.EquipmentInfo.InstitutionName.val;
                    var describe=imgInfo.StudyInfo.StudyDescription.val;
                    // console.log(imgInfo);
                    var patientID=imgInfo.PatientInfo.PatientID.val;
                    var studyTime=imgInfo.StudyInfo.StudyTime.val;
                    var modality=imgInfo.SeriesInfo.Modality.val;

                    if (this.imageId != null&& isImgExist(this.imageId)) {
                        // console.log("add image");
                        var html = $('<div class="joinImg draggable ui-widget-content " patientID="'+patientID+'" studyTime="'+studyTime+'" modality="'+modality+'" ' +
                            ' name="'+name+'" studyDate="'+studyDate+'" sex="'+sex+'" age="'+age+'" birthDate="'+birthDate+'" hosName="'+hosName+'" describe="'+describe+'" '   +
                            'actualW="'+actualW+'"  actualH="'+actualH+'"' +
                            'spacingX="'+spacing[0]+'"   spacingY="'+spacing[1]+'" ' +
                            'imageId="'+this.imageId +'"  W="'+imgW+'" H="'+imgH+'" ' +
                            'style="top: ' + position.y + 'px;left: ' + position.x + 'px; width:'+size[0]+'px; height:'+size[1]+'px; "></div>');
                        $('.joinBox').append(html);
                        // html.width(parseInt( html.width()));
                        // html.height(parseInt( html.height()));
                        html.draggable({
                            containment: ".joinBox",//移动范围
                            stack: html,//重叠时的z-index
                            scroll: false,
                            start:function () {
                                // console.log("start");
                                html.css('opacity','0.5');
                                // html.css('cursor',"move");
                                // html.children().css('cursor',"move"); $('.joinBox').css('cursor',"move");
                            },
                            drag:function () {
                              // console.log("drag888");
                              //   html.css('cursor',"move");
                              //   html.children().css('cursor',"move");
                              //   $('.joinBox').css('cursor',"move");
                            },
                            stop:function () {
                                // html.css('cursor',"default");
                                // html.children().css('cursor',"default");
                                // console.log("stop");
                                html.css('opacity','1');
                                // $('.joinBox').css('cursor',"default");
                            }
                        });
                        $( ".joinBox.joinImg " ).draggable({ stack: ".joinBox.joinImg" });
                        // $( ".joinBox.joinImg " ).resizable();




                        //绘制图像
                        var element = html.get(0);
                        cornerstone.disable(element);//清除上一次使用时留下的信息
                        cornerstone.enable(element);
                        cornerstone.loadImage(this.imageId).then(function (image) {
                            cornerstone.displayImage(element, image);
                        });
                        //绘制图像end
                       /!* html.resizable({
                            containment: ".joinBox",//移动范围
                            // maxHeight:1500,
                            // maxWidth:1500,
                            aspectRatio:$(this).width()/$(this).height(),

                            resize:function ( ) {
                            var ele=$(this).get(0);
                              cornerstone.resize(ele, true);//图像显示大小同步更新
                        }
                        });*!/

                        //大小可拖动改变
                        html.resizable({
                            handles:"se",
                            aspectRatio: imgW/imgH
                        });
                        html.resize(function () {
                            var element = $(this).get(0);
                            cornerstone.resize(element, true);//图像显示大小同步更新
                        });

                    }
                }
                joinStruct._dragFlag = false;
                joinStruct._dragIn = false;
                this.imageId = null;
            }
        });

    });
*/


}

/*
 * 初始化胶片布局
 * 编号和信息显示一并初始化
 * */
function initImgBoxM(row, col, pageId) {
    var pageWidth = $('.printPage').width();
    var pageHeight = $('.printPage').height();

    // var perW = (pageWidth - col * 2 * printStruct.lineBlank + (col - 1) * printStruct.lineBlank) / col;
    // var perH = (pageHeight - row * 2 * printStruct.lineBlank + (row - 1) * printStruct.lineBlank) / row;

    var scaleW = (100 / col) + "%";
    var scaleH = (100 / row) + "%";
    var perW = pageWidth / col;
    var perH = pageHeight / row;


    var perPageDom = $("#" + pageId);
    perPageDom.empty();
    for (var j = 0; j < row; j++) {
        for (var k = 0; k < col; k++) {
            var imgIndexID = pageId + "img" + (j * (col) + k);
            var viewportNo = j * (col) + k + 1;
            // var imgTemp = "<div class='printWrapper' style=' height:" + perH + 'px' + ';width:' + perW + 'px' + ";'><div id='" + imgIndexID + "'" + "  No='" + (j * (col) + k) + "'style='line-height:"+perH+"px; ' class='printViewport'>"+viewportNo+"</div></div>";
            // var imgTemp = "<div class='printWrapper' style=' height:" + perH + 'px' + ';width:' + perW + 'px' + ";'><div id='" + imgIndexID + "'" + "  No='" + (j * (col) + k) + "'style='line-height:"+perH+"px; ' class='printViewport'></div></div>";
            //  var imgTemp = "<div class='printWrapper' style=' height:" + perH + 'px' + ';width:' + perW + 'px' + ";'><div id='" + imgIndexID + "'" + "  No='" + (j * (col) + k) + "' class='printViewport '></div></div>";


            var imgTemp = "<div class='printWrapper' style=' height:" + scaleH +
                ';width:' + scaleW + ";'><div id='" + imgIndexID + "'" +
                "  No='" + viewportNo + "' imgIn='false'  class='singleViewport printViewport'></div></div>";


            perPageDom.append(imgTemp);//添加wrapperbox
            addInfoLay(imgIndexID);
            addBoxNoLay(imgIndexID);

            /* var viewPortDom = $("#" + imgIndexID);
             //左上标签信息
             var lthtml = "<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'>" +
             " <div class=''><span class='print-info print-info-nowNo'></span><span class='print-info print-info-totalNo'></span></div>" +
             " <div class='print-info-SeNo print-info'></div>" +
             "  <div class='print-info-ProtocolName print-info'></div>" +
             " <div class='print-info-StudyDescription print-info'></div>" +
             "  </div> ";
             //右上标签信息
             var rthtml = "   <div class='printOverlay printOverlay-rt' style='top:0px; right:0px;text-align: right'>" +
             "   <div class='print-info-InstitutionName print-info'></div>" +
             "   <div class='print-info-PatientName print-info'></div>" +
             "   <div class='print-info-PatientID print-info'></div>" +
             "   <div><span  class='print-info-PatientBirthDate print-info'></span><span class='print-info-PatientAge print-info'></span><span class='print-info-PatientSex print-info'></span></div>" +
             "   <div class='print-info-CBZ print-info'></div>" +
             "    </div>";
             //左下签信息
             var lbhtml = "  <div class='printOverlay printOverlay-lb' style='bottom:0px; left:0px;text-align:left'>" +
             "   <div class='print-info-zoom print-info'></div>" +
             "   <div class='print-info-wwwl print-info'></div>" +
             "    <div class='print-info-TL print-info'></div>" +
             "   </div>";
             //右下标签信息
             var rbhtml = "   <div class='printOverlay printOverlay-rb' style='bottom:0px; right:0px;text-align: right'>" +
             "  <span class='print-info-kvp print-info'></span>" +
             "    <span class='print-info-mA print-info'></span>" +
             "   <div class='print-info-fov print-info'></div>" +
             "   <div class='print-info-MagneticFieldStrength print-info'></div>" +
             "   <div class='print-info-TrTe print-info'></div>" +
             "    <div class='print-info-datetime print-info'></div>" +
             "    </div>";

             viewPortDom.append(lthtml);
             viewPortDom.append(rthtml);
             viewPortDom.append(lbhtml);
             viewPortDom.append(rbhtml);

             //    格子编号标识
             //     var boxNohtml="<span class='printViewportNo' style='top:"+perH/2+"px; text-align: center; margin:auto'>"+viewportNo+"</span>" ;
             // var boxNohtml="<span class='singleViewportNo printViewportNo' style=' top:"+(perH/2-30)+"px; left:"+(perW/2-30)+"px; text-align: center; color: red'>"+viewportNo+"</span>" ;
             // var boxNoHtml="<span style='top:"+(perH/2-30)+"px; left:"+(perW/2-30)+"px; position: absolute;  color: red;text-align: center;font-size: 50%'>"+viewportNo+"</span>";
             var boxNoHtml="<span class='viewportBoxNo' style='pointer-events:none;top:10px; left:10px; position: absolute;  color: #E9E7E2;text-align: center;font-size: 100%'>"+viewportNo+"</span>";

             viewPortDom.append(boxNoHtml);*/

        }
    }
}

/*
 * 增加胶片页
 * 强制在最后添加一页
 * 增加胶片页的同时调用布局初始化，增加页的布局为当前布局设置中的布局
 */
function addprintPage(direct, type) {
    var printPageBox = $('.printPageBox');
    var pageId = "page" + printStruct.printpage.pagetotal;
    var pageW = $('#page0').width();
    var pageH = $('#page0').height();
    var pagehtml = "<div id='" + pageId + "' papertype='" + type + "' paperdirect='" + direct + "' row='" + printStruct.printpage.row + "'col='" + printStruct.printpage.col + "'class='printPage' style='width:" + pageW + "px;height:" + pageH + "px; display: none;'>" +
        "</div>";
    printPageBox.append(pagehtml);
    initImgBoxM(printStruct.printpage.row, printStruct.printpage.col, pageId);//初始化打印布局
}

/*
 * 在当前页后插入1页胶片页
 * 插入页的布局为当前布局设置中的布局
 * */
function insertprintPage(curPageId, insertTotal, row, col, type, direct) {
    // console.log(direct,type);
    //在第curPageId页后插入页
    var insertPageId;
    for (var i = 0; i < insertTotal; i++) {
        insertPageId = "xnsert" + i;
        var pageW = $('#page0').width();
        var pageH = $('#page0').height();
        var pagehtml = "<div id='" + insertPageId + "' papertype='" + type + "' paperdirect='" + direct + "' row='" + printStruct.printpage.row + "'col='" + printStruct.printpage.col + "'class='printPage' style='width:" + pageW + "px;height:" + pageH + "px; display: none;'>" +
            "</div>";
        $("#" + curPageId).after(pagehtml);
        curPageId = insertPageId;//向后增加
        initImgBoxM(row, col, insertPageId);//以当前页的ROW COL 来初始化新加的页
    }
}

/*
 * 删除当前胶片页
 * 删除后默认显示第一页胶片
 * */
function deleteprintPage(pageIndex) {
    if (pageIndex > 0) {
        var pageId = "page" + pageIndex;
        $("#" + pageId).remove();
    }
    //删除当前页后自动跳到第一页显示
    printStruct.printpage.pagetotal = $('.printPage').length - 1;
    $('.totalImgNo').text(printStruct.printpage.pagetotal);
    if (printStruct.printpage.pagetotal > 0) {
        orderPageId();//重新对pageID进行整理
        $('.currentPageIndex').val(1);
        printStruct.printpage.pageIndex = 1;
        showPrintPage(printStruct.printpage.pageIndex);
    }
    else {
        $('.currentPageIndex').val(0);
        printStruct.printpage.pageIndex = 0;
    }
}


/*
 * 添加与当前胶片页布局相同的页在当前胶片页之后
 * 用于图像拖入时调用
 * */
function addSameLayoutPage(pageId) {

    var regStr = "page" + printStruct.printpage.pagetotal;
    var resplaceStr = "page" + (printStruct.printpage.pagetotal + 1);
    // console.log(regStr+'---'+resplaceStr);

    var viewportIdArr = [];
    viewportIdArr.length = 0;
    $("#" + pageId).find('.printViewport').each(function () {
        viewportIdArr.push($(this).attr("id"));
    });
    //  console.log(viewportIdArr);

    var clonenode = $("#" + pageId).clone();//取得复制节点
    for (var i = 0,len=viewportIdArr.length; i <len ; i++) {
        var newID = viewportIdArr[i].replace(regStr, resplaceStr);
        // console.log("newID:--"+newID);
        clonenode.find("#" + viewportIdArr[i]).attr("imageid", "");
        clonenode.find("#" + viewportIdArr[i]).attr("seno", "");
        clonenode.find("#" + viewportIdArr[i]).attr("group", "");
        clonenode.find("#" + viewportIdArr[i]).attr("imgIn", "false");
        // $("#"+viewportIdArr[i]+" canvas").remove();
        clonenode.find("#" + viewportIdArr[i]).empty();//清空canvas
        clonenode.find("#" + viewportIdArr[i]).attr("id", newID);//最后替换id

    }
    clonenode.attr("id", resplaceStr);//修改page的id
    $("#" + pageId).after(clonenode);

    $("#" + resplaceStr).find('.printViewport').each(function (k, val) {
        addBoxNoLay($(this).attr('id'));
    });
    printStruct.printpage.pagetotal = printStruct.printpage.pagetotal + 1;//page总数添加
    printStruct.printpage.pageIndex = printStruct.printpage.pageIndex + 1;
    //  console.log( printStruct.printpage.pagetotal+'----'+ printStruct.printpage.pageIndex);
    $('.totalImgNo').text(printStruct.printpage.pagetotal);//更新胶片数
    $('.currentPageIndex').val(printStruct.printpage.pageIndex);
    describe();
    return resplaceStr;


}

/*
 * 胶片页清理
 * 当胶片页面中没有图像时删除此胶片
 * 用于图像拖入时调用
 * */
function pageClear() {

    $('.printPage').each(function (k, val) {
        if (k != 0 && k != 1) {
            if ($(this).find("div[imgIn=true]").length == 0) {
                $(this).remove();
                printStruct.printpage.pagetotal = printStruct.printpage.pagetotal - 1;
            }
        }
    });
    if (printStruct.printpage.pageIndex > printStruct.printpage.pagetotal)
        printStruct.printpage.pageIndex = 1;
    $('.currentPageIndex').val(printStruct.printpage.pageIndex);
    $('.totalImgNo').text(printStruct.printpage.pagetotal);

}


/*
 * 整理page的各个属性，修改的属性包括  id  page**img**
 * */
function orderPageId() {
    var pageTotal = 0;
    var imgBoxNo = 0;
    $('.printPage').each(function (m, val) {
        var afterPageId = "page" + m;
        //page0 不参与所有设置与布局
        if ($(this).attr('id') === "page0") {
        }
        else {
            $(this).attr('id', afterPageId);
            $(this).children().children().each(function (n, val) {
                if ($(this).attr('id')) {
                    var oldImgId = $(this).attr('id');
                    var newImgId = afterPageId + oldImgId.substr(oldImgId.indexOf("i"), oldImgId.length);
                    $(this).attr('id', newImgId);
                }
            });
            $(this).children().each(function (k, val) {
                $(this).attr('boxNo', imgBoxNo);
                imgBoxNo++;
            });
            pageTotal++;
        }
    });
    return pageTotal;
}


/*
 * 显示指定的胶片页pageIndex
 * */
function showPrintPage(pageIndex) {
    var pageId = "page" + pageIndex;
    $('.printPage').each(function (m, val) {
        if ($(this).attr('id') === pageId) {
            var pageW = $('#page0').width();
            var pageH = $('#page0').height();
            $(this).css({
                'width': pageW,
                'height': pageH
            });
            $(this).show();
            $(this).find("div[imgIn=true]").each(function (k, val) {
                var element = $(this).get(0);
                cornerstone.resize(element, true);//图像显示大小同步更新
            });
        }
        else {
            $(this).hide();
        }

    });
}

/*
 * 显示指定pageID的胶片页*/
function showPageId(pageId) {
    $('.printPage').each(function (m, val) {
        if ($(this).attr('id') === pageId) {
            var pageW = $('#page0').width();
            var pageH = $('#page0').height();
            $(this).css({
                'width': pageW,
                'height': pageH
            });
            $(this).show();
            $(this).find("div[imgIn=true]").each(function (k, val) {
                var element = $(this).get(0);
                cornerstone.resize(element, true);//图像显示大小同步更新
            });
        }
        else {
            $(this).hide();
        }

    });
}


/*
 * 纸张类型改变时，同步当前胶片的对应属性
 * */
function changePagetype() {
    // var direct = $('.paperDirection').val();
    var type = $('#paperSize').val();
    $('.printPage').each(function () {
        $(this).attr('papertype', type);
    });
}

/*
 * 根据页面大小调整当前胶片中图像显示的大小
 * */
function changeboxSize() {
    var pageWidth = $('.printPage').width();
    var pageHeight = $('.printPage').height();

    $("div[imgIn=true]").each(function () {
        var elementId = $(this).attr('id');
        var imgCanvas = $('#' + elementId)[0];//最终输出胶片页的canvas
        imgCanvas.width = $("#" + elementId).width();
        imgCanvas.height = $("#" + elementId).height();
        var element = $("#" + elementId).get(0);
        // if ($("#" + elementId).attr('imgIn')=="true") {
        cornerstone.resize(element, true);//图像显示大小同步更新
        // }
    });

}

/*
 * 更新最上方的胶片描述
 * */
function describe() {
    //实时更新胶片数
    var filmNo = 0;
    var filmIndex = 0;
    var papersize = "";
    var describStr = "胶片共0张";
    if ($('.totalImgNo').text() != undefined) {
        filmNo = $('.totalImgNo').text();
    }
    if ($('.currentPageIndex').val() != undefined) {
        filmIndex = $('.currentPageIndex').val();
    }

    if ($('#paperSize').val() != undefined) {
        papersize = $('#paperSize').val();
    }
    if(filmNo==0)filmNo=1;
    if(filmIndex==0)filmIndex=1;
    describStr = "胶片共" + filmNo + "张，" + "当前为第" + filmIndex + "张，胶片大小：" + papersize;
    $('#printDescr').text(describStr);

}





/**
 * Created by SongJing on 2017/3/28.
 * 图像过滤的相关操作
 * 图像过滤是胶片打印时图像的批处理操作
 */

/*
 * 过滤弹出框的初始化
 * */
function filterInit() {
    var elementId = $('.imgViewportSelected').attr('id');
    var elementSeNo = $('.imgViewportSelected').attr('seNo');
    var selectorStr = ".printViewport[seNo=" + elementSeNo + "]";
    var imageTotal = $(selectorStr).length;//过滤序列的图像总数
    $("#filterTotal").text(imageTotal);
    $("#filterEndIndex").text(imageTotal);
    $("#beginIndex").val(1);
    $("#endIndex").val(imageTotal);
    $("#interval").val(0);
    show($('.filterBox'));
}

/*
 * 确认过滤
 * 根据过滤条件过滤胶片中的图像
 * */
function filterOk() {
    var beginIndex = parseInt($("#beginIndex").val());
    var endIndex = parseInt($("#endIndex").val());
    var interval = parseInt($("#interval").val());

    var elementId = $('.imgViewportSelected').attr('id');
    var elementSeNo = $('.imgViewportSelected').attr('seNo');
    var selectorStr = ".printViewport[seNo=" + elementSeNo + "]";
    var imageTotal = $(selectorStr).length;


    if (beginIndex == 1 && endIndex == imageTotal && ( interval == 0)) {
        pop_up({title: "过滤提示", message: "当前参数设置:不需要过滤！", yesName: "确定", noName: "取消"});
    }
    else if (interval >= imageTotal) {
        pop_up({title: "过滤提示", message: "当前参数设置:过滤间隔过大！", yesName: "确定", noName: "取消"});

    }
    else if (interval == 0) {
        //间隔为0，不做处理
    }
    //    执行过滤处理
    else {
        //去除标记
        clearSelecCss();
        //标记删除图像
        var inertvalIndex = 0;
        $(selectorStr).each(function (m, val) {
            if (m < beginIndex - 1) {

            }
            else if (m >= endIndex) {

            }
            else {
                // console.log("index:"+inertvalIndex);
                if (inertvalIndex == 0) {

                }
                else {
                    $(this).addClass('imgViewportSelected');
                }

                if (inertvalIndex == interval) {
                    inertvalIndex = 0;
                }
                else {
                    inertvalIndex++;
                }
            }
        });

        $('.printViewport').each(function (k, val) {
            if ($(this).attr('imgIn') == "true" && !($(this).hasClass('imgViewportSelected'))) {
                printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                var element = $(this).get(0);
                var viewport = deepCopy1(cornerstone.getViewport(element));
                printStruct.viewportArr.viewport.push(viewport);
                //cornerstone.disable(element);
            }
            if ($(this).attr('imgIn') == "true") {
                cornerstone.disable($(this).get(0));
                $(this).attr('imgIn', "false");
            }

            $(this).removeClass('imgViewportSelected');
            $(this).parents('.printWrapper').removeClass('imgBoxSelected');
        });

        //回填图像
        // console.log(printStruct.viewportArr.viewport.length);
        //    回填图像
        if (printStruct.viewportArr.viewport.length > 0) {
            // console.log("回填图像================");
            var viewportfillInID = $("div[imgIn=false]").attr('id');
            for (var i = 0,len=printStruct.viewportArr.viewport.length; i <len ; i++) {
                var viewport = printStruct.viewportArr.viewport[i];
                var imageId = printStruct.viewportArr.imageId[i];
                var seNo = printStruct.viewportArr.seNo[i];
                if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                    $("div[imgIn=false]").parents('.printPage').show();
                }
                fillImageSyn(viewportfillInID, imageId, seNo, viewport);

                $("#" + viewportfillInID).attr('imgIn', "true");//添加行列属性
                $("#" + viewportfillInID).attr('imageid', imageId);
                $("#" + viewportfillInID).attr('seNo', seNo);//添加合并方式属性

                viewportfillInID = $("div[imgIn=false]").attr('id');
            }


            pageClear();//空白 页清理
            showPrintPage(printStruct.printpage.pageIndex);
            describe();

        }


        /*  var pageIndexOrig = printStruct.printpage.pageIndex;//记录删除图像所在页
         // layoutSyn(printStruct.printpage.row, printStruct.printpage.col);
         if (printStruct.printpage.pagetotal >= pageIndexOrig) {
         printStruct.printpage.pageIndex = pageIndexOrig;
         }
         else {
         var newPageIndex = printStruct.printpage.pageIndex - 1;
         if (newPageIndex > 0) {
         printStruct.printpage.pageIndex = newPageIndex;
         }
         else {
         printStruct.printpage.pageIndex = 0;
         }
         }
         showPrintPage(printStruct.printpage.pageIndex);//显示最初操作的页
         $('.currentPageIndex').val(printStruct.printpage.pageIndex);*/
    }
    cancel($('.filterBox'));
}

/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面中四角信息的显示相关方法
 */
if (!printStruct) {
    var printStruct = {};
}
/*
 * 在打印页面初始化病人信息显示
 * */
function initPatientInfo() {
    //序列总数
    var seriSumNo = dvStruct.seriesArr.length;
    console.log("序列总数:" + seriSumNo);
    $('#printSeriSum').text(seriSumNo);
}

/*
 * 指定elementId中的图像信息层信息填充
 * */
function fillImgInfoOnScreen(elementId) {
    //无图像直接返回
    if ($("#" + elementId).children().length < 1) {
        return;
    }
    var element = $("#" + elementId).get(0);
    var viewport = deepCopy1(cornerstone.getViewport(element));
    // var ww = Math.round(viewport.voi.windowWidth);
    // var wl = Math.round(viewport.voi.windowCenter);
    var imageId = $("#" + elementId).attr('imageId');
    var idInfo = getSuid(imageId);
    var suid = idInfo.suid;
    var seLength = idInfo.seriesLength;
    var info = printStruct.findOriInfoByIds(imageId, suid);
    if (_.isUndefined(info))return;
    var sNo = printStruct.countSNo(suid);
    var wrapperBox = $("#" + elementId).parent();
    $(wrapperBox).find('.printViewportNo').remove();//移除box编号
    $(wrapperBox).find('.print-info-wwwl').text("WL/WW: " + Math.round(viewport.voi.windowCenter) + "/" + Math.round(viewport.voi.windowWidth));
    try {
        if (info) {
            var theT = info.SeriesInfo.SliceThickness.val, theL = info.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                $(wrapperBox).find('.print-TL').text('T: ' + theT + 'mm L: ' + theL + 'mm');//这个跟专业软件显示得不一样呢，这个要算吧
            }
        }
        $(wrapperBox).find('.print-info-totalNo').text('Im: ' + idInfo.imgIndex + '/' + seLength);
        $(wrapperBox).find('.print-info-SeNo').text('Se: ' + sNo);
        if (!dvStruct.share)//分享状态时不显示病人姓名
        {
            $(wrapperBox).find('.print-info-PatientName').text(info.PatientInfo.PatientName.val);//sj change
        }
        // $(wrapperBox).find('.print-info-PatientName').text(info.PatientInfo.PatientName.val);//sj change
        $(wrapperBox).find('.print-info-PatientID').text(info.PatientInfo.PatientID.val);
        $(wrapperBox).find('.print-info-PatientSex').text(' ' + info.PatientInfo.PatientSex.val);
        $(wrapperBox).find('.print-info-PatientAge').text(' ' + info.PatientInfo.PatientsAge.val);
        if (birth) {
            var birth = info.PatientInfo.PatientBirthDate.val;
            $(wrapperBox).find('.print-info-PatientBirthDate').text(birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2));
        }
        if (!dvStruct.share)//分享状态时不显示医院名称
        {
            $(wrapperBox).find('.print-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);
        }
        // $(wrapperBox).find('.print-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);
        $(wrapperBox).find('.print-info-ProtocolName').text(info.StudyInfo.ProtocolName.val);
        $(wrapperBox).find('.print-info-StudyDescription').text(info.StudyInfo.StudyDescription.val);
        if (info.SomeUsefulInfo.mA.val) {
            $(wrapperBox).find('.print-info-mA').text(info.SomeUsefulInfo.mA.val + 'mA');
        }
        if (info.SomeUsefulInfo.kvp.val) {
            $(wrapperBox).find('.print-info-kvp').text(info.SomeUsefulInfo.kvp.val + 'kV');
        }
        var backInfo = searchBackInfo(info.UIDS.InstanceUID.val);
        if (backInfo) {
            $(wrapperBox).find('.print-info-CBZ').text(backInfo.CBZ);
        }
        if (info.ImageInfo.FieldofView.val) {
            //field of view 扫描视野 0018,0094
            $(wrapperBox).find('.print-info-fov').text('FOV:' + parseFloat(info.ImageInfo.FieldofView.val).toFixed(1));
        }
        if (info.SomeUsefulInfo.MagneticFieldStrength.val)$(wrapperBox).find('.print-info-MagneticFieldStrength').text('FS: ' + info.SomeUsefulInfo.MagneticFieldStrength.val);
        if (info.SomeUsefulInfo.RepetitionTime.val || info.SomeUsefulInfo.RepetitionTime.val)$(wrapper).find('.print-info-TrTe').text('TR: ' + info.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + info.SomeUsefulInfo.EchoTime.val);
        //var date = info.InstanceInfo.ContentDate.val.toString();var time = info.InstanceInfo.ContentTime.val.toString();
        var date = info.StudyInfo.StudyDate.val.toString();
        var time = info.StudyInfo.StudyTime.val.toString();
        if (date && time) {
            $(wrapperBox).find('.print-info-datetime').text(date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2) + ' ' + time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2));
        }
        hideImgInfoOnScreenEle(wrapperBox);
    }
    catch (e) {
    }
}
/*
 * 根据信息层所在wrapperBox的宽度判断是否显示信息层，或缩放
 * */
function hideImgInfoOnScreenEle(wrapperBox) {
    var ltTextW = $(wrapperBox).find('.printOverlay-lt').width();
    var rtTextW = $(wrapperBox).find('.printOverlay-rt').width();
    var lbTextW = $(wrapperBox).find('.printOverlay-lb').width();
    var rbTextW = $(wrapperBox).find('.printOverlay-rb').width();
    var ltTextH = $(wrapperBox).find('.printOverlay-lt').height();
    var rtTextH = $(wrapperBox).find('.printOverlay-rt').height();
    var lbTextH = $(wrapperBox).find('.printOverlay-lb').height();
    var rbTextH = $(wrapperBox).find('.printOverlay-rb').height();

    var w1 = ltTextW + rtTextW;
    var w2 = lbTextW + rbTextW;
    var h1 = ltTextH + lbTextH;
    var h2 = rtTextH + rbTextH;


    var wrapW = $(wrapperBox).width();
    var wrapH = $(wrapperBox).height();

    if (wrapW < 150) {
        $(wrapperBox).find('.printOverlay').hide();
        return;
    }
    else {
        $(wrapperBox).find('.printOverlay').show();
    }

    // console.log(wrapW,wrapH);
    var fontscale = 1;
    if (w1 > wrapW || w2 > wrapW || (h1) > wrapH || (h2) > wrapH) {
        var scale = Math.min(wrapW / w1, wrapW / w2);
        fontscale = 0.9 * scale;
        var fontstr = "scale(" + fontscale + ")";
        $(wrapperBox).find('.printOverlay').css("-webkit-transform", "scale(1)");
        $(wrapperBox).find('.printOverlay').css("-webkit-transform", fontstr);

        var blank = -4 / fontscale + "px";
        var blank2 = -15 / fontscale + "px";

        var lbWW = $(wrapperBox).find('.printOverlay-lb ').width();
        var lbHH = $(wrapperBox).find('.printOverlay-lb ').height();
        var lbblankL = -(lbWW - lbWW * fontscale) * 0.5 + "px";
        var lbblankH = -(lbHH - lbHH * fontscale) * 0.5 + "px";
        $(wrapperBox).find('.printOverlay-lb ').css({"bottom": lbblankH, "left": lbblankL});

        var rtWW = $(wrapperBox).find('.printOverlay-rt ').width();
        var rtHH = $(wrapperBox).find('.printOverlay-rt ').height();
        var rtblankR = -(rtWW - rtWW * fontscale) * 0.5 + "px";
        var rtblankH = -(rtHH - rtHH * fontscale) * 0.5 + "px";
        $(wrapperBox).find('.printOverlay-rt ').css({"top": rtblankH, "right": rtblankR});

        var rbWW = $(wrapperBox).find('.printOverlay-rb ').width();
        var rbHH = $(wrapperBox).find('.printOverlay-rb ').height();
        var rbblankR = -(rbWW - rbWW * fontscale) * 0.5 + "px";
        var rbblankH = -(rbHH - rbHH * fontscale) * 0.5 + "px";
        $(wrapperBox).find('.printOverlay-rb ').css({"bottom": rbblankH, "right": rbblankR});//rtblankR

        var ltWW = $(wrapperBox).find('.printOverlay-lt ').width();
        var ltHH = $(wrapperBox).find('.printOverlay-lt ').height();
        var ltblankL = -(ltWW - ltWW * fontscale) * 0.5 + "px";
        var ltblankH = -(ltHH - ltHH * fontscale) * 0.5 + "px";
        $(wrapperBox).find('.printOverlay-lt ').css({"top": ltblankH, "left": ltblankL});
    }
    else {

    }

}

/*
 * 根据信息层所在wrapperBox的宽度判断是否显示信息层，或缩放
 * //信息缩放（所有）计算偏移位置
 * */
function hideImgInfoOnScreen() {
    var ltTextW = $('.printOverlay-lt').width();
    var rtTextW = $('.printOverlay-rt').width();
    var lbTextW = $('.printOverlay-lb').width();
    var rbTextW = $('.printOverlay-rb').width();

    var ltTextH = $('.printOverlay-lt').height();
    var rtTextH = $('.printOverlay-rt').height();
    var lbTextH = $('.printOverlay-lb').height();
    var rbTextH = $('.printOverlay-rb').height();

    var w1 = ltTextW + rtTextW;
    var w2 = lbTextW + rbTextW;
    var h1 = ltTextH + lbTextH;
    var h2 = rtTextH + rbTextH;


    var wrapW = $('.printWrapper').width();
    var wrapH = $('.printWrapper').height();

    if (wrapW < 180) {
        $('.printOverlay').hide();
        return;
    }
    else {
        $('.printOverlay').show();
        // console.log(wrapW,wrapH);
        var fontscale = 1;
        if (w1 > wrapW || w2 > wrapW || (h1) > wrapH || (h2) > wrapH) {

            var scale = Math.min(wrapW / w1, wrapW / w2);
            fontscale = 0.9 * scale;

            var fontstr = "scale(" + fontscale + ")";
            $('.printOverlay').css("-webkit-transform", "scale(1)");
            $('.printOverlay').css("-webkit-transform", fontstr);
            // -webkit-transform-origin: 0 0;

            var blank = -4 / fontscale + "px";
            var blank2 = -15 / fontscale + "px";

            var ltWW = $('.printOverlay-lt ').width();
            var ltHH = $('.printOverlay-lt ').height();
            var ltblankL = -(ltWW - ltWW * fontscale) * 0.5 + "px";
            var ltblankH = -(ltHH - ltHH * fontscale) * 0.5 + "px";
            $('.printOverlay-lt ').css({"top": ltblankH, "left": ltblankL});

            var lbWW = $('.printOverlay-lb ').width();
            var lbHH = $('.printOverlay-lb ').height();
            var lbblankL = -(lbWW - lbWW * fontscale) * 0.5 + "px";
            var lbblankH = -(lbHH - lbHH * fontscale) * 0.5 + "px";

            $('.printOverlay-lb ').css({"bottom": lbblankH, "left": lbblankL});


            var rtWW = $('.printOverlay-rt ').width();
            var rtHH = $('.printOverlay-rt ').height();
            var rtblankR = -(rtWW - rtWW * fontscale) * 0.5 + "px";
            var rtblankH = -(rtHH - rtHH * fontscale) * 0.5 + "px";
            $('.printOverlay-rt ').css({"top": rtblankH, "right": rtblankR});


            var rbWW = $('.printOverlay-rb ').width();
            var rbHH = $('.printOverlay-rb ').height();
            var rbblankR = -(rbWW - rbWW * fontscale) * 0.5 + "px";
            var rbblankH = -(rbHH - rbHH * fontscale) * 0.5 + "px";
            $('.printOverlay-rb ').css({"bottom": rbblankH, "right": rbblankR});//rtblankR
        }
        else {
            // console.log("放大放大");
            // $('.printOverlay').show();
            var fontscale = 1;
            //  if( w1*3<  wrapW||w2*3<wrapW) {
            //暂时没想到计算出放大的比例的合适方法
            if (false) {
                // console.log("放大放大2");
                var scale = Math.min(wrapW / w1, wrapW / w2);
                // fontscale = 0.5 * scale;
                fontscale = 1;

                var fontstr = "scale(" + fontscale + ")";
                $('.printOverlay').css("-webkit-transform", "scale(1)");
                $('.printOverlay').css("-webkit-transform", fontstr);
                var blank = -4 / fontscale + "px";
                var blank2 = -15 / fontscale + "px";
                var ltWW = $('.printOverlay-lt ').width();
                var ltHH = $('.printOverlay-lt ').height();
                var ltblankL = -(ltWW - ltWW * fontscale) * 0.5 + "px";
                var ltblankH = -(ltHH - ltHH * fontscale) * 0.5 + "px";
                $('.printOverlay-lt ').css({"top": ltblankH, "left": ltblankL});

                var lbWW = $('.printOverlay-lb ').width();
                var lbHH = $('.printOverlay-lb ').height();
                var lbblankL = -(lbWW - lbWW * fontscale) * 0.5 + "px";
                var lbblankH = -(lbHH - lbHH * fontscale) * 0.5 + "px";

                $('.printOverlay-lb ').css({"bottom": lbblankH, "left": lbblankL});


                var rtWW = $('.printOverlay-rt ').width();
                var rtHH = $('.printOverlay-rt ').height();
                var rtblankR = -(rtWW - rtWW * fontscale) * 0.5 + "px";
                var rtblankH = -(rtHH - rtHH * fontscale) * 0.5 + "px";
                $('.printOverlay-rt ').css({"top": rtblankH, "right": rtblankR});


                var rbWW = $('.printOverlay-rb ').width();
                var rbHH = $('.printOverlay-rb ').height();
                var rbblankR = -(rbWW - rbWW * fontscale) * 0.5 + "px";
                var rbblankH = -(rbHH - rbHH * fontscale) * 0.5 + "px";
                $('.printOverlay-rb ').css({"bottom": rbblankH, "right": rtblankR});
            }
        }

    }
}

/**
 * Created by SongJing on 2017/3/28.
 * 布局变换响应
 * 胶片打印页面
 * 主影像页面
 */


/*
 * //删除图像后全部重新按布局加载//
 * 重新布局后的操作同步//
 * 合并以子分格的方式
 * */
function layoutSyn(row, col) {

    //移除原来的page
    $('.printPage').each(function (k, val) {
        if ($(this).attr('id') == "page0") {

        }
        else {
            $(this).remove();
        }
    });

    var imgTotal = printStruct.viewportArr.imageId.length;
    var filmTotal = Math.ceil(imgTotal / ( row * col));
    if (filmTotal == 0) {
        filmTotal = 1;
        printStruct.printpage.pageIndex = 1;//当前是第几页
        $('.currentPageIndex').val(printStruct.printpage.pageIndex);
        showPrintPage(printStruct.printpage.pageIndex);
    }

    var paperDirect = $('.paperDirection').val();
    var paperType = $('#paperSize').val();

    insertprintPage("page0", filmTotal, row, col, paperType, paperDirect);
    //整理前要重新赋值总页数
    printStruct.printpage.pagetotal = filmTotal;
    $('.totalImgNo').text(printStruct.printpage.pagetotal);
    orderPageId();//重新对pageID进行整理

    if (printStruct.viewportArr.viewport.length > 0) {
        console.log("回填图像================");
        var viewportfillInID = $("div[imgIn=false]").attr('id');
        for (var i = 0,len=printStruct.viewportArr.viewport.length; i <len; i++) {
            var viewport = printStruct.viewportArr.viewport[i];
            var imageId = printStruct.viewportArr.imageId[i];
            var seNo = printStruct.viewportArr.seNo[i];
            if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                $("div[imgIn=false]").parents('.printPage').show();
            }
            fillImageSyn(viewportfillInID, imageId, seNo, viewport);
            fillInfoOnLay(viewportfillInID);
            $("#" + viewportfillInID).attr('imgIn', "true");//添加行列属性
            $("#" + viewportfillInID).attr('imageid', imageId);
            $("#" + viewportfillInID).attr('seNo', seNo);//添加合并方式属性

            viewportfillInID = $("div[imgIn=false]").attr('id');
        }
    }
  

    clearImgRecord();
    removeInnerboxNo();//移除组合图像的格子编号
 
}

/*
 * 主页面顶部工具栏滚动条 scrollx
 * 当页面宽度小于按钮总宽度时显示滚动条
 * 不知道什么原因必须要赋值一次才显示，不然，呵呵呵了
 * */
function topScrollX() {
    var innerW = 0;
    $('.tool_btn').each(function () {
        // innerW+=$(this).width();
        innerW += $(this).parent().outerWidth(true);

    });

    innerW += $('.tool_window').width();
    $('#top_tool').width(innerW);
}
/*
 * 根据图像窗口中的图像进行按钮的显示检查
 * 图像窗口中的按钮有同步按钮 MPR 3D 三个按钮
 * */
function btnShowCheck() {
    $('.seriesWindow').each(function () {
        var seriesIndex = parseInt($(this).find('.js-info-SeNo').text().slice(4)) - 1;
        var seriesLength = parseInt($(this).find('.js-info-totalNo').text().slice(1));
        //同步按钮显示检查
        var studyType = $(this).find('.js-info-Modality').text();
        console.log(studyType);

        if (studyType.toLowerCase().indexOf("ct")>=0 ){
            $(this).find('.js-lungAI').show();
        }
        else{
            $(this).find('.js-lungAI').hide();
        }
        
        if (seriesLength > 1) {
            $(this).attr('seriesLength', seriesLength);
            $(this).attr('seriesIndex', seriesIndex);
            $(this).find('.js-syn').show();

        }
        else {
            $(this).find('.js-syn').hide();
            $(this).attr('seriesLength', 0);
            $(this).attr('seriesIndex', -1);
        }
        //vr mpr 按钮显示提示
        if (seriesLength > 5) {
            if (studyType.toLowerCase().indexOf("ct")>=0 || studyType.toLowerCase().indexOf("mr")>=0 ) {
                $(this).find('.js-VR').show();
                $(this).attr('vr', true);
            }
            else {
                $(this).find('.js-VR').hide();
                $(this).attr('vr', false);
            }
            $(this).find('.js-mpr').show();
        }
        else {
            $(this).find('.js-mpr').hide();
            $(this).find('.js-VR').hide();

            $(this).attr('vr', false);
        }
    });
}

/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面双击单个图像放大
 */
//双击图像放大处理
function bindMagnifydblClick() {
    var synchronizerWWWC = new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.wwwcSynchronizer);//调窗同步
    var measureDivId = "imgMagnifyDiv";
    var imageId;
    var seNo;
    var targetCanvId;

    /*
     * 双击图像弹出放大框
     * */
    $(document).dblclick(function (e) {
        var dblClickCss = $(e.target).parent().attr('class');
        var dblClickId = $(e.target).parent().attr('id');
        var dblClickCss2 = $(e.target).parent().attr('class');
        if ($(e.target).parent('.printViewport').attr('imgIn') == "true" && printStruct.drag.dragFlag === false) {
            targetCanvId = dblClickId;
            imageId = $(e.target).parent().attr('imageId');
            seNo = $(e.target).parent().attr('seNo');
            show($('.magnifyBox'));
            fillImageKeep(targetCanvId, "imgMagnifyDiv", imageId, seNo);
        }
    });

    var config = {
        getTextCallback: getTextCallback,
        changeTextCallback: changeTextCallback,
        drawHandles: false,
        drawHandlesOnHover: true,
        arrowFirst: true
    };
    /*
     * 直线测量
     * */
    $("#printLine").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);
        cornerstoneTools.length.activate(element, 1);
        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstoneTools.length.activate(element2, 1);

        synchronizerWWWC.remove(element);
        synchronizerWWWC.remove(element2);

    });
    /*
     * 剪头标识
     * */
    $("#printArrows").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);
        cornerstoneTools.arrowAnnotate.setConfiguration(config);
        cornerstoneTools.arrowAnnotate.activate(element, 1);
        cornerstoneTools.arrowAnnotateTouch.activate(element);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstoneTools.arrowAnnotate.activate(element2, 1);
        cornerstoneTools.arrowAnnotateTouch.activate(element2);

        synchronizerWWWC.remove(element);
        synchronizerWWWC.remove(element2);

    });
    /*
     * 矩形测量
     * */
    $("#printRect").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);
        cornerstoneTools.rectangleRoi.activate(element, 1);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstoneTools.rectangleRoi.activate(element2, 1);

        synchronizerWWWC.remove(element);
        synchronizerWWWC.remove(element2);
    });
    /*
     * 椭圆测量
     * */
    $("#printEllipse").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);
        cornerstoneTools.ellipticalRoi.activate(element, 1);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstoneTools.ellipticalRoi.activate(element2, 1);

        synchronizerWWWC.remove(element);
        synchronizerWWWC.remove(element2);
    });
    /*
     * 角度测量
     * */
    $("#printAngle").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);
        cornerstoneTools.angle.activate(element, 1);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstoneTools.angle.activate(element2, 1);


        synchronizerWWWC.remove(element);
        synchronizerWWWC.remove(element2);
    });
    /*
     * 调窗
     * */
    $("#printWWWLmagnify").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);

        cornerstoneTools.mouseInput.enable(element);
        cornerstoneTools.mouseWheelInput.enable(element);
        cornerstoneTools.wwwc.activate(element, 1);//只是把该操作使能了，但没有同步更新

        cornerstoneTools.mouseInput.enable(element2);
        cornerstoneTools.mouseWheelInput.enable(element2);
        cornerstoneTools.wwwc.activate(element2, 1);//只是把该操作使能了，但没有同步更新
        synchronizerWWWC.add(element);
        synchronizerWWWC.add(element2);
    });
    /*
     * 重置
     * */
    $("#printResetmagnify").click(function () {
        closeAllToolsP(measureDivId);
        var element = $("#" + measureDivId).get(0);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        var element2 = $("#" + targetCanvId).get(0);
        cornerstone.reset(element);
        cornerstone.reset(element2);
    });
    /*
     * 清除测量
     * */
    $("#printClear").click(function () {
        closeAllToolsP(measureDivId);
        clearAllMeasureP(measureDivId);

        //原图像同步操作
        closeAllToolsP(targetCanvId);
        clearAllMeasureP(targetCanvId);

    });
    /*
     * 关闭放大弹出框
     * */
    $("#closeMagnifyBox").click(function () {

        closeAllToolsP(targetCanvId);
        closeAllToolsP(measureDivId);
        cancel($('.magnifyBox'));
        var imageId = $("#" + targetCanvId).attr('imageId');
        // setEleInfo(imageId,targetCanvId);//绘制信息
        // fillImgInfoOnScreen(targetCanvId);
    });
}

/*
 * elementId 关闭所有测绘开关
 * */
function closeAllToolsP(elementId) {
    var element = $("#" + elementId).get(0);
    if ($("#" + elementId).attr('imgIn') == "true") {

        cornerstoneTools.length.deactivate(element, 1);
        cornerstoneTools.ellipticalRoi.deactivate(element, 1);
        cornerstoneTools.rectangleRoi.deactivate(element, 1);
        cornerstoneTools.angle.deactivate(element, 1);
        cornerstoneTools.arrowAnnotate.deactivate(element, 1);
        cornerstoneTools.arrowAnnotateTouch.deactivate(element, 1);
        cornerstoneTools.wwwc.deactivate(element, 1);
    }
}

/*
 * 清除elementId所有测量
 * */
function clearAllMeasureP(elementId) {
    var imageId = $("#" + elementId).attr("imageId");
    var seNo = $("#" + elementId).attr("seNo");
    fillImage("imgMagnifyDiv", imageId, seNo);
    var element = $("#" + elementId).get(0);
    if ($("#" + elementId).attr('imgIn') == "true") {
        
        cornerstoneTools.clearToolState(element, "length");
        cornerstoneTools.clearToolState(element, "rectangleRoi");
        cornerstoneTools.clearToolState(element, "ellipticalRoi");
        cornerstoneTools.clearToolState(element, "angle");
        cornerstoneTools.arrowAnnotate.disable(element);
        cornerstoneTools.arrowAnnotateTouch.disable(element);
        cornerstoneTools.clearToolState(element, "arrowAnnotate");
    }
}
//textbox
function getTextCallback(doneChangingTextCallback) {
    var dialog = $('.annotationDialog');
    var getTextInput = dialog.find('.annotationTextInput');
    var confirm = dialog.find('.annotationDialogConfirm');

    dialog.get(0).showModal();

    confirm.off('click');
    confirm.on('click', function () {
        closeHandler();
    });

    dialog.off("keydown");
    dialog.on('keydown', keyPressHandler);

    function keyPressHandler(e) {
        // If Enter is pressed, close the dialog
        if (e.which === 13) {
            closeHandler();
        }
    }

    function closeHandler() {
        dialog.get(0).close();
        doneChangingTextCallback(getTextInput.val());
        // Reset the text value
        getTextInput.val("");
    }
}

// Define a callback to edit your text annotation
// This could be used, e.g. to open a modal
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    var dialog = $('.relabelDialog');
    var getTextInput = dialog.find('.annotationTextInput');
    var confirm = dialog.find('.relabelConfirm');
    var remove = dialog.find('.relabelRemove');

    getTextInput.val(data.annotationText);
    dialog.get(0).showModal();

    confirm.off('click');
    confirm.on('click', function () {
        dialog.get(0).close();
        doneChangingTextCallback(data, getTextInput.val());
    });

    // If the remove button is clicked, delete this marker
    remove.off('click');
    remove.on('click', function () {
        dialog.get(0).close();
        doneChangingTextCallback(data, undefined, true);
    });

    dialog.off("keydown");
    dialog.on('keydown', keyPressHandler);

    function keyPressHandler(e) {
        // If Enter is pressed, close the dialog
        if (e.which === 13) {
            closeHandler();
        }
    }

    function closeHandler() {
        dialog.get(0).close();
        doneChangingTextCallback(data, getTextInput.val());
        // Reset the text value
        getTextInput.val("");
    }

}
/**
 * Created by SongJing on 2017/3/28.
 * 遮罩层
 */
//打印遮罩层
var printMask={};
printMask.mask = {
    getMask:(function(){
        var maskDiv;
        return function(){
            return maskDiv||(function(){
                    $(document.body).append('<div id="printMask"  ></div>');
                    return maskDiv = document.getElementById('printMask');
                })();
        };
    })(),
    show:function(){
        console.log("showMask=============================");
        var mask = this.getMask();
        $(mask).show();
    },
    hide:function(){
        console.log("hideMask=============================");
        var mask = this.getMask();
        $(mask).hide();
    }
};



//三层弹出框cancel
function threeCancel(div) {
    div.hide();
    $('.setMask').hide();
}
//三层弹出框show
function threeShow(div) {
    div.show();
    $('.setMask').show();
}

/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的图像合并与拆分操作的相关方法
 */
if (!printStruct) {
    var printStruct = {};
}
 


/*
* 将imgbox拆分为内置多个子格的形式
* 合并操作
* */
function imgBoxBreakUp(mergeType) {
    var mergeImgcount = 0;//最多几张图参与合并
    var colInner;
    var rowInner;
    switch (mergeType) {
        case "1":
            rowInner = 2;
            colInner = 1;
            mergeImgcount = 2;
            break;
        case "2":
            rowInner = 1;
            colInner = 2;
            mergeImgcount = 2;
            break;
        //特殊样式1
        case "3":
            rowInner = 2;
            colInner = 2;
            mergeImgcount = 3;
            break;
        //特殊样式2
        case "4":
            rowInner = 2;
            colInner = 2;
            mergeImgcount = 3;
            break;
        case "5":
            rowInner = 2;
            colInner = 2;
            mergeImgcount = 4;
            break;
        case "6":
            rowInner = 3;
            colInner = 2;
            mergeImgcount = 6;
            break;
        case "7":
            rowInner = 2;
            colInner = 3;
            mergeImgcount = 6;
            break;
        case "8":
            rowInner = 3;
            colInner = 3;
            mergeImgcount = 9;
            break;
        default:
            break;
    }


    if (mergeImgcount === 0) {
        console.log("请选中正确的拆分方式");
        return;
    }
    else {
        // console.log("blankBox:========3========="+blankBox);
        if(blankBox==true){

        }
        else{//当前box中有图像，则要记录从当前位置到最后位置的图像
            // console.log("当前box中有图像，则要记录从当前位置到最后位置的图像-------------------");

            $('.printViewport').each(function (index,val) {
                var elementId= $(this).attr('id');
                var element = $("#" + elementId).get(0);
                if ($(this).attr('imgIn')=="true") {//确保box中有图
                    printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                    printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                    var viewport = deepCopy1(cornerstone.getViewport(element));
                    printStruct.viewportArr.viewport.push(viewport);
                    cornerstone.disable(element);
                    $(this).attr('imageId',"");
                    $(this).attr('seNo',"");
                    $(this).attr('imgIn',"false");
                }
            });
        }

        //拆分单元格
        $('.imgBoxSelected').each(function(k,val){

            var wrapDom=$(this);
            var viewportfillInID=$(this).children('.printViewport').attr('id');
            wrapDom.empty();//清空
            $(this).attr('multiRow', rowInner);//添加行列属性
            $(this).attr('multiCol', colInner);
            $(this).attr('breakType',mergeType);//添加合并方式属性
            $(this).addClass('multiImg');//要参与合并的图像添加groupState类

            var width =  $(this).width();
            var height =  $(this).height();
            // var innerW = (width) / colInner ;
            // var innerH = (height) / rowInner ;
            var scaleW=(100/colInner)+'%';
            var scaleH=(100/rowInner)+'%';

            var imgIndexID;
            if(mergeType=="3"){
                for (var m = 0; m < 3; m++) {
                    imgIndexID = viewportfillInID + "_" + (m );
                    if(m==0){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT1 printViewport innerBoxBorder' style='width: 100%;height: 50%'  ></div>";

                    }
                    else if(m==1){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT2 printViewport innerBoxBorder' style='width: 50%;height: 50%' ></div>";

                    }
                    else if(m==2){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT4 printViewport innerBoxBorder' style='width: 50%;height: 50%' ></div>";

                    }

                    wrapDom.append(innerViewport);
                    addInfoLay(imgIndexID);
                    addBoxNoLay(imgIndexID);
                }
            }
            else if(mergeType=="4"){
                for (var m = 0; m < 3; m++) {
                    imgIndexID = viewportfillInID + "_" + (m );
                    if(m=='0'){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT1 printViewport innerBoxBorder' style='width:50%;height: 100%' ></div>";

                    }
                    else if(m=='1'){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT3 printViewport innerBoxBorder' style='width: 50%;height: 50%'  ></div>";

                    }
                    else if(m=='2'){
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m ) + "'  imgIn='false' class='multiViewport multiMergeT4 printViewport innerBoxBorder' style='width: 50%;height: 50%' ></div>";

                    }
                    wrapDom.append(innerViewport);
                    addInfoLay(imgIndexID);
                    addBoxNoLay(imgIndexID);
                }

            }
            else{
                for (var m = 0; m < rowInner; m++) {
                    for (var n = 0; n < colInner; n++) {
                        imgIndexID = viewportfillInID + "_" + (m * colInner + n);
                        var innerViewport = "<div id='" + imgIndexID + "'" + "  No='" + (m * (colInner) + n) + "' imgIn='false' class='multiViewport printViewport innerBoxBorder' style='width:"+scaleW+";height: "+scaleH+";' ></div>";

                        wrapDom.append(innerViewport);

                        addInfoLay(imgIndexID);
                        addBoxNoLay(imgIndexID);
                    }
                }
            }


        });



//回填图像
        if(printStruct.viewportArr.viewport.length>0){
            console.log("回填图像================");
            var ImgTotal =printStruct.viewportArr.imageId.length;
            var fillCount = 0;

            var  viewportfillInID = $("div[imgIn=false]").attr('id');

            while(fillCount <ImgTotal){
                while (viewportfillInID !== undefined && fillCount < ImgTotal) {
                    var viewport = printStruct.viewportArr.viewport[fillCount];
                    var imageId = printStruct.viewportArr.imageId[fillCount];
                    var seNo = printStruct.viewportArr.seNo[fillCount];
                    if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                        $("div[imgIn=false]").parents('.printPage').show();
                    }
                    // console.log("====");
                    fillImageSyn(viewportfillInID, imageId, seNo, viewport);
                    fillInfoOnLay(viewportfillInID);
                    viewportfillInID = $("div[imgIn=false]").attr('id');

                    fillCount++;//记录绘制的图像数
                    if (fillCount < ImgTotal&&viewportfillInID==undefined) {
                        // console.log("添加相同布局的新页====================");
                        var pagefillInID="page"+ printStruct.printpage.pagetotal;
                        pagefillInID=addSameLayoutPage(pagefillInID);//添加相同布局的新页
                        viewportfillInID = $("div[imgIn=false]").attr('id');
                    }
                }
            }
        }

    }

}



/*
* 取消将imgbox拆分为内置多个子格（只处理选中的第一个）
* 拆分操作
* */
function imgBoxCancleBreakUp() {
    var wrapperDom=$('.imgBoxSelected').first();
    var portId=wrapperDom.children('.printViewport').attr("id");

    if($("#"+portId).attr('imgIn')=="true"){
        blankBox=false;

        $('.printViewport').each(function (index,val) {
            var elementId= $(this).attr('id');
            var element = $("#" + elementId).get(0);
            if ($(this).attr('imgIn')=="true") {//确保box中有图


                printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                var viewport = deepCopy1(cornerstone.getViewport(element));
                printStruct.viewportArr.viewport.push(viewport);
                cornerstone.disable(element);
                $(this).attr('imageId',"");
                $(this).attr('seNo',"");
                $(this).attr('imgIn',"false");

            }
        });
    }

    var strart=portId.indexOf("_");
    var imgIndexID=portId.substring(0,strart);

    // console.log("imgIndexID:"+imgIndexID);
    var strat2=portId.indexOf("img");
    var viewportNo=parseInt(portId.substring(strat2+3,strart))+1;
    // console.log("No:"+No);

    wrapperDom.removeAttr('multirow');
    wrapperDom.removeAttr('multicol');
    wrapperDom.removeAttr('breaktype');
    wrapperDom.removeClass('multiImg');
    wrapperDom.empty();
    var singleViewportHtml="<div id='" + imgIndexID + "'" +
        "  No='" + viewportNo + "' imgIn='false'  class='singleViewport printViewport'></div>";
    wrapperDom.append(singleViewportHtml);

    addInfoLay(imgIndexID);
    addBoxNoLay(imgIndexID);


    //    回填图像
    if(printStruct.viewportArr.viewport.length>0){
       console.log("回填图像================");
        var  viewportfillInID = $("div[imgIn=false]").attr('id');
        for(var i=0,len=printStruct.viewportArr.viewport.length;i<len;i++){
            var viewport = printStruct.viewportArr.viewport[i];
            var imageId = printStruct.viewportArr.imageId[i];
            var seNo = printStruct.viewportArr.seNo[i];
            if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                $("div[imgIn=false]").parents('.printPage').show();
            }
            fillImageSyn(viewportfillInID, imageId, seNo, viewport);
            fillInfoOnLay(viewportfillInID);

            $("#" + viewportfillInID).attr('imgIn', "true");//添加行列属性
            $("#" + viewportfillInID).attr('imageid', imageId);
            $("#" + viewportfillInID).attr('seNo',seNo);//添加合并方式属性

            viewportfillInID=$("div[imgIn=false]").attr('id');
        }


        pageClear();//空白 页清理
        showPrintPage(printStruct.printpage.pageIndex);
        describe();

    }

    clearSelecImgBoxCss();
    clearSelecImgViewportCss();
}
/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的多选操作
 */

//shift 图像多选
function multiSelected(procType) {
    var firstId = $('.imgViewportSelected').first().attr('id');
    var lastId = $('.imgViewportSelected').last().attr('id');
    var startIndex = firstId.substring(firstId.indexOf("img") + 3, firstId.length);
    var endIndex = lastId.substring(lastId.indexOf("img") + 3, lastId.length);
    // console.log(startIndex,endIndex);
    var title = firstId.substring(0, firstId.indexOf("img") + 3);
    while (parseInt(startIndex) <= parseInt(endIndex)) {
        var elementId = title + startIndex;
        //有无图像都可以多选
        if ($("#" + elementId).length > 0) {
            // console.log("===:", $("#" + elementId).attr('id'));
            $("#" + elementId).parents('.printWrapper').addClass('imgBoxSelected');
            $("#" + elementId).addClass("imgViewportSelected");
        }
        else if ($("#" + elementId).length == 0) {
            elementId = elementId + "_";
            $("div[id^=" + elementId + "]").each(function (k, val) {
                // console.log("xxx:",  $(this).attr('id'));
                $(this).addClass("imgViewportSelected");
            });
            $("div[id^=" + elementId + "_]").parents('.printWrapper').addClass('imgBoxSelected');
        }
        // 其实有个隐藏的bug
        /*
         * 10_1 10_2
         * 10_1* 10_2*
         *
         *
         * */
        startIndex++;
    }
    openProcEnable(procType);
}
//shift 左侧缩略图多选
function multiSelecLeftbox() {
    var firstId = $('.imgLiSelected').first().attr('id');
    var lastId = $('.imgLiSelected').last().attr('id');
    console.log(firstId, lastId);
    var elementId = firstId;
    while (elementId != lastId) {
        $("#" + elementId).addClass('imgLiSelected');
        elementId = $("#" + elementId).next().attr('id');
    }
}
/**
 * Created by SongJing on 2017/3/28.
 * 胶片打印页面的一些公用方法
 */
if (!dvStruct) {
    var dvStruct = {};
}
if (!printStruct) {
    var printStruct = {};
}


dvStruct.seriesArr;//整个打印页面用的数据来源就是主影像页面的数据
printStruct.viewportArr = {

    imageId: [],
    seNo: [],
    viewport: []

};

printStruct.findOriInfoOnlyByOriId = function (imageId) {
    for (var i = 0,len=dvStruct.seriesArr.length; i < len; i++) {
        var s = dvStruct.seriesArr[i];
        if (!_.isUndefined(s)) {
            var arr = s.dicomArr;
            var re = _.find(arr, function (o) {
                return o.imageId == imageId;
            });
            if (!_.isUndefined(re)) {
                return re.infoSet
            }
        }
    }
    return undefined;
};
printStruct.findOriInfoByIds = function (imageId, suid) {
    var s = dvStruct.findSeries(suid);
    if (!_.isUndefined(s)) {
        var arr = s.dicomArr;
        var re = _.find(arr, function (o) {
            return o.imageId == imageId;
        });
        if (!_.isUndefined(re)) {
            return re.infoSet
        }
    }
    return undefined;
};
printStruct.countSNo = function (seriesUid) {
    var No = 0;
    var re = _.find(dvStruct.seriesArr, function (o) {
        No++;
        return o.suid == seriesUid;
    });
    return No;
};


//获取图像序列号
function getSuid(imageId) {
    // console.log(imageId);
    var imgIdObj = {
        imgId: imageId,
        suid: 0,
        seriesLength: 0,//所属序列总共有多少张
        se: 0,//序列排序的序号
        imgIndex: 0//表示是序列中的第几张
    };
    $.each(dvStruct.seriesArr, function (i) {
        var reFlag = false;
        $.each(dvStruct.seriesArr[i].dicomArr, function (j) {
            if (dvStruct.seriesArr[i].dicomArr[j].imageId === imageId) {
                imgIdObj.suid = dvStruct.seriesArr[i].suid; //从dvStruct.seriesArr中找到匹配的序列号
                imgIdObj.se = printStruct.countSNo(dvStruct.seriesArr[i].suid);
                imgIdObj.seriesLength = dvStruct.seriesArr[i].dicomArr.length;
                imgIdObj.imgIndex = j + 1;

                reFlag = true;

            }
        });
        if (reFlag == true) {

        }
    });
    return imgIdObj;

}

//获取窗口的ww wl
function getwwwlofViewport(elementId) {
    var obj = {
        ww: null,
        wl: null
    };
    if ($("#" + elementId).attr('imgIn') == "true") {
        var element = $("#" + elementId).get(0);
        var viewport = deepCopy1(cornerstone.getViewport(element));
        obj.ww = Math.round(viewport.voi.windowWidth);
        obj.wl = Math.round(viewport.voi.windowCenter);
        return obj;
    }
    else {
        return undefined;
    }
}
/*
 * 获取所选纸张类型对应的 像素W H
 * */
function getprinPaperPixel(printSetObj) {
    var paperSize = {
        width: 0,
        height: 0
    };

    switch (printSetObj.paperType) {
        case "A4":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 794;
                paperSize.height = 1123;
            }
            else {
                paperSize.width = 1123;
                paperSize.height = 794;
            }
            break;
        case "A3":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 1123;
                paperSize.height = 1588;
            }
            else {
                paperSize.width = 1588;
                paperSize.height = 1123;
            }
            break;
        case "8INX10IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 768;
                paperSize.height = 960;
            }
            else {
                paperSize.width = 960;
                paperSize.height = 768;
            }
            break;
        case "8_5INX11IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 816;
                paperSize.height = 1056;
            }
            else {
                paperSize.width = 1056;
                paperSize.height = 816;
            }
            break;
        case "10INX12IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 960;
                paperSize.height = 1152;
            }
            else {
                paperSize.width = 1152;
                paperSize.height = 960;
            }
            break;
        case "10INX14IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 960;
                paperSize.height = 1344;
            }
            else {
                paperSize.width = 1344;
                paperSize.height = 960;
            }
            break;
        case "11INX14IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 1056;
                paperSize.height = 1344;
            }
            else {
                paperSize.width = 1344;
                paperSize.height = 1056;
            }
            break;
        case "11INX17IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 1056;
                paperSize.height = 1632;
            }
            else {
                paperSize.width = 1632;
                paperSize.height = 1056;
            }
            break;
        case "14INX14IN":

            paperSize.width = 1344;
            paperSize.height = 1344;

            break;
        case "14INX17IN":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 1344;
                paperSize.height = 1632;
            }
            else {
                paperSize.width = 1632;
                paperSize.height = 1344;
            }
            break;
        case "24CMX24CM":

            paperSize.width = 908;
            paperSize.height = 908;

            break;
        case "24CMX30CM":
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 908;
                paperSize.height = 1134;
            }
            else {
                paperSize.width = 1134;
                paperSize.height = 908;
            }
            break;
        default:
            if (printSetObj.paperDirect == "1") {
                paperSize.width = 794;
                paperSize.height = 1123;
            }
            else {
                paperSize.width = 1123;
                paperSize.height = 794;
            }
            break;
    }
    return paperSize;
}

//获取dcm图像的检查类型
function getModality() {
    console.log(dvStruct.seriesArr);
    if (dvStruct.seriesArr[0].dicomArr.length > 0) {
        Modality = dvStruct.seriesArr[0].dicomArr[0].infoSet.SeriesInfo.Modality.val;
    }
}

//关闭打印界面
function closePrintMain() {
    emptyImgData();
    cancel($('.main'));
    // printMask.mask.hide();

}

//关闭弹出框
function cancel(div) {   
    div.hide();
    $('.printMask').hide();
}

//打开弹出框
function show(div) {
    div.show();
    $('.printMask').show();
}
 


/**
 * Created by Administrator on 2016/12/7.
 * 打印页面的操作响应
 */
//响应打印页面的操作
$(function () {


    bindPrintDrag();//图像拖动
    

    /*
     * 鼠标样式
     * */
    $(document).on('mouseenter', '.printViewport canvas', function () {
        if ($('.magnify').hasClass("activeBtn")) {
            $(this).parent().css({cursor:"zoom-in"});
        }
        if ($('.move').hasClass("activeBtn")) {
            $(this).parent().css({cursor:"move"});
        }
        if ($('.rotateMin').hasClass("activeBtn")) {
            $(this).parent().css({cursor:"-webkit-grab"});
        }
        if ($('.wwwl').hasClass("activeBtn")) {
            // $(this).parent().css({cursor:"not-allowed"});
           $(this).parent().css({cursor:"url(ipacsdv/css/img/pointer/wwwl.cur),auto"});
        }
    });
    $(document).on('mouseleave', '.printViewport canvas', function () {

        $(this).parent().css({cursor: "default"});
    });

    /*
     * 默认右键调窗
     * */
    $(document).on('mousemove', '.printViewport canvas', function (e) {
        if (3 == e.which) {
            printStruct.procType2 = "wwwc";
            emptyBaseImgCss();
            if ($(e.target).parents('.printViewport').hasClass('imgViewportSelected') &&
                (printStruct.procType2 != "null" && printStruct.procType2 != undefined)) {
                $(e.target).parents('.printViewport').addClass("procHandle");//procHandle 图像操作同步时的基窗口标志
                openProcEnable(printStruct.procType2);
            }
            else {
                clearSelecImgBoxCss();
                clearSelecImgViewportCss();
            }
            $(e.target).parents('.printWrapper').addClass("imgBoxSelected");
            $(e.target).parents('.printViewport').addClass("imgViewportSelected");

            printStruct.procType2 = "wwwc";
            mainProcess(printStruct.procObj, printStruct.procType);
            allowWwwlMouseR();
            $(this).parent().css({cursor: "url(ipacsdv/css/img/pointer/wwwl.cur),auto"});
        }
    });
    $(document).on('mouseup', '.printViewport canvas', function (e) {
        if (3 == e.which) {
            $(this).parent().css({cursor: "default"});
        }

    });

  /*  $(document).on("mousedown",'.imgLi',function(){
        console.log(".mousedown............d........");
    });*/

    /*
     *胶片布局切换
     * */
    $('.filmLayout').on('click', function () {
        show($('.layoutBox'));
    });

    /*
     * 增加一页胶片到最后
     * */
    $(document).on('click', '#addPage', function () {

        printStruct.printpage.pagetotal = printStruct.printpage.pagetotal + 1;
        $('.totalImgNo').text(printStruct.printpage.pagetotal);
        var direct = $('.paperDirection').val();
        var type = $('#paperSize').val();

        addprintPage(direct, type);

        printStruct.printpage.pageIndex = printStruct.printpage.pagetotal;
        showPrintPage(printStruct.printpage.pageIndex);//增加后自动显示增加的那页

        // console.log(printStruct.printpage.pageIndex, printStruct.printpage.pagetotal);

        $('.currentPageIndex').val(printStruct.printpage.pageIndex);
        orderPageId();
        describe();

    });
    /*
     * 删除当前胶片页面
     * */
    $(document).on('click', '#deletePage', function () {

        // console.log("delete  page");
        printStruct.printpage.pageIndex = $('.currentPageIndex').val();
        deleteprintPage(printStruct.printpage.pageIndex);

        //始终要有一页面
        if (printStruct.printpage.pagetotal == 0) {
            initPage();
        }

        describe();

    });
    /*
     * 转到第一页胶片
     * */
    $(document).on('click', '#firstPage', function () {

        if (printStruct.printpage.pagetotal >= 1) {
            printStruct.printpage.pageIndex = 1;

            $('.currentPageIndex').val(printStruct.printpage.pageIndex);
            showPrintPage(printStruct.printpage.pageIndex);
        }
        describe();
        infoLayShow();
    });
    /*
     * 转到上一页胶片
     * */
    $(document).on('click', '#prePage', function () {

        if (printStruct.printpage.pagetotal >= 1) {
            printStruct.printpage.pageIndex -= 1;
            if (printStruct.printpage.pageIndex < 1) {
                printStruct.printpage.pageIndex = 1;
            }

            $('.currentPageIndex').val(printStruct.printpage.pageIndex);
            showPrintPage(printStruct.printpage.pageIndex);
        }
        describe();
        infoLayShow();
    });
    /*
     * 转到下一页胶片
     * */
    $(document).on('click', '#nextPage', function () {
   console.log( printStruct.printpage.pageIndex);
        if (printStruct.printpage.pagetotal >= 1) {
            printStruct.printpage.pageIndex += 1;
            console.log( printStruct.printpage.pageIndex);
            if (printStruct.printpage.pageIndex > printStruct.printpage.pagetotal) {
                printStruct.printpage.pageIndex = printStruct.printpage.pagetotal;
                console.log( printStruct.printpage.pageIndex);
            }

            $('.currentPageIndex').val(printStruct.printpage.pageIndex);
            showPrintPage(printStruct.printpage.pageIndex);
        }
        describe();
        infoLayShow();
    });
    /*
     * 转到最后一页胶片
     * */
    $(document).on('click', '#lastPage', function () {

        if (printStruct.printpage.pagetotal >= 1) {
            printStruct.printpage.pageIndex = printStruct.printpage.pagetotal;

            $('.currentPageIndex').val(printStruct.printpage.pageIndex);
            showPrintPage(printStruct.printpage.pageIndex);
        }
        describe();
        infoLayShow();
    });


    /*
     * 纸张方向切换
     * */
    $('.paperDirection').bind('change', function () {
        var printDirection = $(this).val();
        var paperType = $('#paperSize').val();
        getprintPaperSize(paperType, printDirection);
        changeboxSize();
        chagePagedirec();
        describe();
    });
    /*
     * 纸张类型切换
     * */
    $('#paperSize').bind('change', function () {
        var paperType = $(this).val();
        var printDirection = $('.paperDirection').val();
        getprintPaperSize(paperType, printDirection);
        changeboxSize();
        changePagetype();
        describe();
        //    cookie 保存选择
        var cookieName = "paperSize";
        var cookieValue = paperType;
        console.log(cookieName, cookieValue);
        deleteCookie(cookieName);
        addCookie(cookieName, cookieValue, 24 * 30);

    });
    /*
     * 打印机切换
     * */
    $('.printBoxSelect').bind('change', function () {
        //    cookie 保存选择
        var cookieName = "printerName";
        var cookieValue = $('.printBoxSelect').val();
        console.log(cookieName, cookieValue);
        deleteCookie(cookieName);
        addCookie(cookieName, cookieValue, 24 * 30);
    });

    bindMagnifydblClick();//双击放大


    /*
     *   操作对象切换
     *   图像
     *   */
    $("#procImg").bind('click', function () {
        printStruct.procObj = "procImg";
        printStruct.procType = "null";

        // console.log( printStruct.procObj );
        if ($("#printZoom").hasClass('activeBtn')) {
            printStruct.procType2 = "zoom";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printMove").hasClass('activeBtn')) {
            printStruct.procType2 = "pan";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printWwwl").hasClass('activeBtn')) {
            printStruct.procType2 = "wwwc";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printRotate").hasClass('activeBtn')) {
            printStruct.procType = "rotate";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else {
            printStruct.procType2 = "null";
        }

    });
    /*
     *   操作对象切换
     *   序列
     *   */
    $("#procSeri").bind('click', function () {
        printStruct.procObj = "procSeri";
        printStruct.procType = "null";
        // console.log( printStruct.procObj );
        if ($("#printZoom").hasClass('activeBtn')) {
            printStruct.procType = "zoom";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printMove").hasClass('activeBtn')) {
            printStruct.procType = "pan";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printWwwl").hasClass('activeBtn')) {
            printStruct.procType = "wwwc";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printRotate").hasClass('activeBtn')) {
            printStruct.procType = "rotate";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else {
            printStruct.procType2 = "null";
        }
    });
    /*
     *   操作对象切换
     *   页
     *   */
    $("#procPage").bind('click', function () {
        printStruct.procObj = "procPage";
        printStruct.procType = "null";
        // console.log( printStruct.procObj );
        if ($("#printZoom").hasClass('activeBtn')) {
            printStruct.procType = "zoom";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printMove").hasClass('activeBtn')) {
            printStruct.procType = "pan";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printWwwl").hasClass('activeBtn')) {
            printStruct.procType = "wwwc";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printRotate").hasClass('activeBtn')) {
            printStruct.procType = "rotate";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else {
            printStruct.procType2 = "null";
        }
    });
    /*
     *   操作对象切换
     *   所有
     *   */
    $("#procAll").bind('click', function () {
        printStruct.procObj = "procAll";
        printStruct.procType = "null";
        // console.log( printStruct.procObj );
        if ($("#printZoom").hasClass('activeBtn')) {
            printStruct.procType = "zoom";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printMove").hasClass('activeBtn')) {
            printStruct.procType = "pan";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printWwwl").hasClass('activeBtn')) {
            printStruct.procType = "wwwc";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else if ($("#printRotate").hasClass('activeBtn')) {
            printStruct.procType = "rotate";
            mainProcess(printStruct.procObj, printStruct.procType);
        }
        else {
            printStruct.procType2 = "null";
        }
    });

    /*
     * 图像旋转
     * */
    $("#printRrotate").click(function (e) {
        printStruct.procType = "rrotate";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();
    });
    /*
     * 图像重置
     * */
    $("#printReset").click(function (e) {
        printStruct.procType = "reset";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();

    });
    /*
     * 图像水平镜像
     * */
    $("#printHflip").click(function (e) {
        printStruct.procType = "hflip";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();

    });
    /*
     * 图像垂直镜像
     * */
    $("#printVflip").click(function (e) {
        printStruct.procType = "vflip";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();

    });
    /*
     *图像左旋
     * */
    $("#printLrotate").click(function (e) {
        printStruct.procType = "lrotate";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();
    });
    /*
     * 图像反显
     * */
    $("#printInvert").click(function (e) {
        printStruct.procType = "invert";
        mainProcess(printStruct.procObj, printStruct.procType);
        clearAllMeaserState();
    });


    /*
     * 图像删除
     * */
    $("#printDelete").click(function (e) {
        $('.printViewport').each(function (index, val) {
            //要删除的图像
            if ($(this).hasClass('imgViewportSelected') && $(this).parents('.printWrapper').hasClass('imgBoxSelected')) {
                if ($(this).attr('imgIn') == 'true') {
                    // console.log("删除11");
                    $(this).removeClass("imgBoxSelected");
                    $(this).parents('.printWrapper').removeClass("imgBoxSelected");
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    cornerstone.disable(element);
                    $(this).attr('imageId', "");
                    $(this).attr('seNo', "")
                }
            }
            //    保留的图像
            else {

                if ($(this).attr('imgIn') == 'true') {//确保box中有图
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                    printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                    var viewport = deepCopy1(cornerstone.getViewport(element));
                    printStruct.viewportArr.viewport.push(viewport);
                    cornerstone.disable(element);
                    $(this).attr('imageId', "");
                    $(this).attr('seNo', "");
                }
            }
            $(this).attr('imgIn', 'false');
        });
        //填充图像
        var fillIndex = 0;
        var viewportfillInID = $("div[imgIn=false]").attr('id');

//console.log(printStruct.viewportArr);console.log(printStruct.viewportArr.imageId.length);


        while (fillIndex < printStruct.viewportArr.imageId.length) {
            $("#" + viewportfillInID).parents('.printPage').show();
            // console.log("viewportfillInID:"+viewportfillInID);
            var viewport = printStruct.viewportArr.viewport[fillIndex];
            var imageId = printStruct.viewportArr.imageId[fillIndex];
            var seNo = printStruct.viewportArr.seNo[fillIndex];

            if (viewportfillInID != null || viewportfillInID != "" || viewportfillInID != undefined) {
                $("div[imgIn=false]").parents('.printPage').show();
            }
            fillImageSyn(viewportfillInID, imageId, seNo, viewport);
            fillInfoOnLay(viewportfillInID);
            $("#" + viewportfillInID).attr('imgIn', "true");//添加行列属性
            $("#" + viewportfillInID).attr('imageid', imageId);
            $("#" + viewportfillInID).attr('seNo', seNo);//添加合并方式属性

            fillIndex++;

            viewportfillInID = $("div[imgIn=false]").attr('id');

        }
        pageClear();//空白 页清理
        showPrintPage(printStruct.printpage.pageIndex);
        describe();
        clearImgRecord();
        removeInnerboxNo();
        clearSelecImgBoxCss();
        clearSelecImgViewportCss();

    });


    /*
     * 定位线
     * */
    $("#printReferLine").click(function () {

        if ($(this).hasClass('active')) {
            $("#printReferLine").removeClass('active');
            //  $('#printRLimg').attr('src','ipacsdv/css/img/print/posLine.png');
            cancleMarkReferLine();
            $('.imgViewportSelected').removeAttr('referLine');
        }
        else {
            $("#printReferLine").addClass('active');
            //  $('#printRLimg').attr('src','ipacsdv/css/img/print/posLineActive.png');
            markReferLine();
            $('.imgViewportSelected').attr('referLine', 'true');
        }
    });

  
    /*标识L*/
    $("#markL").click(function (e) {
        var selecStr=".imgViewportSelected[imgIn=true]";
        var length=selectedLength( selecStr,true);
        if(length<1){
            $(this).removeClass('directionStyle');
            return;
        }
        config.current = 'L';
        changeMarkerText();     
    });
    /*标识R*/
    $("#markR").click(function (e) {
        var selecStr=".imgViewportSelected[imgIn=true]";
        var length=selectedLength( selecStr,true);
        if(length<1){
            $(this).removeClass('directionStyle');
            return;
        }
        config.current = 'R';
        changeMarkerText();
    });
    /*标识A*/
    $("#markA").click(function (e) {
        var selecStr=".imgViewportSelected[imgIn=true]";
        var length=selectedLength( selecStr,true);
        if(length<1){
            $(this).removeClass('directionStyle');
            return;
        }
        config.current = 'A';
        changeMarkerText();

    });
    /*标识H*/
    $("#markH").click(function (e) {
        var selecStr=".imgViewportSelected[imgIn=true]";
        var length=selectedLength( selecStr,true);
        if(length<1){
            $(this).removeClass('directionStyle');
            return;
        }
        config.current = 'H';
        changeMarkerText();

    });




    //屏蔽右键
    // .printPageBox,.contentBox,.leftBox,.rightBox
    $(".printPageBox,.contentBox,.leftBox,.rightBox").on('contextmenu', function (e) {
        // e.preventDefault();
         emptyBaseImgCss();
        clearLeftboxSelecCss();
        printStruct.drag.dragFlag = false;
        return false;
    });

    /*
     * (打印全部页)
     * 打印胶片输出图像
     * */
    $("#printAllFilm").click(function (e) {
        var printer = $('.printBoxSelect').val();
        if (printer == "localPrinter") {
            if ($('.printPage').find("div[imgIn=true]").length == 0) {
                pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                return;
            }
            else {
                var printObj = "all";
                jpegPrint(printObj, drawType);
                // var serviceType="FILMPRINT";//预留服务类型参数
                // pop_up({title: "打印提示", message: "确认打印？", ok: getAllFilmData, yesName: "确定", noName: "取消"});
            }
        }
        else {
            if (drawType == "web") {
                if ($('.printPage').find("div[imgIn=true]").length == 0) {
                    pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                    return;
                }
                else {
                    // var serviceType="FILMPRINT";//预留服务类型参数
                    pop_up({title: "打印提示", message: "确认打印？", ok: getAllFilmDataWeb, yesName: "确定", noName: "取消"});
                }

            }
            else if (drawType == "background") {
                if ($('.printPage').find("div[imgIn=true]").length == 0) {
                    pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                    return;
                }
                else {
                    // var serviceType="FILMPRINT";//预留服务类型参数
                    pop_up({
                        title: "打印提示",
                        message: "确认打印？",
                        ok: getAllFilmDataBackground,
                        yesName: "确定",
                        noName: "取消"
                    });
                }
            }
        }


    });

    /*
     * (打印当前页)
     * 打印胶片输出图像
     * */
    $("#printCurFilm").click(function (e) {
        var printer = $('.printBoxSelect').val();
        if (printer == "localPrinter") {
            if ($('.printPage').find("div[imgIn=true]").length == 0) {
                pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                return;
            }
            else {
                var printObj = "cur";
                jpegPrint(printObj, drawType);
                // var serviceType="FILMPRINT";//预留服务类型参数
                // pop_up({title: "打印提示", message: "确认打印？", ok: getCurFilmData, yesName: "确定", noName: "取消"});
            }
        }
        else {
            if (drawType == "web") {
                if ($('.printPage').find("div[imgIn=true]").length == 0) {
                    pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                    return;
                }
                else {
                    // var serviceType="FILMPRINT";//预留服务类型参数
                    pop_up({title: "打印提示", message: "确认打印？", ok: getCurFilmDataWeb, yesName: "确定", noName: "取消"});
                }
            }
            else if (drawType == "background") {
                if ($('.printPage').find("div[imgIn=true]").length == 0) {
                    pop_up({title: "打印提示", message: "当前没有胶片需要打印，或者胶片中没有设置打印图像！", yesName: "确定", noName: "取消"});
                    return;
                }
                else {
                    // var serviceType="FILMPRINT";//预留服务类型参数
                    pop_up({
                        title: "打印提示",
                        message: "确认打印？",
                        ok: getCurFilmDataBackground,
                        yesName: "确定",
                        noName: "取消"
                    });
                }
            }
        }
    });

    //响应缩放操作 响应调窗操作
    $(document).on('mouseup', '.printPageBox', function () {
        if (printStruct.procType2 == "null") {
        }
        else {

            if (printStruct.procObj == "procSeri") {

                seriViewportSyn(printStruct.procType2);//同步序列
            }
            else if (printStruct.procObj == "procAll") {

                allViewportSyn(printStruct.procType2);//同步所有图像
            }
            else if (printStruct.procObj == "procPage") {

                pageViewportSyn(printStruct.procType2);//同步所有图像
            }
            else if (printStruct.procObj == "procImg") {

                imgViewportSyn(printStruct.procType2);//同步所有图像
            }
        }
    });

    //动态改变胶片布局
    $('#layoutBtn').bind('click', function () {
        cancel($('.layoutBox'));//关闭布局弹出框
        if ($('input[name="layoutRadio"]:checked').hasClass('specialRadio')) {
            printStruct.printpage.row = $('.select-row').val();
            printStruct.printpage.col = $('.select-col').val();
        }
        else {
            printStruct.printpage.row = $('input[name="layoutRadio"]:checked').attr('data-row');
            printStruct.printpage.col = $('input[name="layoutRadio"]:checked').attr('data-col');
        }

        //将布局选择保存cookie
        var cookieName = "layout";
        var cookieValue = printStruct.printpage.row + "*" + printStruct.printpage.col;
        console.log(cookieName, cookieValue);
        deleteCookie(cookieName);
        addCookie(cookieName, cookieValue, 24 * 30);


        // var layoutStr = "胶片布局" + "(" + printStruct.printpage.row + "X" + printStruct.printpage.col + ")";
        var layoutStr = "胶片布局" + "(" + printStruct.printpage.col + "X" + printStruct.printpage.row + ")";
        $('.filmLayout').text(layoutStr);
        //每次清空

        $('.printViewport').each(function (m, val) {
            if ($(this).attr('imgIn') == "true") {
                var elementId = $(this).attr('id');
                var element = $("#" + elementId).get(0);

                printStruct.viewportArr.imageId.push($(this).attr('imageId'));
                printStruct.viewportArr.seNo.push($(this).attr('seNo'));
                var viewport = deepCopy1(cornerstone.getViewport(element));
                printStruct.viewportArr.viewport.push(viewport);
            }
        });
 
        layoutSyn(printStruct.printpage.row, printStruct.printpage.col);

        //完成重新布局后默认显示第一页
        printStruct.printpage.pageIndex = 1;
        $('.currentPageIndex').val(printStruct.printpage.pageIndex);
        showPrintPage(1);//显示第一页
        describe();
        clearImgRecord();//清空记录
    });

    /*
     * 胶片打印页面的预设值调窗事件
     * 值来源与主页面的快捷调窗
     * */
    $('#printSetwwwc').bind('change', function () {


        var ww, wc;
        var name = $('#printSetwwwc').val();
        for (var i = 0,len=printStruct.wwwcObjArr.length; i < len; i++) {
            if (name == printStruct.wwwcObjArr[i].name) {
                ww = printStruct.wwwcObjArr[i].ww;//窗位窗宽值必须是数据，注意不要传成字符去了。
                wc = printStruct.wwwcObjArr[i].wc;
                $('#printSetwc').val(ww);
                $('#printSetww').val(wc);
                break;
            }
        }
        if (!isNaN(ww) && !isNaN(wc)) {
            ww = parseInt(ww);
            wc = parseInt(wc);
            // console.log(ww,wc);
            if (!isNaN(ww) && !isNaN(wc)) {
                printQucikwwwc(ww, wc, printStruct.procObj);
            }
        }

    });


    // 主页面，快捷调窗设置中的图像类型变换
    $('.device').bind('change', function () {
        var code = dvStruct.userCode;
        typeChange(code);
    });

    /*
     * 拆分
     * */
    $('.mergeclick').click(function () {
        var mergeType = $(this).attr('data-id');

        if ($('.imgViewportSelected').length >= 1) {
            imgBoxBreakUp(mergeType);
            // pop_up({title: "合并提示", message: "选中的图像太少，无法进行合并操作，至少选中两张！", yesName: "确定", noName: "取消"});
            pageClear();//空白 页清理
            showPrintPage(printStruct.printpage.pageIndex);
            describe();
            clearImgRecord();//清空记录
        }

        removeInnerboxNo();
    });

    /*
     * 还原布局
     * */
    $('.breakup').click(function () {
        // var pageId=$('.imgBoxSelected').parents('.printPage').attr('id');
        if ($('.imgBoxSelected').first().find('.printViewport').hasClass('multiViewport')) {
            var pageIndex = printStruct.printpage.pageIndex;
            imgBoxCancleBreakUp();
            printStruct.printpage.pageIndex = pageIndex; //索引定到拆分时的页
            showPrintPage(printStruct.printpage.pageIndex);//显示拆分时的那一页
            describe();  //更新上方描述
            clearImgRecord();//清空记录
            removeInnerboxNo();
        }
    });

    /*
     * 过滤
     * 过滤初步判定
     * */
    $("#printFliter").click(function (e) {
        if ($(".imgViewportSelected").length < 1) {
            pop_up({title: "过滤提示", message: "没有选中的图像，请先选择有效图像！", yesName: "确定", noName: "取消"});
        }
        else {
            filterInit();

        }

    });

    /*
     * 过滤
     * 确定响应
     * */
    $("#filterOk").click(function (e) {
        filterOk();
        removeInnerboxNo();
        clearImgRecord();

    });


    //=================================四角信息begin=========================================================
    //四角信息设置
    $("#filmTagSet").click(function (e) {

        show($('.printTagSetbox'));
        var printTags = getEnableTags();
        setTimeout(function () {
            console.log("set1");
            var fontsize = $("#tagFontsize").val();
            fontSetInit(400, 400, fontsize);
        }, 200);
    });
    //四角信息内容设置
    $("#tagsetOK").click(function () {
        tagsetOk(dvStruct.userCode);
    });

    $("#tagFontsize").bind('change', function () {
        var fontsize = $(this).val();
        console.log(fontsize);
        addCookie("filmFontsize", fontsize, 24 * 30);
        fontSetInit(400, 400, fontsize);
    });
    //字体设置
    $('.viewFontHref').click(function () {
        setTimeout(function () {
            console.log("set2");
            var fontsize = $("#tagFontsize").val();
            fontSetInit(400, 400, fontsize);
        }, 200);
    });
    //=================================四角信息end=========================================================

});



/**
 * Created by SongJing on 2017/3/28.
 * 打印机设置的相关方法
 */
/*
 * 获取打印机设置参数
 * */
function getPrintSet() {
    // sendData(socket, data, printDirection, sizeType,IP,port,AET,filmObj,filmType,quality,grayEnable)
    var printSetObj = {
        copys: "",
        IP: "",
        port: "",
        AET: "",
        AETLocal: "",
        filmObj: "",
        filmType: "",
        quality: "",
        magnifyType: "",
        grayEnable: ""
    };

    printSetObj.copys = $('.shareNum').val();


    var optionItem = $('.printBoxSelect').val();
    // console.log(optionItem);

    $('.printBoxSelect option').each(function (k, val) {
        var ItemText = $(this).attr('data-name');
        if (ItemText === optionItem) {
            printSetObj.IP = $(this).attr('data-ip');
            printSetObj.port = $(this).attr('data-port');
            printSetObj.AET = $(this).attr('data-aet');
            printSetObj.AETLocal = $(this).attr('data-aetLocal');
            printSetObj.filmObj = $(this).attr('data-position');
            printSetObj.filmType = $(this).attr('data-type');
            printSetObj.quality = $(this).attr('data-priority');
            printSetObj.magnifyType = $(this).attr('data-magnifyType');
            printSetObj.grayEnable = $(this).attr('data-color');

        }
    });
    return printSetObj;
}


/*
 * 获取可显示的信息的词条
 * 图像中某些信息可能没有，所以做这一处理
 * */
function getEnableTags() {
    var printTags = [];
    printTags.length = 0;
    if (dvStruct.seriesArr.length > 0) {
        if (dvStruct.seriesArr[0].dicomArr.length > 0) {
            printTags.push("序列编号");
            printTags.push("图像序号");
            printTags.push("窗位窗宽");

            var infoSetObj = dvStruct.seriesArr[0].dicomArr[0].infoSet;

            if (infoSetObj.EquipmentInfo.InstitutionName.val) {
                printTags.push("机构名称");
            }
            if (infoSetObj.UIDS.InstanceUID.val) {
                printTags.push("机构编号");
            }
            if (infoSetObj.PatientInfo.PatientName.val) {
                printTags.push("患者姓名");
            }
            if (infoSetObj.PatientInfo.PatientID.val) {
                printTags.push("患者ID号");
            }
            if (infoSetObj.PatientInfo.PatientSex.val || infoSetObj.PatientInfo.PatientsAge.val) {
                printTags.push("患者年龄/性别");
            }

            if (infoSetObj.PatientInfo.PatientBirthDate.val) {
                printTags.push("患者出生日期");
            }
            if (infoSetObj.StudyInfo.ProtocolName.val) {
                printTags.push("检查部位");
            }
            if (infoSetObj.StudyInfo.StudyDescription.val) {
                printTags.push("检查描述");
            }
            if (infoSetObj.SomeUsefulInfo.kvp.val && infoSetObj.SomeUsefulInfo.mA.val) {
                printTags.push("千伏/毫安");
            }
            if (infoSetObj.ImageInfo.FieldofView.val) {
                printTags.push("FOV");
            }
            if (infoSetObj.SomeUsefulInfo.MagneticFieldStrength.val) {
                printTags.push("FS");
            }
            if (infoSetObj.SomeUsefulInfo.RepetitionTime.val || infoSetObj.SomeUsefulInfo.RepetitionTime.val) {
                printTags.push("TR/TE");
            }
            if (infoSetObj.SeriesInfo.SliceThickness.val && infoSetObj.SeriesInfo.SliceLocation.val) {
                printTags.push("层厚/实际相对位置");
            }
        }
        else {

        }
    }
    else {

    }
    return printTags;
}

/*
 * 按照设置的参数
 * 创建图像信息对象
 * */
function creatInfoAsSet(imgInfo, imgIdObj, wl, ww, ltTags, rtTags, lbTags, rbTags) {

    var stringTemp;
    var imgInfoStrObj = {
        ltInfoStrArr: [],
        lbInfoStrArr: [],
        rtInfoStrArr: [],
        rbInfoStrArr: []
    };
    imgInfoStrObj.ltInfoStrArr.length = 0;
    imgInfoStrObj.lbInfoStrArr.length = 0;
    imgInfoStrObj.rtInfoStrArr.length = 0;
    imgInfoStrObj.rbInfoStrArr.length = 0;
    //lt  infoStrArr
    for (var i = 0,len=ltTags.length; i < len; i++) {
        var tagsText = ltTags[i];

        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.ltInfoStrArr.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "机构编号") {

        }
        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.ltInfoStrArr.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.ltInfoStrArr.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.ltInfoStrArr.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.ltInfoStrArr.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.ltInfoStrArr.push(stringTemp);
            }
        }

    }

    //lb  infoStrArr
    for (var i = 0,len=lbTags.length; i < len; i++) {
        var tagsText = lbTags[i];
        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.lbInfoStrArr.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.lbInfoStrArr.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.lbInfoStrArr.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.lbInfoStrArr.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();

            if (date) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.lbInfoStrArr.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.lbInfoStrArr.push(stringTemp);
            }

        }
    }

    //rt  infoStrArr
    for (var i = 0 ,len=rtTags.length; i < len; i++) {
        var tagsText = rtTags[i];
        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.rtInfoStrArr.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "机构编号") {

        }
        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.rtInfoStrArr.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.rtInfoStrArr.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.rtInfoStrArr.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.rtInfoStrArr.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }

        }
        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.rtInfoStrArr.push(stringTemp);
            }
        }
    }

    //rb  infoStrArr
    for (var i = 0,len=rbTags.length; i < len; i++) {
        var tagsText = rbTags[i];

        if (tagsText == "序列编号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Se:" + imgIdObj.se;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像序号") {
            if (imgIdObj.seriesLength > 0) {
                stringTemp = "Im:" + imgIdObj.imgIndex + "/" + imgIdObj.seriesLength;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "窗位窗宽") {
            stringTemp = "WL/WW:" + wl + "/" + ww;//占位数据
            imgInfoStrObj.rbInfoStrArr.push(stringTemp);

        }
        if (tagsText == "机构名称") {
            if (imgInfo.EquipmentInfo.InstitutionName.val) {
                stringTemp = imgInfo.EquipmentInfo.InstitutionName.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者姓名") {
            if (imgInfo.PatientInfo.PatientName.val) {
                stringTemp = imgInfo.PatientInfo.PatientName.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "患者ID号") {
            if (imgInfo.PatientInfo.PatientID.val) {
                stringTemp = imgInfo.PatientInfo.PatientID.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }

        if (tagsText == "患者年龄/性别") {
            if (imgInfo.PatientInfo.PatientsAge.val || imgInfo.PatientInfo.PatientSex.val) {
                stringTemp = imgInfo.PatientInfo.PatientsAge.val + " " + imgInfo.PatientInfo.PatientSex.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }

        }
        if (tagsText == "患者出生日期") {
            var birth = imgInfo.PatientInfo.PatientBirthDate.val;
            if (birth) {
                if (imgInfo.PatientInfo.PatientBirthDate.val) {
                    var birthstr = birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2);
                    imgInfoStrObj.rbInfoStrArr.push(birthstr);
                }
            }
        }
        if (tagsText == "检查部位") {
            stringTemp = imgInfo.StudyInfo.ProtocolName.val;
            imgInfoStrObj.rbInfoStrArr.push(stringTemp);
        }
        if (tagsText == "检查描述") {
            if (imgInfo.StudyInfo.StudyDescription.val) {
                stringTemp = imgInfo.StudyInfo.StudyDescription.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "InstanceUID") {
            var backInfo = searchBackInfo(imgInfo.UIDS.InstanceUID.val);
            if (backInfo) {
                if (backInfo.CBZ) {
                    imgInfoStrObj.rbInfoStrArr.push(backInfo.CBZ);
                }
            }
        }
        if (tagsText == "千伏/毫安") {
            stringTemp = null;
            if (imgInfo.SomeUsefulInfo.kvp.val) {
                stringTemp = imgInfo.SomeUsefulInfo.kvp.val + 'kV';
            }
            if (imgInfo.SomeUsefulInfo.mA.val) {
                if (stringTemp == null) {
                    stringTemp = imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
                else {
                    stringTemp += ' ' + imgInfo.SomeUsefulInfo.mA.val + 'mA';
                }
            }
            if (stringTemp != null) {
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FOV") {
            if (imgInfo.ImageInfo.FieldofView.val) {
                stringTemp = 'FOV:' + parseFloat(imgInfo.ImageInfo.FieldofView.val).toFixed(1);
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "FS") {
            if (imgInfo.SomeUsefulInfo.MagneticFieldStrength.val) {
                stringTemp = 'FS: ' + imgInfo.SomeUsefulInfo.MagneticFieldStrength.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "TR/TE") {
            if (imgInfo.SomeUsefulInfo.RepetitionTime.val || imgInfo.SomeUsefulInfo.RepetitionTime.val) {
                stringTemp = 'TR: ' + imgInfo.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + imgInfo.SomeUsefulInfo.EchoTime.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查日期") {
            var date = imgInfo.StudyInfo.StudyDate.val.toString();
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (date && time) {
                stringTemp = date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2);
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "层厚/实际相对位置") {
            var theT = imgInfo.SeriesInfo.SliceThickness.val, theL = imgInfo.SeriesInfo.SliceLocation.val;
            if (theT || theL) {
                try {
                    theT = theT ? parseFloat(theT).toFixed(1) : theT;
                    theL = theL ? parseFloat(theL).toFixed(1) : theL;
                } catch (e) {
                    console.error(e);
                }
                stringTemp = 'T:' + theT + 'mm L:' + theL + 'mm';
                // stringTemp = 'T/L:' + theT + '/' + theL;
            }
            imgInfoStrObj.rbInfoStrArr.push(stringTemp);
        }
        if (tagsText == "层间距") {
            var sbs = imgInfo.SeriesInfo.SpacingBetweenSlices.val;
            if (sbs) {
                try {
                    sbs = sbs ? parseFloat(sbs).toFixed(1) : sbs;
                } catch (e) {
                    console.error(e);
                }
                // stringTemp='T:'+theT+'mm L:'+theL+'mm';
                stringTemp = 'SBS:' + sbs + "mm";
            }
            imgInfoStrObj.rbInfoStrArr.push(stringTemp);
        }
        if (tagsText == "图像位置") {
            if (imgInfo.ImageInfo.ImagePositionPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImagePositionPatient.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "检查模态") {
            if (imgInfo.SeriesInfo.Modality.val) {
                stringTemp = imgInfo.SeriesInfo.Modality.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "图像方位") {

            if (imgInfo.ImageInfo.ImageOrientationPatient.val) {
                stringTemp = imgInfo.ImageInfo.ImageOrientationPatient.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }


        }
        if (tagsText == "检查时间") {
            var time = imgInfo.StudyInfo.StudyTime.val.toString();
            if (time) {
                stringTemp = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2);
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
        if (tagsText == "采样率") {

            if (imgInfo.ImageInfo.SamplesPerPixel.val) {
                stringTemp = imgInfo.ImageInfo.SamplesPerPixel.val;
                imgInfoStrObj.rbInfoStrArr.push(stringTemp);
            }
        }
    }

    return imgInfoStrObj;
}


//显示打印机信息
function showPrintInfo(code) {

    // console.log(code);
    $.ajax({
        type: 'post',
        data: {
            opt: 'GetPSet',
            code: code

        },
        url: 'http://' + urlInit + '/DicomPrinter',

        success: function (data) {

            var json = eval('(' + data + ')');
            if (json.result == true) {
                //页面本身
                var printBoxSelect = $('.printBoxSelect');
                printBoxSelect.empty();
                $.each(json.message, function (key, val) {
                    console.log(key,val);
                    // var option = $('<option  data-id="' + val.IID + '" data-name="' + val.Name + '" data-ip="' + val.IP + '" data-AET="' + val.AET + '" data-Port="' + val.Port + '" data-Position="' + val.Position + '" data-Type="' + val.Type + '" data-Priority="' + val.Priority + '"   data-Color="' + val.Color + '"></option>').append(val.Name);
                    // var option = $('<option  data-id="' + val.IID + '" data-name="' + val.Name + '" data-ip="' + val.IP + '" data-AET="' + val.AET + '" data-Port="' + val.Port + '" data-Position="' + val.Position + '" data-Type="' + val.Type + '" data-Priority="' + val.Priority + '"    data-magnifyType="'+val.magnifyType+' "   data-Color="' + val.Color + '"></option>').append(val.Name);
                    var option = $('<option  data-id="' + val.IID + '" data-name="' + val.Name + '" data-ip="' + val.IP + '" data-AET="' + val.AET + '" data-AETLocal="' + val.AETLocal+ '" data-Port="' + val.Port + '" data-Position="' + val.Position + '" data-Type="' + val.Type + '" data-Priority="' + val.Priority + '"    data-magnifyType="'+val.magnifyType+' "   data-Color="' + val.Color + '"></option>').append(val.Name);

                    printBoxSelect.append(option);
                });


                addLocalPrinter();//添加本地打印机

                //打印机设置框内部
                var leftBox = $('.setBox .leftBox');
                var ul = $('.temp');
                ul.empty();
                $.each(json.message, function (key, val) {
                    var li = $('<li class="leftPrintBox" data-id="' + val.IID + '"></li>').append(val.Name);
                    ul.append(li);
                });
                leftBox.append(ul);
            }

        },
        error:function () {
            // addLocalPrinter();//添加本地打印机
        }
    });


}
//添加打印机信息
function addPrintInfo(opt, id, code) {
    var name = $('input[name="name"]').val();
    var ip = $('input[name="ip1"]').val() + '.' + $('input[name="ip2"]').val() + '.' + $('input[name="ip3"]').val() + '.' + $('input[name="ip4"]').val();
    var aet = $('input[name="aet"]').val();
    var aetLocal = $('input[name="aetLocal"]').val();
    var port = $('input[name="port"]').val();
    var position = $('select[name="position"]').val();
    var type = $('select[name="type"]').val();
    var priority = $('select[name="priority"]').val();
    var gray = $('input:checkbox[name="gray"]:checked').val();
    var magnifyType= $('select[name="magnifyType"]').val();

    if (gray == null || gray == "" || gray == undefined) {
        gray = 0;
    }
    else {
        gray = 1;
    }
    console.log(name + '---' + ip + '---' + aet +'---' + aetLocal + '---' + port + '---' + position + '--' + type + '=--' + priority + '--' + gray+'--' +magnifyType);
    console.log(code);
    $.ajax({
        type: 'post',
        data: {
            opt: opt,
            code: code,
            id: id,
            name: name,
            ip: ip,
            aet: aet,
            aetLocal: aetLocal,
            port: port,
            position: position,
            type: type,
            priority: priority,
            color: gray,
            magnifyType:magnifyType
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            console.log(data);

            var json = eval('(' + data + ')');
            console.log(json);
            if (json.result == true) {
                clearInput();
                threeCancel($('.printSetBox'));
                pop_up({title: "提示", message: "操作成功", yesName: "确定", noName: "取消"});
                var code = dvStruct.hospitalCode;
                showPrintInfo(code);
            }
            else {
                pop_up({title: "提示", message: "操作失败", yesName: "确定", noName: "取消"});
            }
        }
    });
}
function clearInput() {
    $('input[name="name"]').val('');
    $('input[name="ip1"]').val('127');
    $('input[name="ip2"]').val('0');
    $('input[name="ip3"]').val('0');
    $('input[name="ip4"]').val('1');
    $('input[name="aet"]').val('');
    $('input[name="aetLocal"]').val('');
    $('input[name="port"]').val('');
    $('select[name="position"]').val('processor');
    $('select[name="type"]').val('blue film');
    $('select[name="priority"]').val('low');
    $('select[name="magnifyType"]').val('none');

    $('input:checkbox[name="gray"]').attr('checked');
}
//删除打印机信息
function deletePrintInfo(id, code) {
    $.ajax({
        type: 'post',
        data: {
            opt: 'DelPSet',
            code: code,
            id: id
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            var json = eval('(' + data + ')');
            if (json.result == true) {
                $('.leftPrintBox').each(function () {
                    if ($(this).attr('data-id') == id) {
                        $(this).remove();
                    }
                });
                pop_up({title: "提示", message: "删除成功", yesName: "确定", noName: "取消"});

            }
        }
    });
}

/**
 * Created by Administrator on 2016/12/7.
 * 胶片打印页面的页面显示处理及初始化
 */


if (!printStruct) {
    var printStruct = {};
}
if (!printStruct.printpage) {
    printStruct.printpage = {
        row: 1,
        col: 1,
        pagetotal: 0,
        pageIndex: 0
    };
}

printStruct.key = {
    ctrlDown: false,
    shiftDown: false
};


var mergeId;//合并方式

$(function () {
    boxH();
    getprintPaperSize('14INX17IN', '1');
    /*
     * 窗口自适应
     * */
    $(window).resize(function () {
        boxH();
        var paperType = $('#paperSize').val();
        var printDirection = $('.paperDirection').val();

        getprintPaperSize(paperType, printDirection);
        changeboxSize();
        // hideImgInfoOnScreen();
        infoLayShow();

    });
    bindMagnifydblClick();//双击放大
    /*
     * 左侧缩略图选择
     * */
    $(document).on('click', '.orderUl', function () {
        $(this).addClass('activeStyle-background ').siblings().removeClass('activeStyle-background');
        $(this).addClass('activeStyle-boder').siblings().removeClass('activeStyle-boder');

    });
    //table li active
    $(document).on('click', '.table1Body tr', function () {
        $(this).addClass('activeLi').siblings().removeClass('activeLi');
    });
    /*
     * 左侧序列展开
     * */
    $('.right .fa-plus').bind('click', function () {
        $('.right .fa-minus').show();
        $(this).hide();
        $('.imgBox').show();

    });
    /*
     * 左侧序列合并
     * */
    $('.right .fa-minus').bind('click', function () {
        $('.right .fa-plus').show();
        $(this).hide();
        $('.imgBox').hide();

    });
    /*
     * 左侧当前序列缩略图合并
     * */
    $(document).on('click', '.right .fa-caret-down', function () {
        $(this).parent('.right').find('.fa-caret-right').show();
        $(this).hide();
        // $(this).parents('.orderUl').css('height', '190px');
        // $(this).parents('.orderUl').css('height', '174px');
        $(this).parents('.orderUl').css('height', '179px');
        $(this).parents('.orderUl').removeClass('expansionstate');//收拢状态

    });
    /*
     * 左侧当前序列缩略图展开
     * */
    $(document).on('click', '.right .fa-caret-right', function () {
        $(this).parent('.right').find('.fa-caret-down').show();
        $(this).hide();
        $(this).parents('.orderUl').css('height', 'inherit');
        /* $('.orderUl').css('height','inherit');*/
        $(this).parents('.orderUl').addClass('expansionstate');//展开状态

    });


    // 打印份数增加
    $('.btnAddNum').bind('click', function () {
        var add = $('.shareNum').val();
        add++;
        $('.shareNum').val(add);
    });
    //打印份数减少
    $('.btnPlusNum').bind('click', function () {
        var add = $('.shareNum').val();
        if (add != 1) {
            add--;
        }
        $('.shareNum').val(add);
    });
    //点击拆分样式
    $('.merge').hover(function () {
        $('.merge ul').show();
    }, function () {
        $('.merge ul').hide();
    });
    //点击merge li 选择拆分布局的方式
    $('.mergeUl li').bind('click', function () {
        mergeId = $(this).attr('data-id');
        // console.log(mergeId);
        return mergeId;
    });


    //点击外层陷下图标
    $('.iconBtnBox .btnStyle2').bind('click', function () {
        printStruct.procType = "null";
        clearAllMeaserState();
        var imgBox = $(this).attr('data-img');
        if ($(this).hasClass('activeBtn')) {
            clearAllMeaserState();//关闭所有图像操作开关
            printStruct.procType2 = "null";
            $(this).removeClass('activeBtn');
            $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox + '") no-repeat  0 0');
        }
        else {
            //add function
            var btnId = $(this).attr('id');
            procSelect(btnId);

            $(this).addClass('activeBtn').siblings().removeClass('activeBtn');
            $('.btnStyle2').each(function () {
                var imgBox1 = $(this).attr('data-img');
                if ($(this).hasClass('activeBtn')) {
                    $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox1 + '") no-repeat  -80px 0');
                }
                else {
                    $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox1 + '") no-repeat  0 0');
                }
            });

        }

    });

    //点击一次操作按钮如镜像时，状态开关按钮关闭如移动
    $('.iconBtnBox .btnStyle1').bind('click', function () {
        clearAllMeaserState();//关闭所有图像操作开关
        printStruct.procType2 = "null";
        $('.btnStyle2').each(function () {
            var imgBox1 = $(this).attr('data-img');
            if ($(this).hasClass('activeBtn')) {
                $(this).removeClass('activeBtn');
                $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox1 + '") no-repeat  0 0');
            }
        });
    });


    //点击放大弹出框陷下图标
    $('.calBox .btnStyle3').bind('click', function () {
        $(this).addClass('activeBtn').siblings().removeClass('activeBtn');
        $('.btnStyle3').each(function () {
            var imgBox1 = $(this).attr('data-img');
            if ($(this).hasClass('activeBtn')) {

                $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox1 + '") no-repeat  -80px 0');
            }
            else {
                // //add function
                // var btnId=$(this).attr('id');
                // procSelect(btnId);
                $(this).css('background', 'url("ipacsdv/css/img/print/' + imgBox1 + '") no-repeat  0 0');
            }
        });


    });

    //点击清除任务
    $('.clearBtn').bind('click', function () {
        pop_up({title: "提示", message: "hahahhah", yesName: "确定", noName: "取消"});

    });
    //胶片页面点击方向标识L R A H
    $('.directionLi li').bind('click', function () {
        $(this).addClass('directionStyle').siblings().removeClass('directionStyle');
    });
    //序列及图像显示收缩按钮
    $('.right .fa-caret-down').bind('click', function () {
        $(this).parent('.right').find('.fa-caret-right').show();
        $(this).hide();
        $(this).parents('.orderUl').css('height', '174px');
    });
    $('.right .fa-caret-right').bind('click', function () {
        $(this).parent('.right').find('.fa-caret-down').show();
        $(this).hide();
        $(this).parents('.orderUl').css('height', 'inherit');
        /* $('.orderUl').css('height','inherit');*/
    });
    //设置点击LI  打印机设置中的增删改
    $(document).on('click', '.setBox .leftBox ul li', function () {
        $(this).addClass('setBoxLi').siblings().removeClass('setBoxLi');
    });

    //打印机设置 begin
    //点击打印机设置按钮
    $('#printerSet').bind('click', function () {
        show($('.setBox'));
    });
    //打印机添加确定按钮
    $('#printSetBoxBtn').bind('click', function () {
        var id = '';
        var opt = 'AddPSet';
        var code = dvStruct.hospitalCode;
        addPrintInfo(opt, id, code);
    });
    //设置取消加关闭按钮
    $('.printCloseBtn').bind('click', function () {
        threeCancel($('.printSetBox'));
        clearInput();
    });
    $('#printUpdataBoxBtn').bind('click', function () {
        var id = $('.setBoxLi').attr("data-id");
        var opt = 'UpdPSet';
        var code = dvStruct.hospitalCode;
        addPrintInfo(opt, id, code);
    });
    //打印机添加按钮
    $('#addPrint').bind('click', function () {
        threeShow($('.printSetBox'));
        $('#printUpdataBoxBtn').hide();
        $('#printSetBoxBtn').show();
    });
    //打印机修改按钮
    $('#modifyPrint').bind('click', function () {
        var id = $('.setBoxLi').attr("data-id");
        if (id == "" || id == null) {
            pop_up({title: "提示", message: "没有选择修改项", yesName: "确定", noName: "取消"});

        }
        else {
            var code = dvStruct.hospitalCode;
            threeShow($('.printSetBox'));
            $('#printUpdataBoxBtn').show();
            $('#printSetBoxBtn').hide();
            $.ajax({
                type: 'post',
                data: {
                    opt: 'GetPSet',
                    code: code,
                    id: id
                },
                url: 'http://' + urlInit + '/DicomPrinter',
                success: function (data) {
                    // console.log(data);
                    var json = eval('(' + data + ')');
                    if (json.result == true) {
                        $('input[name="name"]').val(json.message[0].Name);
                        var kk = json.message[0].IP.split(".");//以逗号作为分隔字符串
                        var inpue1 = $('input[name="ip1"]').val(kk[0]);
                        var inpue2 = $('input[name="ip2"]').val(kk[1]);
                        var inpue3 = $('input[name="ip3"]').val(kk[2]);
                        var inpue4 = $('input[name="ip4"]').val(kk[3]);

                        $('input[name="aet"]').val(json.message[0].AET);
                        $('input[name="aetLocal"]').val(json.message[0].AETLocal);
                        $('input[name="port"]').val(json.message[0].Port);
                        $('select[name="position"]').val(json.message[0].Position);
                        $('select[name="type"]').val(json.message[0].Type);
                        $('select[name="priority"]').val(json.message[0].Priority);
                        $('select[name="magnifyType"]').val(json.message[0].magnifyType);
                        // console.log(json.message[0].Color);
                        if (json.message[0].Color == 1) {
                            $('input[name="gray"]').attr('checked');
                        }
                        else {
                            $('input[name="gray"]').removeAttr('checked');
                        }
                    }
                }
            });
        }

    });
    //打印机删除按钮
    $('#deletePrint').bind('click', function () {
        var id = $('.setBoxLi').attr("data-id");
        if (id == "" || id == null) {
            pop_up({title: "提示", message: "没有选择删除项", yesName: "确定", noName: "取消"});

        }
        else {
            var code = dvStruct.hospitalCode;
            deletePrintInfo(id, code);
        }

    });
    //打印机设置 end
    //选框li
    $(document).on('mouseover', '.fontDiv ul li', function () {
        $(this).find('.pull-right').show();
    });
    $(document).on('mouseout', '.fontDiv ul li', function () {
        $(this).find('.pull-right').hide();
    });
    //选框ul
    $(document).on('click', '.fontDiv ul', function () {
        $('.fontDiv ul').removeClass('activeUl');
        $(this).addClass('activeUl');
    });
    //可选内容li
    $(document).on('click', '.selectBox li', function () {
        $(this).addClass('activeLi').siblings().removeClass('activeLi');
    });

    //四角信息设置弹出框响应
    //四角信息添加
    $('#addPrintTag').bind('click', function () {
        var div = $('<div class="clearfix pull-right">' +
            '<a class="moveUpBtn" href="javascript:;"><span class="delTit">上移</span></a>&nbsp;' +
            '<a class="moveDownBtn" href="javascript:;"><span class="delTit">下移</span></a>&nbsp;' +
            '<a class="deleteBtn" href="javascript:;"><span class="delTit">删除</span></a>' +
            '</div>');
        var span = $('<span class="pull-left"></span>').append($('.selectBox .activeLi').text());
        //  var describ=$('.selectBox .activeLi').attr('desc');
        var li = $('<li class="courseList"></li>');
        li.append(span, div);
        $('.activeUl').append(li);
        if ($('.fontDiv ul').hasClass('activeUl')) {
            $('.selectBox .activeLi').remove();
        }
        else {
            pop_up({title: "提示", message: "请选中添加位置", yesName: "确定", noName: "取消"});
        }


    });

    //上移
    $(document).on("click", ".moveUpBtn", function () {

        var self = $(this);
        var _old = self.closest("li.courseList");
        var _new = self.closest("li.courseList").prev("li");
        // var oldDescribe=self.closest("li.courseList").attr('desc');
        // var newDescribe=self.closest("li.courseList").prev("li").attr('desc');

        if (_new.length > 0) {
            var _temp = _old.html();
            _old.empty().append(_new.html());
            _new.empty().append(_temp);

            // _old.attr('desc',newDescribe);
            // _new.attr('desc',oldDescribe)
        }
        $('.pull-right').hide();
    });
    //下移
    $(document).on("click", ".moveDownBtn", function () {
        console.log('234');
        var self = $(this);
        var _old = self.closest("li.courseList");
        var _new = self.closest("li.courseList").next("li");
        // var oldDescribe=self.closest("li.courseList").attr('desc');
        // var newDescribe=self.closest("li.courseList").next("li").attr('desc');
        if (_new.length > 0) {
            var _temp = _old.html();
            _old.empty().append(_new.html());
            _new.empty().append(_temp);

            // _old.attr('desc',newDescribe);
            // _new.attr('desc',oldDescribe)
        }
        $('.pull-right').hide();
    });
    //删除
    $(document).on("click", ".deleteBtn", function () {
        console.log('345');
        var self = $(this);//当前click事件源对象
        self.closest("li.courseList").remove();
        // var describe= self.closest("li.courseList").attr('desc');
        var li = $('<li></li>');
        li.append(self.parents('.courseList').find('.pull-left').text());
        $('.selectBox').append(li);
    });
    //四角信息设置弹出框响应end

});












/**
 * Created by Administrator on 2016/12/7.
 * 打印页面纸张类型的尺寸
 */

var paperSizeW;
var paperSizeH;
/*
 * 根据纸张类型和纸张方向获取W H
 * 单位像素
 * */
function getprintPaperSize(paperType, printDirection) {

    switch (paperType) {
        case "A4":
            // console.log("A4:");
            printSize(794, 1123, printDirection);

            break;
        case "A3":
            // console.log("A3:");
            printSize(1123, 1588, printDirection);

            break;
        case "8INX10IN":
            printSize(768, 960, printDirection);
            break;
        case "8_5INX11IN":
            printSize(816, 1056, printDirection);
            break;
        case "10INX12IN":
            printSize(960, 1152, printDirection);
            break;
        case "10INX14IN":
            printSize(960, 1344, printDirection);
            break;
        case "11INX14IN":
            printSize(1056, 1344, printDirection);
            break;
        case "11INX17IN":
            printSize(1056, 1632, printDirection);
            break;
        case "14INX14IN":
            printSize(1344, 1344, printDirection);
            break;
        case "14INX17IN":
            printSize(1344, 1632, printDirection);
            break;
        case "24CMX24CM":
            printSize(908, 908, printDirection);
            break;
        case "24CMX30CM":
            printSize(908, 1134, printDirection);
            break;
        default:
            printSize(794, 1123, printDirection);
            break;
    }
    $('.printPage').css({
        'width': paperSizeW,
        'height': paperSizeH
    });
}
/*
 * 根据页面W H 和纸张的W H 计算胶片显示的实际W H
 * */
function printSize(boxWidth, boxHeight, direction) {
    var printW = $('.printPageBox').width();
    var printH = $('.printPageBox').height();
    var scale = Math.min(printW / boxWidth, printW / boxHeight, printH / boxHeight, printH / boxWidth);
    if (direction == 1) {
        printW = boxWidth * scale;
        printH = boxHeight * scale;
    }
    else {
        printW = boxHeight * scale;
        printH = boxWidth * scale;
    }
    paperSizeW = printW;
    paperSizeH = printH;

    return paperSizeW;
    return paperSizeH;
}
/*
* 纸张方向改变
* */
function chagePagedirec() {
    var direct = $('.paperDirection').val();
    // var type = $('#paperSize').val();
    // addprintPage(direct, type);
    $('.printPage').each(function () {
        $(this).attr('paperdirect', direct);
    });

}






/*
 * 获取所选纸张类型对应的 像素W H
 * */
function getPaperWH(paperType, printDirection) {
    var paperSize = {
        width: 0,
        height: 0
    };

    switch (paperType) {
        case "A4":
                paperSize.width = 794;
                paperSize.height = 1123;
            break;
        case "A3":
                paperSize.width = 1123;
                paperSize.height = 1588;
            break;
        case "8INX10IN":
                paperSize.width = 768;
                paperSize.height = 960;
            break;
        case "8_5INX11IN":
                paperSize.width = 816;
                paperSize.height = 1056;
            break;
        case "10INX12IN":
                paperSize.width = 960;
                paperSize.height = 1152;
            break;
        case "10INX14IN":
                paperSize.width = 960;
                paperSize.height = 1344;
            break;
        case "11INX14IN":
                paperSize.width = 1056;
                paperSize.height = 1344;
            break;
        case "11INX17IN":
                paperSize.width = 1056;
                paperSize.height = 1632;
            break;
        case "14INX14IN":
            paperSize.width = 1344;
            paperSize.height = 1344;
            break;
        case "14INX17IN":
                paperSize.width = 1344;
                paperSize.height = 1632;
            break;
        case "24CMX24CM":
            paperSize.width = 908;
            paperSize.height = 908;
            break;
        case "24CMX30CM":
                paperSize.width = 908;
                paperSize.height = 1134;
            break;
        default:
                paperSize.width = 794;
            break;
    }
    if(printDirection == "1"){
        var temp=paperSize.width;
        paperSize.width=paperSize.height;
        paperSize.height=temp;
    }
    return paperSize;
}



/**
 * Created by SongJing on 2017/3/28.
 * 胶片页面切换操作对象时的图像状态同步
 */
if (!dvStruct) {
    var dvStruct = {};
}
if (!printStruct) {
    var printStruct = {};
}
/*
 * 关闭所有图像的测量操作操作开关
 * */
function clearAllMeaserState() {
    $(".printViewport").each(function () {
        var elementId = $(this).attr('id');
        if ($("#" + elementId).attr('imgIn') == "true") {
            var element = $("#" + elementId).get(0);
            disableAllToolsP(element);
        }
    });
}

/*
 *
 * 关闭element的图像操作使能
 * */
function disableAllToolsP(element) {
    cornerstoneTools.mouseInput.disable(element);
    cornerstoneTools.mouseWheelInput.disable(element);
    cornerstoneTools.wwwc.deactivate(element, 1);
    cornerstoneTools.pan.deactivate(element, 1); // 2 is middle mouse button
    // cornerstoneTools.zoom.deactivate(element, 4); // 4 is right mouse button
    // cornerstoneTools.zoom.deactivate(element, 5); // 4 is right mouse button
    cornerstoneTools.rotate.deactivate(element, 1);
    // cornerstoneTools.zoomWheel.deactivate(element);
    cornerstoneTools.zoom.deactivate(element, 1);

}

/*
 * 打开多选情况下每个窗口的开关
 * */
function openProcEnable(procType) {
    $('.imgViewportSelected').each(function () {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            if (procType == "wwwc" || procType == "zoom" || procType == "pan" || procType == "rotate") {
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);//只是把该操作使能了，但没有同步更新
            }

        }
    });
}

/*
 * 根据当前选中的操作对象和操作类型修改参数调用路由方法
 * */
function procSelect(btnId) {
    switch (btnId) {
        case"printRotate":
            printStruct.procType = "null";
            printStruct.procType2 = "rotate";
            break;
        case"printRrotate":
            printStruct.procType = "rrotate";
            break;
        case"printZoom":
            printStruct.procType = "null";
            printStruct.procType2 = "zoom";
            break;
        case"printMove":
            printStruct.procType = "null";
            printStruct.procType2 = "pan";
            break;
        case"printHflip":
            printStruct.procType = "hflip";
            break;
        case"printVflip":
            printStruct.procType = "vflip";
            break;
        case"printLrotate":
            printStruct.procType = "lrotate";
            break;
        case"printInvert":
            printStruct.procType = "invert";
            break;
        case"printWwwl":
            printStruct.procType = "null";
            printStruct.procType2 = "wwwc";
            break;
        case"printReset":
            printStruct.procType = "reset";
            break;
        default:
            printStruct.procType = "null";
            break;

    }
    if (printStruct.procType != "null" && printStruct.procType != undefined) {
        mainProcess(printStruct.procObj, printStruct.procType);
    }
    if (printStruct.procType2 != "null" && printStruct.procType2 != undefined) {
        mainProcess(printStruct.procObj, printStruct.procType2);
    }

}

/*
 * 响应图像操作的路由函数
 * procObj： procImg procSeri procPage procAll
 * procType： 图像的操作如翻转调窗等
 * */
function mainProcess(procObj, procType) {
    switch (procObj) {
        case "procImg":
            procImg(procType);
            break;
        case"procSeri":
            procSeri(procType);
            break;
        case"procPage":
            procPage(procType);
            break;
        case"procAll":
            // console.time('timeProcAll');
            procAll(procType);
            // console.timeEnd('timeProcAll');
            break;
        default:
            procImg(procType);
            break;
    }
}

//图像操作同步设置
var synchronizerWWWC = new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.wwwcSynchronizer);
var synchronizerZoomPan = new cornerstoneTools.Synchronizer("CornerstoneImageRendered", cornerstoneTools.panZoomSynchronizer);

/*
 * 移除所有图像的同步设置
 * */
function removeAllsyn() {
    $(".printViewport").each(function () {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            synchronizerWWWC.remove(element);
            synchronizerZoomPan.remove(element);
            cornerstoneTools.wwwc.deactivate(element, 1);
            cornerstoneTools.pan.deactivate(element, 1); // 2 is middle mouse button
            cornerstoneTools.zoom.deactivate(element, 1); // 4 is right mouse button
            cornerstoneTools.zoomWheel.deactivate(element);
        }

    });
}

/*
 * 同步所有选中图像
 * */
function addAllsyn(procType) {
    $("div[imgIn=true]").each(function (k, val) {
        var elementId = $(this).attr('id');
        var element = $("#" + elementId).get(0);
        if (procType == "wwwc" || procType == "zoom" || procType == "pan" || procType == "rotate") {
            cornerstoneTools.mouseInput.enable(element);
            cornerstoneTools.mouseWheelInput.enable(element);
            cornerstoneTools[procType].activate(element, 1);//只是把该操作使能了，但没有同步更新
        }
    });
}

/*
 * 同步与选中图像在同一序列图像
 * */
function addSerisyn(procType, seNo) {

    var selectorStr = "div[seNo=" + seNo + "]";
    $(selectorStr).each(function () {
        if ($(this).attr("imgIn") == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            if (procType == "wwwc" || procType == "zoom" || procType == "pan" || procType == "rotate") {
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);//只是把该操作使能了，但没有同步更新
            }

        }
    });

}

/*
 * 对当前选中图像处理事件
 * */
function procImg(procType) {
    $(".imgViewportSelected").each(function (k, val) {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            //     disableAllToolsP(element);
            if (procType == "reset") {
                cornerstone.reset(element);
            }
            else if (procType == "hflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.vflip = !viewport.vflip;
                }
                else{
                    viewport.hflip = !viewport.hflip;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "vflip") {
                var viewport = cornerstone.getViewport(element);

                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.hflip = !viewport.hflip;
                }
                else{
                    viewport.vflip = !viewport.vflip;
                }


                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "rrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation + 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "lrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation - 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "invert") {
                var viewport = cornerstone.getViewport(element);
                if (viewport.invert === true) {
                    viewport.invert = false;
                } else {
                    viewport.invert = true;
                }
                cornerstone.setViewport(element, viewport);
            }

            if (procType == "wwwc" || procType == "pan" || procType == "zoom" || procType == "rotate") {
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);
            }

        }

    });
}

/*
 * 对当前选中图像所在序列处理事件
 * */
function procSeri(procType) {
    removeAllsyn();//移除所有element的同步
    var elementSeNo;
    var selectorStr;
    $(".imgViewportSelected").each(function (k, val) {
        if ($(this).attr("imgIn") == "true") {
            elementSeNo = $(".imgViewportSelected").attr('seNo');
            selectorStr = "div[seNo=" + elementSeNo + "]";
            return;
        }
    });


    $(selectorStr).each(function () {
        var elementId = $(this).attr('id');
        var element = $("#" + elementId).get(0);
        if ($("#" + elementId).attr('imgIn') == "true") {
            disableAllToolsP(element);
            if (procType == "reset") {
                cornerstone.reset(element);
            }
            else if (procType == "hflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.vflip = !viewport.vflip;
                }
                else{
                    viewport.hflip = !viewport.hflip;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "vflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.hflip = !viewport.hflip;
                }
                else{
                    viewport.vflip = !viewport.vflip;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "rrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation + 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "lrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation - 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "invert") {
                var viewport = cornerstone.getViewport(element);
                if (viewport.invert === true) {
                    viewport.invert = false;
                } else {
                    viewport.invert = true;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "wwwc" || procType == "pan" || procType == "zoom" || procType == "rotate") {

                addSerisyn(procType, elementSeNo);
                // cornerstone.enable(element);
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);//只是把该操作使能了，但没有同步更新
                // fillImgWWWL(elementId);
            }

        }
    });

}

/*
 * 对当前页所有图像处理事件
 * */
function procPage(procType) {
    removeAllsyn();//移除之前的同步操作
    var curPageId = "page" + printStruct.printpage.pageIndex;
    $("#" + curPageId).find('.printViewport').each(function (k, val) {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            disableAllToolsP(element);
            if (procType == "reset") {
                cornerstone.reset(element);
            }
            else if (procType == "hflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.vflip = !viewport.vflip;
                }
                else{
                    viewport.hflip = !viewport.hflip;
                }

                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "vflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.hflip = !viewport.hflip;
                }
                else{
                    viewport.vflip = !viewport.vflip;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "rrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation + 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "lrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation - 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "invert") {
                var viewport = cornerstone.getViewport(element);
                if (viewport.invert === true) {
                    viewport.invert = false;
                } else {
                    viewport.invert = true;
                }
                cornerstone.setViewport(element, viewport);
            }

            else if (procType == "wwwc" || procType == "pan" || procType == "zoom" || procType == "rotate") {
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);
            }

        }
    });
}

/*
 * 对所有图像的处理事件
 * */
function procAll(procType) {
    removeAllsyn();//移除之前的同步操作//移除所有element的同步
    $(".printViewport").each(function () {
        var elementId = $(this).attr('id');
        var element = $("#" + elementId).get(0);
        if ($(this).attr('imgIn') == "true") {
            // disableAllToolsP(element);
            if (procType == "reset") {
                cornerstone.reset(element);
            }
            else if (procType == "hflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.vflip = !viewport.vflip;
                }
                else{
                    viewport.hflip = !viewport.hflip;
                }

                cornerstone.setViewport(element, viewport);

            }
            else if (procType == "vflip") {
                var viewport = cornerstone.getViewport(element);
                var changeFlag=false;
                if(viewport.rotation==90||viewport.rotation==-90||viewport.rotation==270||viewport.rotation==-270){
                    changeFlag=true;
                }
                if(changeFlag){
                    viewport.hflip = !viewport.hflip;
                }
                else{
                    viewport.vflip = !viewport.vflip;
                }
                cornerstone.setViewport(element, viewport);

            }
            else if (procType == "rrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation + 90) % 360;
                cornerstone.setViewport(element, viewport);

            }
            else if (procType == "lrotate") {
                var viewport = cornerstone.getViewport(element);
                viewport.rotation = (viewport.rotation - 90) % 360;
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "invert") {
                var viewport = cornerstone.getViewport(element);
                if (viewport.invert === true) {
                    viewport.invert = false;
                } else {
                    viewport.invert = true;
                }
                cornerstone.setViewport(element, viewport);
            }
            else if (procType == "wwwc" || procType == "pan" || procType == "zoom" || procType == "rotate") {
                addAllsyn(procType);
                cornerstoneTools.mouseInput.enable(element);
                cornerstoneTools.mouseWheelInput.enable(element);
                cornerstoneTools[procType].activate(element, 1);
            }

        }
    });
}

/*
 *  选中图像操作同步
 *  */
function imgViewportSyn(procType) {
    var viewport;
    var ww, wc, pan, zoom;
    var translation, scale, rotation;
    var wFlag = false;
    $(".procHandle").each(function () {

        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            // var viewport = cornerstone.getViewport(element);
            viewport = deepCopy1(cornerstone.getViewport(element));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);
            translation = viewport.translation;
            scale = viewport.scale;
            rotation = viewport.rotation;
            wFlag = true;
            return;
        }
    });
    if (wFlag == true) {
        //wwwc
        if (procType == "wwwc") {
            $(".imgViewportSelected").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    fillImgWWWL(elementId);//同步信息中的窗位窗宽
                }
            });
        }
        //pan
        else if (procType == "pan") {
            $(".imgViewportSelected").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.translation = translation;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
        // zoo
        else if (procType == "zoom") {
            $(".imgViewportSelected").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.scale = scale;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
        else if (procType == "rotate") {
            $(".imgViewportSelected").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.rotation = rotation;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
    }
}

/*
 * 序列图像窗口同步
 * */
function seriViewportSyn(procType) {
    var viewport;
    var ww, wc, pan, zoom;
    var translation, scale, rotation;
    var wFlag = false;
    var elementSeNo;
    var selectorStr;
    $(".imgViewportSelected").each(function () {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            viewport = deepCopy1(cornerstone.getViewport(element));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);
            translation = viewport.translation;
            scale = viewport.scale;
            rotation = viewport.rotation;
            wFlag = true;
            elementSeNo = $(this).attr('seNo');
            selectorStr = "div[seNo=" + elementSeNo + "]";
            return;
        }
    });
    if (wFlag == true) {
        //wwwc
        if (procType == "wwwc") {
            $(selectorStr).each(function () {
                //把图像所在页show出来
                $(selectorStr).parents('.printPage').show();
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                    fillImgWWWL(elementId);
                }
            });
        }
        //pan
        else if (procType == "pan") {
            $(selectorStr).each(function () {
                //把图像所在页show出来
                $(selectorStr).parents('.printPage').show();
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.translation = translation;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                }
            });
        }
        // zoo
        else if (procType == "zoom") {
            $(selectorStr).each(function () {
                //把图像所在页show出来
                $(selectorStr).parents('.printPage').show();
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.scale = scale;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                }
            });
        }
        // rotate
        else if (procType == "rotate") {
            $(selectorStr).each(function () {
                //把图像所在页show出来
                $(selectorStr).parents('.printPage').show();
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.rotation = rotation;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                }
            });
        }
        showPrintPage(printStruct.printpage.pageIndex);//显示最初操作的页
    }
}

/*
 * 所有图像窗口同步
 * */
function allViewportSyn(procType) {
    var ww, wc;
    var translation, scale, rotation;
    var wFlag = false;
    var viewport;
    $(".imgViewportSelected").each(function () {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            // var viewport = cornerstone.getViewport(element);
            viewport = deepCopy1(cornerstone.getViewport(element));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);
            translation = viewport.translation;
            scale = viewport.scale;
            rotation = viewport.rotation;
            wFlag = true;
            return;
        }
    });

    if (wFlag == true) {
        if (procType == "wwwc") {
            $(".printViewport").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    //把图像所在页show出来
                    $(".printViewport").parents('.printPage').show();
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                    fillImgWWWL(elementId);
                }
            });
        }
        else if (procType == "pan") {
            $(".printViewport").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    //把图像所在页show出来
                    $(".printViewport").parents('.printPage').show();
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.translation = translation;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                    var imageId = $(this).attr('imageId');
                }
            });
        }
        else if (procType == "zoom") {
            $(".printViewport").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    //把图像所在页show出来
                    $(".printViewport").parents('.printPage').show();
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.scale = scale;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                }
            });
        }
        else if (procType == "rotate") {
            $(".printViewport").each(function () {
                if ($(this).attr('imgIn') == "true") {
                    //把图像所在页show出来
                    $(".printViewport").parents('.printPage').show();
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.rotation = rotation;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                }
            });
        }
    }
    showPrintPage(printStruct.printpage.pageIndex);//显示最初操作的页
}

/*
 * 当前页的窗口同步
 * */
function pageViewportSyn(procType) {
    var ww, wc;
    var translation, scale, rotation;
    var wFlag = false;
    var curPageId = "page" + printStruct.printpage.pageIndex;
    $(".imgViewportSelected").each(function () {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            // var viewport = cornerstone.getViewport(element);
            var viewport = deepCopy1(cornerstone.getViewport(element));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);
            translation = viewport.translation;
            scale = viewport.scale;
            rotation = viewport.rotation;
            wFlag = true;
            return;
        }
    });
    if (wFlag == true) {
        if (procType == "wwwc") {
            $("#" + curPageId).find(".printViewport").each(function (k, val) {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    // cornerstone.resize(element, true);
                    fillImgWWWL(elementId);
                }
            });
        }
        else if (procType == "pan") {
            $("#" + curPageId).find(".printViewport").each(function (k, val) {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.translation = translation;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
        else if (procType == "zoom") {
            $("#" + curPageId).find(".printViewport").each(function (k, val) {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.scale = scale;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
        else if (procType == "rotate") {
            $("#" + curPageId).find(".printViewport").each(function (k, val) {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.rotation = rotation;
                    cornerstone.setViewport(element, viewport);
                }
            });
        }
    }
}

/*
 * 同步打印胶片中的图像与页面中图像的操作状态
 * 最终打印胶片时调用
 * */
function enableAllMeasureTools(element, elementId) {
    // console.log(elementId);
    cornerstoneTools.length.enable(element);
    cornerstoneTools.ellipticalRoi.enable(element);
    cornerstoneTools.rectangleRoi.enable(element);
    cornerstoneTools.angle.enable(element);
    cornerstoneTools.arrowAnnotate.enable(element);
    cornerstoneTools.textMarker.enable(element);

    if ($("#" + elementId).attr('referLine') == "true") {
        var printSynchronizer = new cornerstoneTools.Synchronizer("CornerstoneNewImage", cornerstoneTools.updateImageSynchronizer);
        $('.printViewport').each(function () {
            var elementId = $(this).attr('id');
            if ($("#" + elementId).attr('imgIn') == "true") {
                var elementTemp = $("#" + elementId).get(0);
                printSynchronizer.add(elementTemp);//这里改写过，
            }
        });
        printStruct.enableReferenceLines(element, printSynchronizer);
    }
}

//右键默认调窗
function allowWwwlMouseR() {
    var curPageId = "page" + printStruct.printpage.pageIndex;
    $("#" + curPageId).find('.printViewport').each(function (k, val) {
        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            cornerstoneTools.mouseInput.enable(element);
            cornerstoneTools.mouseWheelInput.enable(element);
            cornerstoneTools["wwwc"].activate(element, 4);
        }
    });
}
/**
 * Created by SongJing on 2017/3/28.
 * 快捷调窗相关方法
 */

printStruct.wwwcObjArr;
printStruct.procObj = "procImg";


//显示窗位窗宽
function wwwlShow(modalityVal, code) {
    console.log(modalityVal, code);
    $.ajax({
        type: 'post',
        data: {
            opt: 'GetWSet',
            code: code,
            modality: modalityVal
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            // console.log(data);
            var json = eval('(' + data + ')');
            if (json.result == true) {
                var table1 = $('.table2 tbody');

                table1.empty();
                $.each(json.message, function (key, val) {


                    var td4 = $('<td class="name"></td>').append(val.Name);
                    var td5 = $('<td class="wl"></td>').append(val.WL);
                    var td6 = $('<td class="ww"></td>').append(val.WW);
                    var td7 = '';

                    if (parseInt(key) < 10) {
                        // td7 = $('<td class="txt">shift+' + parseInt(key) + '</td>');
                        td7 = $('<td class="txt">Alt+' + parseInt(key) + '</td>');//调窗快捷键名称
                    }
                    else {
                        td7 = $('<td class="txt"></td>');
                    }

                    var tr1 = $('<tr  data-id="' + val.IID + '"></tr>');
                    tr1.append(td4, td5, td6, td7);
                    table1.append(tr1);
                });


            }
        }
    });
}
//删除窗位信息
function deletewwwlInfo(id, code) {
    $.ajax({
        type: 'post',
        data: {
            opt: 'DelWSet',
            code: code,
            id: id
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            var json = eval('(' + data + ')');
            if (json.result == true) {
                typeChange(code);
                wwwlShow(Modality, code);
                pop_up({title: "提示", message: "删除成功", yesName: "确定", noName: "取消"});

            }
        }
    });
}
//添加窗位窗宽信息
function addwwwlInfo(opt, id, code) {
    var device = $('.device1').val();
    var wlInput = $('.wlInput').val();
    var wwInput = $('.wwInput').val();
    var modifyName = $('.modifyName').val();
    $.ajax({
        type: 'post',
        data: {
            opt: opt,
            code: code,
            id: id,
            modality: device,
            name: modifyName,
            wl: wlInput,
            ww: wwInput

        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            var json = eval('(' + data + ')');
            if (json.result == true) {
                clearwwwl();
                cancel($('.wwwlSetBox'));
                pop_up({title: "提示", message: "操作成功", yesName: "确定", noName: "取消"});
                typeChange(code);
            }
            else {
                pop_up({title: "提示", message: "操作失败", yesName: "确定", noName: "取消"});
            }
        }
    });
}
//清空ww wwl
function clearwwwl() {
    $('.device1').val('CT');
    $('.wlInput').val('');
    $('.wwInput').val('');
    $('.modifyName').val('');
}


//显示窗位窗宽change
function typeChange(code) {
    var type = $('.device').val();

    $.ajax({
        type: 'post',
        data: {
            opt: 'GetWSet',
            code: code,
            modality: type
        },
        url: 'http://' + urlInit + '/DicomPrinter',
        success: function (data) {
            var json = eval('(' + data + ')');
            var table = $('.table1 tbody');
            table.empty();
            if (json.result == true) {

                $.each(json.message, function (key, val) {

                    var td = $('<td></td>').append(val.Name);
                    var td1 = $('<td></td>').append(val.WL);
                    var td2 = $('<td></td>').append(val.WW);
                    var td3 = '';
                    // console.log(td);
                    // console.log(td1);
                    // console.log(td2);
                    // console.log(td3);
                    /* if (parseInt(key + 1) >= 5 && parseInt(key + 1) <= 10) {
                     td3 = $('<td>ctrl+F' + parseInt(key + 2) + '</td>');
                     }
                     else if (parseInt(key + 1) > 10) {
                     td3 = $('<td></td>');
                     }
                     if (parseInt(key + 1) < 5) {
                     td3 = $('<td>ctrl+F' + parseInt(key + 1) + '</td>');
                     }*/
                    if (parseInt(key) < 10) {
                        // td3 = $('<td>shift+' + parseInt(key) + '</td>');
                        td3 = $('<td>Alt+' + parseInt(key) + '</td>');
                    }
                    else {
                        td3 = $('<td class="txt"></td>');
                    }

                    var tr = $('<tr  data-id="' + val.IID + '"></tr>');

                    tr.append(td, td1, td2, td3);
                    table.append(tr);
                });


            }
            else {
                var td = $('<td></td>').append(json.message);
                var tr = $('<tr></tr>').append(td);
                table.append(tr);
            }
        }
    });

}

function getWWWL() {
    var wwwcObjArr = [];
    var wwwcObj = {
        name: "请选择",
        wc: "",
        ww: ""
    };
    wwwcObjArr.push(wwwcObj);//添加一个默认值用于初始显示

    $('.table1Body').children().each(function () {
        // console.log($(this));
        var wwwcObj = {
            name: "请选择",
            wc: 0,
            ww: 0
        };
        wwwcObj.name = $(this).children().eq(0).text();
        wwwcObj.wc = $(this).children().eq(1).text();
        wwwcObj.ww = $(this).children().eq(2).text();
        wwwcObjArr.push(wwwcObj);
    });
    // console.log(wwwcObjArr);
    //值同步填充
    if (wwwcObjArr.length > 0) {
        var domNode = $('#printSetwwwc');
        domNode.empty();
        // var html0="<option>请选择</option>";
        // domNode.append(html0);
        for (var i = 0,len=wwwcObjArr.length; i < len; i++) {
            var html = "<option>" + wwwcObjArr[i].name + "</option>";
            domNode.append(html);//设置初始值
        }

        //设置初始值
        $('#printSetww').val(wwwcObjArr[0].ww);
        $('#printSetwc').val(wwwcObjArr[0].wc);
        printStruct.wwwcObjArr = wwwcObjArr;
    }
}

//打印页面的快捷调窗
function enterBtnInner(name) {

    if (printStruct.openFlag == true) {
        $('.table2Body tr .txt').each(function () {
            if ($(this).text() == name) {
                var wc = parseInt($(this).parents('tr').find('.wl').text());
                var ww = parseInt($(this).parents('tr').find('.ww').text());
                console.log("快捷调窗in：", ww, wc);
                if (!isNaN(ww) && !isNaN(wc)) {
                    // dvStruct.fun.wwwc(ww, wc);

                    //如果有选中的图像就调节选择的图像
                    if ($('.imgViewportSelected ').attr('imgIn') == "true") {
                        console.log("调选中图像");
                        $('.imgViewportSelected ').each(function () {
                            if ($(this).attr('imgIn') == "true") {
                                var elementId = $(this).attr('id');
                                var element = $("#" + elementId).get(0);

                                var viewport = cornerstone.getViewport(element);
                                viewport.voi.windowWidth = ww;
                                viewport.voi.windowCenter = wc;
                                cornerstone.setViewport(element, viewport);
                                fillImgWWWL(elementId);

                            }
                        });
                    }
                    //    如果没有选中的图像就调节当前页中的图像
                    else {
                        console.log("调页");
                        var curPageId = "page" + printStruct.printpage.pageIndex;
                        $("#" + curPageId).find('.printViewport').each(function () {
                            if ($(this).attr('imgIn') == "true") {
                                var elementId = $(this).attr('id');

                                var element = $("#" + elementId).get(0);
                                var viewport = cornerstone.getViewport(element);
                                viewport.voi.windowWidth = ww;
                                viewport.voi.windowCenter = wc;
                                cornerstone.setViewport(element, viewport);
                                fillImgWWWL(elementId);

                            }
                        });
                    }
                }

            }
        });
    }

}


//快捷键调窗（外层页面的调窗）
function enterBtn(name) {
 
    // if (isWWWL()) {
    $('.table2Body tr .txt').each(function () {
        if ($(this).text() == name) {
            var wc = parseInt($(this).parents('tr').find('.wl').text());
            var ww = parseInt($(this).parents('tr').find('.ww').text());
            console.log("快捷调窗out：", ww, wc);
            if (!isNaN(ww) && !isNaN(wc)) {
                $('.widthInput').val(ww);
                $('.centerInput').val(wc);
                dvStruct.fun.wwwc(ww, wc);
            }

        }
    });
    // }
}


//调窗对象为选择对象
function printQucikwwwc(ww, wc, procObj) {
    // console.log("调窗-------------");
    //  console.log(ww, wc,procObj);
    switch (procObj) {
        case "procImg":
            $('.imgViewportSelected').each(function () {
                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    var imageId = $(this).attr('imageId');
                    fillImgWWWL(elementId);
                }
            });
            break;
        case "procSeri":
            $(".imgViewportSelected").each(function () {
                var elementSeNo = $(this).attr('seNo');
                var selectorStr = "div[seNo=" + elementSeNo + "]";
                $(selectorStr).each(function () {

                    if ($(this).attr('imgIn') == "true") {
                        var elementId = $(this).attr('id');
                        var element = $("#" + elementId).get(0);
                        var viewport = cornerstone.getViewport(element);
                        viewport.voi.windowWidth = ww;
                        viewport.voi.windowCenter = wc;
                        cornerstone.setViewport(element, viewport);
                        var imageId = $(this).attr('imageId');
                        fillImgWWWL(elementId);
                    }
                });
            });
            break;
        case "procPage":
            var curPageId = "page" + printStruct.printpage.pageIndex;
            $("#" + curPageId).find('.printViewport').each(function () {


                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    var imageId = $(this).attr('imageId');
                    fillImgWWWL(elementId);
                }

            });
            break;
        case "procAll":
            $(".printViewport").each(function () {


                if ($(this).attr('imgIn') == "true") {
                    var elementId = $(this).attr('id');
                    var element = $("#" + elementId).get(0);
                    var viewport = cornerstone.getViewport(element);
                    viewport.voi.windowWidth = ww;
                    viewport.voi.windowCenter = wc;
                    cornerstone.setViewport(element, viewport);
                    var imageId = $(this).attr('imageId');
                    fillImgWWWL(elementId);
                }
            });
            break;
        default :
            break;
    }
}


/*
 *判断是否进行调窗
 * */
function isWWWL() {

    //排除页面上的input输入
    if (document.activeElement.id == 'widthInput' || document.activeElement.id == 'centerInput') {
        return false;
    }

    if ($(".wwwlSetBox").is(":hidden") && $("#printMain").is(":hidden")) {
        return true;
    }
    else {
        return false;
    }
}


var printWWWL = false;
$(function () {

    //快捷键 Alt+(0-9)
    var direct="blank";//图像拼接

    document.onkeydown = function (event) {

        var name = "";
        var e = event || window.event || arguments.callee.caller.arguments[0];


        //图像拼接
        //左键 A
        if (  e.shiftKey&&e.keyCode == 37 || e.shiftKey&&e.keyCode == 65 ) { // 0
            direct="left";
        }
        //向上键 W
        if (  e.shiftKey&&e.keyCode == 38 || e.shiftKey&&e.keyCode == 87) { // 按 1
            direct="up";
        }
        //右键 D
        if ( e.shiftKey&&e.keyCode == 39 ||  e.shiftKey&&e.keyCode == 68) { // 按 2
            direct="right";
        }
        //向下键 S
        if (  e.shiftKey&&e.keyCode == 40 || e.shiftKey&&e.keyCode ==  83) {// 按 3
            direct="down";
        }
        positionAdjust(direct);



        if ((e.altKey && e.keyCode == 48) || (e.altKey && e.keyCode == 96)) { // 0
            name = 'Alt+0';
            enterBtn(name);
            enterBtnInner(name);

        }
        if ((e.altKey && e.keyCode == 49) || (e.altKey && e.keyCode == 97)) { // 按 1

            name = 'Alt+1';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 50) || (e.altKey && e.keyCode == 98)) { // 按 2

            name = 'Alt+2';
            enterBtn(name);
            enterBtnInner(name);
        }

        if ((e.altKey && e.keyCode == 51) || (e.altKey && e.keyCode == 99)) {// 按 3

            name = 'Alt+3';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 52) || (e.altKey && e.keyCode == 100)) {// 按 4

            name = 'Alt+4';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 53) || (e.altKey && e.keyCode == 101)) {

            name = 'Alt+5';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 54) || (e.altKey && e.keyCode == 102)) {

            name = 'Alt+6';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 55) || (e.altKey && e.keyCode == 103)) {

            name = 'Alt+7';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 56) || (e.altKey && e.keyCode == 104)) {

            name = 'Alt+8';
            enterBtn(name);
            enterBtnInner(name);
        }
        if ((e.altKey && e.keyCode == 57) || (e.altKey && e.keyCode == 105)) {
            name = 'Alt+9';
            enterBtn(name);
            enterBtnInner(name);
        }
        // console.log(name);
        if (e.shiftKey) { // shift 键
            printStruct.key.shiftDown = true;
            printStruct.key.ctrlDown = false;
        }
        else if (e.ctrlKey) { // ctrl 键
            printStruct.key.shiftDown = false;
            printStruct.key.ctrlDown = true;
        }
        else {
            printStruct.key.shiftDown = false;
            printStruct.key.ctrlDown = false;
        }

    };


    //判断胶片DIV是否获取鼠标焦点
    document.onclick = function (e) {
        if ($(e.target).hasClass("printPageBox") || $(e.target).parents(".printPageBox").length > 0) {
            printWWWL = true;

        }
        else {
            printWWWL = false;

        }
    };

    //快捷键 (0-9)
    /* document.onkeydown = function (event) {
     var e = event || window.event || arguments.callee.caller.arguments[0];


     //小键盘0-9
     if (e.keyCode == 96) {

     var name = '0';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 97) {
     var name = '1';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 98) {
     var name = '2';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 99) {
     var name = '3';
     enterBtn(name);
     enterBtnInner(name);
     }

     if (e.keyCode == 100) {
     var name = '4';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 101) {
     var name = '5';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 102) {
     var name = '6';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 103) {
     var name = '7';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 104) {
     var name = '8';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 105) {
     var name = '9';
     enterBtn(name);
     enterBtnInner(name);
     }
     //数字按键0-9
     if (e.keyCode == 48) {

     var name = '0';
     enterBtn(name);
     enterBtnInner(name);

     }
     if (e.keyCode == 49) {
     var name = '1';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 50) {
     var name = '2';
     enterBtn(name);
     enterBtnInner(name);
     }

     if (e.keyCode == 51) {
     var name = '3';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 52) {
     var name = '4';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 53) {
     var name = '5';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 54) {
     var name = '6';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 55) {
     var name = '7';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 56) {
     var name = '8';
     enterBtn(name);
     enterBtnInner(name);
     }
     if (e.keyCode == 57) {
     var name = '9';
     enterBtn(name);
     enterBtnInner(name);
     }

     if (e.shiftKey) { // shift 键
     printStruct.key.shiftDown = true;
     printStruct.key.ctrlDown = false;
     }
     else if (e.ctrlKey) { // ctrl 键
     printStruct.key.shiftDown = false;
     printStruct.key.ctrlDown = true;
     }
     else {
     printStruct.key.shiftDown = false;
     printStruct.key.ctrlDown = false;
     }

     };
     */

    document.onkeyup = function (event) {
        printStruct.key.shiftDown = false;
        printStruct.key.ctrlDown = false;
        direct="blank";
    };
});
if (!Modality) {
    var Modality = "none";
}
/**
 * Created by SongJing on 2017/3/29.
 * 页面中显示的信息
 *
 */


//初始化页面显示四角信息控制对象
function initinfoScreenArr(code) {
    $.ajax({
        type: 'post',
        data: {
            opt: 'showTags',
            code: code
        },
        url: 'http://' + urlInit + '/SetTags',
        success: function (data) {
            if (data.length > 0) {
                emptyInfoScreenArr();//清空
                console.log("初始化页面显示四角信息控制对象");
                var json = eval('(' + data + ')');
                console.log(json);

                $.each(json, function (key, val) {
                    if (val.data == "lt") {
                        infoScreenArr.ltInfo.push(infoDic[val.title]);
                    }
                    else if (val.data == "lb") {
                        infoScreenArr.lbInfo.push(infoDic[val.title]);
                    }
                    else if (val.data == "rt") {
                        infoScreenArr.rtInfo.push(infoDic[val.title]);
                    }
                    else if (val.data == "rb") {
                        infoScreenArr.rbInfo.push(infoDic[val.title]);
                    }
                });
                console.log("infoScreenArr");
                console.log(infoScreenArr)
            }
        },
        error: function () {
            console.log("初始化页面显示四角信息控制对象失败！");
        }
    });

}
//根据设置添加信息层
function addInfoLay(viewportId) {
    var viewPortDom = $("#" + viewportId);
    //lt
    var lthtml = $("<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'></div>");
    viewPortDom.append(lthtml);
    for (var i = 0,len=infoScreenArr.ltInfo.length; i < len; i++) {
        var info = "<div class='" + infoScreenArr.ltInfo[i] + " print-info'></div>";
        lthtml.append(info);
    }
//lb
    var lbhtml = $("<div class='printOverlay printOverlay-lb ' style='bottom:0px; left:0px;text-align:left'></div>");
    viewPortDom.append(lbhtml);
    for (var i = 0,len=infoScreenArr.lbInfo.length; i <len ; i++) {
        var info = "<div class='" + infoScreenArr.lbInfo[i] + " print-info'></div>";
        lbhtml.append(info);
    }
//rt
    var rthtml = $("<div class='printOverlay printOverlay-rt ' style='top:0px; right:0px;text-align: right'></div>");
    viewPortDom.append(rthtml);
    for (var i = 0,len=infoScreenArr.rtInfo.length; i < len; i++) {
        var info = "<div class='" + infoScreenArr.rtInfo[i] + " print-info'></div>";
        rthtml.append(info);
    }
//rb
    var rbhtml = $("<div class='printOverlay printOverlay-rb ' style='bottom:0px; right:0px;text-align: right'></div>");
    viewPortDom.append(rbhtml);
    for (var i = 0,len=infoScreenArr.rbInfo.length; i < len; i++) {
        var info = "<div class='" + infoScreenArr.rbInfo[i] + " print-info'></div>";
        rbhtml.append(info);
    }

    //用个循环加变量来控制 4个角 每个角21条
    /*  for(var i=0;i<4;i++){
     for(var j=0;j<21;j++){
     }
     }
     */
    /* //左上标签信息
     var lthtml = "<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'>" +
     " <div class='print-info-lt1 print-info'></div>" +
     " <div class='print-info-lt2 print-info'></div>" +
     " <div class='print-info-lt3 print-info'></div>" +
     " <div class='print-info-lt4 print-info'></div>" +
     " <div class='print-info-lt5 print-info'></div>" +
     " <div class='print-info-lt6 print-info'></div>" +
     " <div class='print-info-lt7 print-info'></div>" +
     " <div class='print-info-lt8 print-info'></div>" +
     " <div class='print-info-lt9 print-info'></div>" +
     " <div class='print-info-lt10 print-info'></div>" +
     " <div class='print-info-lt11 print-info'></div>" +
     " <div class='print-info-lt12 print-info'></div>" +
     " <div class='print-info-lt13 print-info'></div>" +
     " <div class='print-info-lt14 print-info'></div>" +
     " <div class='print-info-lt15 print-info'></div>" +
     " <div class='print-info-lt16 print-info'></div>" +
     " <div class='print-info-lt17 print-info'></div>" +
     " <div class='print-info-lt18 print-info'></div>" +
     " <div class='print-info-lt19 print-info'></div>" +
     " <div class='print-info-lt20 print-info'></div>" +
     " <div class='print-info-lt21 print-info'></div>"
     "  </div> ";

     //右上标签信息
     var rthtml = "<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'>" +
     " <div class='print-info-rt1 print-info'></div>" +
     " <div class='print-info-rt2 print-info'></div>" +
     " <div class='print-info-rt3 print-info'></div>" +
     " <div class='print-info-rt4 print-info'></div>" +
     " <div class='print-info-rt5 print-info'></div>" +
     " <div class='print-info-rt6 print-info'></div>" +
     " <div class='print-info-rt7 print-info'></div>" +
     " <div class='print-info-rt8 print-info'></div>" +
     " <div class='print-info-rt9 print-info'></div>" +
     " <div class='print-info-rt10 print-info'></div>" +
     " <div class='print-info-rt11 print-info'></div>" +
     " <div class='print-info-rt12 print-info'></div>" +
     " <div class='print-info-rt13 print-info'></div>" +
     " <div class='print-info-rt14 print-info'></div>" +
     " <div class='print-info-rt15 print-info'></div>" +
     " <div class='print-info-rt16 print-info'></div>" +
     " <div class='print-info-rt17 print-info'></div>" +
     " <div class='print-info-rt18 print-info'></div>" +
     " <div class='print-info-rt19 print-info'></div>" +
     " <div class='print-info-rt20 print-info'></div>" +
     " <div class='print-info-rt21 print-info'></div>"
     "  </div> ";
     //左下签信息
     var lbhtml = "<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'>" +
     " <div class='print-info-lb1 print-info'></div>" +
     " <div class='print-info-lb2 print-info'></div>" +
     " <div class='print-info-lb3 print-info'></div>" +
     " <div class='print-info-lb4 print-info'></div>" +
     " <div class='print-info-lb5 print-info'></div>" +
     " <div class='print-info-lb6 print-info'></div>" +
     " <div class='print-info-lb7 print-info'></div>" +
     " <div class='print-info-lb8 print-info'></div>" +
     " <div class='print-info-lb9 print-info'></div>" +
     " <div class='print-info-lb10 print-info'></div>" +
     " <div class='print-info-lb11 print-info'></div>" +
     " <div class='print-info-lb12 print-info'></div>" +
     " <div class='print-info-lb13 print-info'></div>" +
     " <div class='print-info-lb14 print-info'></div>" +
     " <div class='print-info-lb15 print-info'></div>" +
     " <div class='print-info-lb16 print-info'></div>" +
     " <div class='print-info-lb17 print-info'></div>" +
     " <div class='print-info-lb18 print-info'></div>" +
     " <div class='print-info-lb19 print-info'></div>" +
     " <div class='print-info-lb20 print-info'></div>" +
     " <div class='print-info-lb21 print-info'></div>"
     "  </div> ";
     //右下标签信息
     var rbhtml = "<div class='printOverlay printOverlay-lt ' style='top:0px; left:0px;text-align:left'>" +
     " <div class='print-info-rb1 print-info'></div>" +
     " <div class='print-info-rb2 print-info'></div>" +
     " <div class='print-info-rb3 print-info'></div>" +
     " <div class='print-info-rb4 print-info'></div>" +
     " <div class='print-info-rb5 print-info'></div>" +
     " <div class='print-info-rb6 print-info'></div>" +
     " <div class='print-info-rb7 print-info'></div>" +
     " <div class='print-info-rb8 print-info'></div>" +
     " <div class='print-info-rb9 print-info'></div>" +
     " <div class='print-info-rb10 print-info'></div>" +
     " <div class='print-info-rb11 print-info'></div>" +
     " <div class='print-info-rb12 print-info'></div>" +
     " <div class='print-info-rb13 print-info'></div>" +
     " <div class='print-info-rb14 print-info'></div>" +
     " <div class='print-info-rb15 print-info'></div>" +
     " <div class='print-info-rb16 print-info'></div>" +
     " <div class='print-info-rb17 print-info'></div>" +
     " <div class='print-info-rb18 print-info'></div>" +
     " <div class='print-info-rb19 print-info'></div>" +
     " <div class='print-info-rb20 print-info'></div>" +
     " <div class='print-info-rb21 print-info'></div>"
     "  </div> ";*/

    /*viewPortDom.append(lthtml);
     viewPortDom.append(rthtml);
     viewPortDom.append(lbhtml);
     viewPortDom.append(rbhtml);*/
}
//添加编号层
function addBoxNoLay(viewportId) {
    var viewPortDom = $("#" + viewportId);
    var viewportNo = $("#" + viewportId).attr('No');
    var boxNoHtml = "<span class='viewportBoxNo' style='pointer-events:none;top:10px; left:10px; position: absolute;  color: #E9E7E2;text-align: center;font-size: 100%'>" + viewportNo + "</span>";

    viewPortDom.append(boxNoHtml);
}
//在屏幕上填充信息
function fillInfoOnLay(viewportId) {
    //无图像直接返回
    if ($("#" + viewportId).attr('imgIn') == "false") {
        return;
    }
    else if ($("#" + viewportId).find('.print-info').length == 0) {//如果没有信息层，添加信息层
        addInfoLay(viewportId);
        addBoxNoLay(viewportId);
    }

//添加信息或者更新信息
    var element = $("#" + viewportId).get(0);
    var viewport = deepCopy1(cornerstone.getViewport(element));
    // var ww = Math.round(viewport.voi.windowWidth);
    // var wl = Math.round(viewport.voi.windowCenter);
    var imageId = $("#" + viewportId).attr('imageId');
    var viewportBox = $("#" + viewportId);
    $(viewportBox).find('.printViewportNo').remove();//移除box编号
    //窗位窗宽
    $(viewportBox).find('.print-info-wwwl').text("WL/WW: " + Math.round(viewport.voi.windowCenter) + "/" + Math.round(viewport.voi.windowWidth));

    if ((imageId.indexOf("loadJoinImg") >= 0)) {
        //填充拼接图像的信息
        var joinIndex = parseInt(imageId.substring(14));//根据图像ID得到图像索引编号

        // console.log(joinOutputObj[joinIndex]);

        $(viewportBox).find('.print-info-PatientName').text(joinOutputObj[joinIndex].name);//sj change
        $(viewportBox).find('.print-info-PatientAgeSex').text(joinOutputObj[joinIndex].age + ' ' + joinOutputObj[joinIndex].sex);
        $(viewportBox).find('.print-info-PatientBirthDate').text(joinOutputObj[joinIndex].birthDate.substr(0, 4) + '/' + joinOutputObj[joinIndex].birthDate.substr(4, 2) + '/' + joinOutputObj[joinIndex].birthDate.substr(6, 2));
        $(viewportBox).find('.print-info-studyDate').text(joinOutputObj[joinIndex].studyDate.substr(0, 4) + '/' + joinOutputObj[joinIndex].studyDate.substr(4, 2) + '/' + joinOutputObj[joinIndex].studyDate.substr(6, 2));

        return;
    }
    else{
        var idInfo = getSuid(imageId);
        var suid = idInfo.suid;
        var seLength = idInfo.seriesLength;
        var info = printStruct.findOriInfoByIds(imageId, suid);
        if (_.isUndefined(info))return;
        var sNo = printStruct.countSNo(suid);

        try {

            //T L
            if (info.SeriesInfo.SliceThickness.val) {
                var theT = info.SeriesInfo.SliceThickness.val;
                var theL = info.SeriesInfo.SliceLocation.val;
                $(viewportBox).find('.print-TL').text('T: ' + theT + 'mm L: ' + theL + 'mm');//这个跟专业软件显示得不一样呢，这个要算吧
            }
            //登记编号
            $(viewportBox).find('.print-info-accessionNum').text( info.PatientInfo.AccessionNumber.val);
            //图像张数据
            $(viewportBox).find('.print-info-nowNo').text('Im: ' + idInfo.imgIndex + '/' + seLength);

            //序列号
            $(viewportBox).find('.print-info-SeNo').text('Se: ' + sNo);
            //病人姓名
            if (info.PatientInfo.PatientName.val) {
                if (!dvStruct.share)//分享状态时不显示病人姓名
                {
                    $(viewportBox).find('.print-info-PatientName').text(info.PatientInfo.PatientName.val);//sj change
                }
            }
            //病人ID
            if (info.PatientInfo.PatientID.val) {
                $(viewportBox).find('.print-info-PatientID').text(info.PatientInfo.PatientID.val);
            }
            /* //病人性别
             if(info.PatientInfo.PatientSex.val){
             $(viewportBox).find('.print-info-PatientAgeSex').text(info.PatientInfo.PatientSex.val);
             }
             //病人年龄
             if(info.PatientInfo.PatientsAge.val){
             $(viewportBox).find('.print-info-PatientAge').text(' ' + info.PatientInfo.PatientsAge.val);
             }*/

            //病人年龄/性别
            if (info.PatientInfo.PatientsAge.val) {
                $(viewportBox).find('.print-info-PatientAgeSex').text(info.PatientInfo.PatientsAge.val + ' ' + info.PatientInfo.PatientSex.val);
            }
            //病人出生年月
            if (info.PatientInfo.PatientBirthDate.val) {
                var birth = info.PatientInfo.PatientBirthDate.val;
                $(viewportBox).find('.print-info-PatientBirthDate').text(birth.substr(0, 4) + '/' + birth.substr(4, 2) + '/' + birth.substr(6, 2));
            }
            //机构名称
            if (info.EquipmentInfo.InstitutionName.val) {
                if (!dvStruct.share)//分享状态时不显示医院名称
                {
                    $(viewportBox).find('.print-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);
                }
            }

            // $(viewportBox).find('.print-info-InstitutionName').text(info.EquipmentInfo.InstitutionName.val);
            // $(viewportBox).find('.print-info-ProtocolName').text(info.StudyInfo.ProtocolName.val);

//        检查描述
            if (info.StudyInfo.StudyDescription.val) {
                $(viewportBox).find('.print-info-StudyDescription').text(info.StudyInfo.StudyDescription.val);
            }

            //        检查部位
            if (info.StudyInfo.ProtocolName.val) {
                $(viewportBox).find('.print-info-ProtocolName').text(info.StudyInfo.ProtocolName.val);
            }

            //mA
            /* if (info.SomeUsefulInfo.mA.val) {
             $(viewportBox).find('.print-info-mA').text(info.SomeUsefulInfo.mA.val + 'mA');
             }*/
            //mA kvp
            if (info.SomeUsefulInfo.kvp.val) {
                $(viewportBox).find('.print-info-mAkvp').text(info.SomeUsefulInfo.kvp.val + 'kV ' + info.SomeUsefulInfo.mA.val + 'mA');
            }
            //CBZ
            var backInfo = searchBackInfo(info.UIDS.InstanceUID.val);
            if (backInfo) {
                $(viewportBox).find('.print-info-CBZ').text(backInfo.CBZ);
            }
            //FOV
            if (info.ImageInfo.FieldofView.val) {
                //field of view 扫描视野 0018,0094
                $(viewportBox).find('.print-info-fov').text('FOV:' + parseFloat(info.ImageInfo.FieldofView.val).toFixed(1));
            }
            //FS
            if (info.SomeUsefulInfo.MagneticFieldStrength.val) {
                $(viewportBox).find('.print-info-MagneticFieldStrength').text('FS: ' + info.SomeUsefulInfo.MagneticFieldStrength.val);
            }
            //TR TE
            if (info.SomeUsefulInfo.RepetitionTime.val || info.SomeUsefulInfo.RepetitionTime.val) {
                $(viewportBox).find('.print-info-TrTe').text('TR: ' + info.SomeUsefulInfo.RepetitionTime.val + ' TE: ' + info.SomeUsefulInfo.EchoTime.val);
            }
            //检查日期
            var date = info.StudyInfo.StudyDate.val.toString();
            if (date) {
                $(viewportBox).find('.print-info-studyDate').text(date.substr(0, 4) + '/' + date.substr(4, 2) + '/' + date.substr(6, 2));
            }
            //检查时间
            var time = info.StudyInfo.StudyTime.val.toString();
            if (time) {
                $(viewportBox).find('.print-info-studyTime').text(time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(2, 2));
            }


            //图像位置
            if (info.ImageInfo.ImagePositionPatient.val) {
                $(viewportBox).find('.print-info-imgPosition').text(info.ImageInfo.ImagePositionPatient.val);
            }
            //图像方位
            if (info.ImageInfo.ImageOrientationPatient.val) {
                $(viewportBox).find('.print-info-imgOriention').text(info.ImageInfo.ImageOrientationPatient.val);
            }
            //检查模态
            if (info.SeriesInfo.Modality.val) {
                $(viewportBox).find('.print-info-modality').text(info.SeriesInfo.Modality.val);
            }
            //采样率
            if (info.ImageInfo.SamplesPerPixel.val) {
                $(viewportBox).find('.print-info-samplesP').text(info.ImageInfo.SamplesPerPixel.val);
            }
            //层间距
            if (info.SeriesInfo.SpacingBetweenSlices.val) {
                $(viewportBox).find('.print-info-SpacingBetweenSlices').text('层间距:' + info.SeriesInfo.SpacingBetweenSlices.val + "mm");
            }

        }
        catch (e) {
            console.log("screen info error");
        }
    }


}
//在屏幕上添加窗位窗宽信息
function fillImgWWWL(elementId) {
    if ($("#" + elementId).attr('imgIn') == "true") {
        var element = $("#" + elementId).get(0);
        var viewport = deepCopy1(cornerstone.getViewport(element));
        // var viewport = cornerstone.getViewport(element);
        var viewportBox = $("#" + elementId);
        $(viewportBox).find('.print-info-wwwl').text("WL/WW: " + Math.round(viewport.voi.windowCenter) + "/" + Math.round(viewport.voi.windowWidth));
        // $(wrapperBox).find('.printViewportNo').remove();
    }
}

/*
 * 图像框编号与信息层的隐藏与显示
 * 已填充图像隐藏编号
 * 无填充图像隐藏信息层
 * */
function removeInnerboxNo() {
    $("div[imgIn=true]").find('.viewportBoxNo').hide();
    // $('.printViewportInner').parents('.printWrapper').find('.viewportBoxNo').hide();
    $("div[imgIn=false]").find('.viewportBoxNo').show();
    $("div[imgIn=false]").find('.printOverlay').hide();
    infoLayShow();
}

/*
 * 比较信息层的高宽和图像框的高宽 自动显示或隐藏
 * */
function infoLayShow() {
    $("div[imgIn=true]").each(function (k, val) {

        var viewportH = $(this).height();
        var viewportW = $(this).width();

        var leftH = $(this).find('.printOverlay-lt ').height() + $(this).find('.printOverlay-lb ').height();
        var rightH = $(this).find('.printOverlay-rt ').height() + $(this).find('.printOverlay-rb ').height();

        var topW = $(this).find('.printOverlay-lt ').width() + $(this).find('.printOverlay-rt ').width();
        var bottomW = $(this).find('.printOverlay-lb ').width() + $(this).find('.printOverlay-rb ').width();

        var infoH = Math.max(leftH, rightH);
        var infoW = Math.max(topW, bottomW);
        if (infoH > viewportH || infoW > viewportW) {
            $(this).find('.printOverlay').hide();
        }
        else {
            $(this).find('.printOverlay').show();
        }
    });
}

/**
 * Created by SongJing on 2017/3/28.
 * 服务文件下载
 */
//下载打印服务
function downloadPrintServe() {
    var triggerDownload = $("<a>").attr("href", "ipacsdv/iindaServiceFile/printService.zip").attr("download", "PrintService.zip").appendTo("body");
    triggerDownload[0].click();
    triggerDownload.remove();
}
//下载3D服务
function downloadPrintServeVR() {
    var triggerDownload = $("<a>").attr("href", "ipacsdv/iindaServiceFile/3dService.zip").attr("download", "3dService.zip").appendTo("body");
    triggerDownload[0].click();
    triggerDownload.remove();
}
/**
 * Created by Administrator on 2016/12/7.
 * socket连接验证
 * socket连接验证
 */
/*
* socket 连接错误提示
* 胶片打印服务的错误提示
* */
function socketConnectionTips(errorType) {
    switch (errorType) {
        case -1:
            //window.confirm("-1浏览器不支持服务，推荐使用谷歌浏览器，\r\t360极速浏览器（极速模式），搜狗浏览器（极速模式）!");

            pop_up({
                title: "打印服务连接提示",
                message: "tips1:浏览器不支持服务，推荐使用谷歌浏览器，\r\t360极速浏览器（极速模式），搜狗浏览器（极速模式）!",
                yesName: "确定",
                noName: "取消"
            });
            // downloadPrintServe();

            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 3:

            pop_up({
                title: "打印服务连接提示",
                message: "tips2:下载服务连接失败,请检查服务是否正确安装并打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！",
                ok: downloadPrintServe,
                yesName: "确定",
                noName: "取消"
            });

            // var servDown= window.confirm("3服务连接失败,请检查服务是否正确安装，或打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！");
            // downloadPrintServe();


            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 2:

            pop_up({
                title: "打印服务连接提示",
                message: "tips3:下载服务连接失败,请检查服务是否正确安装并打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！",
                ok: downloadPrintServe,
                yesName: "确定",
                noName: "取消"
            });
            // var servDown= window.confirm("服务连接失败,请检查服务是否正确安装，或打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！");

            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 1:

            break;
        default:
            window.confirm("default");

            break;
    }


}

/*
 * socket 连接错误提示
 * 三维服务的错误提示
 * */
function socketConnectionTipsVR(errorType) {
    switch (errorType) {
        case -1:
            //window.confirm("-1浏览器不支持服务，推荐使用谷歌浏览器，\r\t360极速浏览器（极速模式），搜狗浏览器（极速模式）!");

            pop_up({
                title: "VR提示",
                message: "tips1:浏览器不支持服务，推荐使用谷歌浏览器，\r\t360极速浏览器（极速模式），搜狗浏览器（极速模式）!",
                yesName: "确定",
                noName: "取消"
            });
            // downloadPrintServe();

            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 3:

            pop_up({
                title: "VR提示",
                message: "tips2:请启动IpacsVR服务并检查端口配置。\r\t下载该服务请点击确定按钮！",
                ok: downloadPrintServeVR,
                yesName: "确定",
                noName: "取消"
            });

            // var servDown= window.confirm("3服务连接失败,请检查服务是否正确安装，或打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！");
            // downloadPrintServe();


            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 2:

            pop_up({
                title: "VR服务提示",
                message: "tips3:请启动IpacsVR服务并检查端口配置。\r\t下载该服务请点击确定按钮！",
                ok: downloadPrintServeVR,
                yesName: "确定",
                noName: "取消"
            });
            // var servDown= window.confirm("服务连接失败,请检查服务是否正确安装，或打开。\r\t如未安装服务请先安装该服务再进入胶片打印页面。\r\t下载该服务请点击确定按钮！");

            if (window.stop)
                window.stop();
            else
                document.execCommand("Stop");
            break;
        case 1:

            break;
        default:
            window.confirm("default");

            break;
    }


}

/*
 * socket 发送数据
 * 发送胶片打印数据
 * */
function sendDataPrint(socket,data,row,col, printDirection, sizeType, copys, IP, port, AET, AETLocal, filmObj, filmType, quality, grayEnable,magnifyType) {

    var serviceType="print";
    var printSetStr="serviceType:" + serviceType+"#orientation:" + printDirection + "#filmSize:" + sizeType + "#copys:" + copys + "#IP:" + IP + "#port:" + port + "#AET:" + AET +
        "#localAET:" + AETLocal +
        "#filmObj:" + filmObj + "#filmType:" + filmType + "#quality:" + quality + "#grayEnable:" + grayEnable+"#magnifyType:"+magnifyType;


  /*  var printSetStr ="orientation:" + printDirection + "#filmSize:" + sizeType + "#copys:" + copys + "#IP:" + IP + "#port:" + port + "#AET:" + AET +
        "#localAET:" + AETLocal +
        "#filmObj:" + filmObj + "#filmType:" + filmType + "#quality:" + quality + "#grayEnable:" + grayEnable+"#magnifyType:"+magnifyType;*/

    console.log("打印机设置参数1："+printSetStr);

    // console.log(data);
    if (!socket) {
        pop_up({
            title: "打印服务连接提示",
            message: "tips4:创建链接失败，请下载打印服务!\r\t下载该服务请点击确定按钮！",
            ok: downloadPrintServe,//下载打印服务
            yesName: "确定",
            noName: "取消"
        });
        // downloadPrintServe();
        return;
    }
    if (socket.readyState != 1) {
        initWebSocket( dvStruct.localIP);
        setTimeout(function () {
            if (socket.readyState != 1) {
                pop_up({title: "打印服务连接提示", message: "tips5:链接服务失败，请检查打印服务是否开启!", yesName: "确定", noName: "取消"});
            } else {
                socket.send(printSetStr);
                socket.send(data);
                console.log("成功发送打印数据");
            }
        }, 1000)
    }
    else {
        socket.send(printSetStr);
        socket.send(data);
        console.log("成功发送打印数据");
    }
}


/**
 * Created by SongJing on 2017/3/28.
 * 四角信息设置
 */

/*
 * 获取四角信息设置
 * 从页面获取设置内容
 * */
function getTagSet() {
    emptyInfoScreenArr();
    var tagset = {
        ltTagset: [],
        lbTagset: [],
        rtTagset: [],
        rbTagset: []
    };
    $("#ltTags").find('.pull-left').each(function () {
        var tags = $(this).text();
        tagset.ltTagset.push(tags);
        infoScreenArr.ltInfo.push(infoDic[tags]);
    });
    $("#rtTags").find('.pull-left').each(function () {
        var tags = $(this).text();
        tagset.rtTagset.push(tags);
        infoScreenArr.rtInfo.push(infoDic[tags]);
    });
    $("#lbTags").find('.pull-left').each(function () {
        var tags = $(this).text();
        tagset.lbTagset.push(tags);
        infoScreenArr.lbInfo.push(infoDic[tags]);
    });
    $("#rbTags").find('.pull-left').each(function () {
        var tags = $(this).text();
        tagset.rbTagset.push(tags);
        infoScreenArr.rbInfo.push(infoDic[tags]);
    });
    return tagset;
}

/*
 * 初始化四角信息显示
 * 根据usercode从后台获取设置参数
 * */
function initShowTag(code) {

    $.ajax({
        type: 'post',
        data: {
            opt: 'showTags',
            code: code
        },
        url: 'http://' + urlInit + '/SetTags',
        success: function (data) {

            // console.log("data:",data);
            if (data.length > 0) {
                // emptyInfoScreenArr();
                console.log("初始化四角信息 ");
                var json = eval('(' + data + ')');
                console.log(json);

                var showNotDom = $('.selectBox');
                var ltTagsDom = $('#ltTags');
                var lbTagsDom = $('#lbTags');
                var rtTagsDom = $('#rtTags');
                var rbTagsDom = $('#rbTags');

                showNotDom.empty();
                ltTagsDom.empty();
                lbTagsDom.empty();
                rtTagsDom.empty();
                rbTagsDom.empty();


                $.each(json, function (key, val) {
                    var div = $('<div class="clearfix pull-right">' +
                        '<a class="moveUpBtn" href="javascript:;"><span class="delTit">上移</span></a>&nbsp;' +
                        '<a class="moveDownBtn" href="javascript:;"><span class="delTit">下移</span></a>&nbsp;' +
                        '<a class="deleteBtn" href="javascript:;"><span class="delTit">删除</span></a>' +
                        '</div>');
                    var span = $('<span class="pull-left"></span>').append(val.title);
                    var li = $('<li class="courseList"></li>');
                    li.append(span, div);
                    // console.log("==========1====================");
                    // console.log(val);
                    // debugger;
                    if (!("data" in val)) {
                        var li = $('<li></li>');
                        li.append(val.title);
                        $('.selectBox').append(li);
                    }
                    else if (val.data == "") {
                        var li = $('<li></li>');
                        li.append(val.title);
                        $('.selectBox').append(li);
                    }
                    else if (val.data == "lt") {
                        // console.log("lt----" + val.title);
                        ltTagsDom.append(li);
                        // infoScreenArr.ltInfo.push(val.desc);
                    }
                    else if (val.data == "lb") {
                        // console.log("lb----"+val.title);
                        lbTagsDom.append(li);
                        // infoScreenArr.lbInfo.push(val.desc);
                    }
                    else if (val.data == "rt") {
                        // console.log("rt----"+val.title);
                        rtTagsDom.append(li);
                        // infoScreenArr.rtInfo.push(val.desc);
                    }
                    else if (val.data == "rb") {
                        // console.log("rb----"+val.title);
                        rbTagsDom.append(li);
                        // infoScreenArr.rbInfo.push(val.desc);
                    }
                });
            }
        },
        error: function () {
            console.log("初始化四角信息显示失败！");
        }
    });

}

/*
 * 确认设置，根据usercode保存设置到后台
 * */
function tagsetOk(code) {
    console.log(code);

    var tagset = getTagSet();
    var selectedTag = [];
    $('.printTagSetbox').find('.selectBox li').each(function () {
        var tag = $(this).text();
        selectedTag.push(tag);
    });
    var tagsetObj = new Array;
    for (var i = 0,len=selectedTag.length; i < len; i++) {
        var tempObj = {
            visible: false,
            title: selectedTag[i],
            order: 0,
            data: ""
        };
        tagsetObj.push(tempObj);
    }

    for (var i = 0,len=tagset.ltTagset.length; i < len; i++) {
        var tempObj = {
            visible: true,
            title: tagset.ltTagset[i],
            order: i,
            data: "lt"
        };
        tagsetObj.push(tempObj);

    }
    for (var i = 0,len=tagset.lbTagset.length; i < len; i++) {
        var tempObj = {
            visible: true,
            title: tagset.lbTagset[i],
            order: i,
            data: "lb"
        };
        tagsetObj.push(tempObj);

    }
    for (var i = 0,len=tagset.rtTagset.length; i < len; i++) {
        var tempObj = {
            visible: true,
            title: tagset.rtTagset[i],
            order: i,
            data: "rt"
        };
        tagsetObj.push(tempObj);

    }
    for (var i = 0,len=tagset.rbTagset.length; i < len; i++) {
        var tempObj = {
            visible: true,
            title: tagset.rbTagset[i],
            order: i,
            data: "rb"
        };
        tagsetObj.push(tempObj);

    }
    // console.log(tagsetObj);
    var str = JSON.stringify(tagsetObj);
    console.log(str);
    $.ajax({
        type: 'post',
        data: {
            opt: 'saveSetting',
            data: str
        },
        url: 'http://' + urlInit + '/SetTags',
        success: function (data) {
            console.log("保存四角信息");
            console.log(data);
            pop_up({title: "提示", message: "保存成功", yesName: "确定", noName: "取消"});

        },
        error: function () {
            pop_up({title: "提示", message: "保存失败", yesName: "确定", noName: "取消"});
        }
    });

}

/**
 * Created by SongJing on 2017/3/28.
 */

/*
 * 根据后台返回的信息对dicom信息进行汉化显示
 * 汉化方式是图像全部加载完毕后进行汉化
 * */
var translateFlag = false;
function translate2Chinese() {
    // console.log("开始汉化！");
    //只允许进行一次汉化
    if (!translateFlag) {
        var pich = 0;
        var pichFlag = false;
        // console.log("汉化前！");
        // console.log(dvStruct.seriesArr);

        for (var i = 0,len0=dvStruct.seriesArr.length; i < len0; i++) {
            pichFlag = false;
            pich = 0;
            //序列匹配
            for (var k = 0,len1=dvStruct.outputSeriesArr.length; k < len1; k++) {
                if (dvStruct.seriesArr[i].suid === dvStruct.outputSeriesArr[k].suid) {
                    pich = k;
                    pichFlag = true;
                    break;
                }
            }
            //开始汉化
            if (pichFlag) {

                for (var j = 0,len2=dvStruct.seriesArr[i].dicomArr.length; j < len2; j++) {
                    if (dvStruct.outputSeriesArr[pich].dicoms[j].CDes !== undefined) {
                        if (dvStruct.outputSeriesArr[pich].dicoms[j].CDes.length > 0) {
                            dvStruct.seriesArr[i].dicomArr[j].infoSet.StudyInfo.StudyDescription.val = dvStruct.outputSeriesArr[pich].dicoms[j].CDes;
                        }
                    }
                    if (dvStruct.outputSeriesArr[pich].dicoms[j].age) {
                        if (dvStruct.outputSeriesArr[pich].dicoms[j].age.length > 0) {
                            dvStruct.seriesArr[i].dicomArr[j].infoSet.PatientInfo.PatientsAge.val = dvStruct.outputSeriesArr[pich].dicoms[j].age;
                        }
                    }

                    if (dvStruct.outputSeriesArr[pich].dicoms[j].CPName) {
                        if (dvStruct.outputSeriesArr[pich].dicoms[j].CPName.length > 0) {
                            dvStruct.seriesArr[i].dicomArr[j].infoSet.PatientInfo.PatientName.val = dvStruct.outputSeriesArr[pich].dicoms[j].CPName;
                        }
                    }

                    if (dvStruct.outputSeriesArr[pich].dicoms[j].sex) {
                        if (dvStruct.outputSeriesArr[pich].dicoms[j].sex.length > 0) {
                            dvStruct.seriesArr[i].dicomArr[j].infoSet.PatientInfo.PatientSex.val = dvStruct.outputSeriesArr[pich].dicoms[j].sex;
                        }
                    }
                    if (dvStruct.outputSeriesArr[pich].dicoms[j].CHos) {
                        if (dvStruct.outputSeriesArr[pich].dicoms[j].CHos.length > 0) {
                            dvStruct.seriesArr[i].dicomArr[j].infoSet.EquipmentInfo.InstitutionName.val = dvStruct.outputSeriesArr[pich].dicoms[j].CHos;
                        }
                    }
                }
            }
            //完成汉化
            if (i == dvStruct.seriesArr.length - 1) {
                // console.log("汉化后！");
                // console.log(dvStruct.seriesArr);
                translateFlag = true;
            }
        }
    }
}
 



/**
 * Created by SongJing on 2017/4/1.
 * 调用本地打印机的相关方法
 */

var filmDataLocal = [];//保存后台处理的所有胶片

/*
 * 后台绘制图像信息。jpg打印当前页
 * */
function printCurFilmBackgroundLocal() {
    console.log("后台绘制图像信息。jpg打印当前页");
    filmDataLocal.length = 0;//清空本地打印对象
    var curPageId = "page" + printStruct.printpage.pageIndex;
    //返回给后台的数据对象，用于绘制图像信息
    var film = {
        img: "",
        data: []
    };
    $('.printPage').each(function (k, val) {
        if ($(this).attr('id') === curPageId) {
            console.log("打印第几页：" + $(this).attr('id'));
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            // console.log("pageTop--pageLeft:"+pageTop+"---"+pageLeft);

            //胶片参数
            var filmData = {
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {}
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');

            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;
            filmPageOut.height = filmData.paperSize.height * 2;

            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);


            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {
                    //每张小图的相应信息
                    var data = {
                        position: {//位置信息
                            xstart: 0,
                            ystart: 0,
                            xend: 1,
                            yend: 1,
                            W: 1,
                            H: 1
                        },
                        info: {//图像信息
                            lb: [],
                            lt: [],
                            rb: [],
                            rt: []
                        }
                    };
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    //var seNo = getseNo(imageId);//根据imageid找seno
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }
                    data.info = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取图像信息 //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();


                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    xend = xstrat + scaleWidth * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    yend = ystart + scaleHeight * filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;//图像的实际宽度
                    var actulH = scaleHeight * filmPageOut.height;//图像的实际高度
                    data.position.xstart = xstrat;
                    data.position.ystart = ystart;
                    data.position.xend = xend;
                    data.position.yend = yend;
                    data.position.xend = xstrat + actulW;
                    data.position.yend = ystart + actulH;
                    data.position.W = actulW;
                    data.position.H = actulH;
                    film.data.push(data);//将单张图像的信息push到返回后台的数据对象中
                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制
                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);//同步输出图像与页面中的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');
                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }
            });

            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");
            film.img = image.src.substring(23, image.src.length);

            var str = JSON.stringify(film);
            $.ajax({
                async: false,
                type: 'post',
                data: {
                    data: str
                },
                url: 'http://' + urlInit + '/GetDicomPrinterPic',
                success: function (data) {
                    var imageOut = new Image();
                    imageOut.src = "data:image/jpeg;base64," + data;
                    filmDataLocal.push(imageOut.src);//将后台返回的数据push到本地打印的数据对象
                },
                error: function () {
                    pop_up({title: "提示", message: "后台返回数据失败", yesName: "确定", noName: "取消"});
                }
            });
            $('#canvas4PrintOut').hide();
        }
    });
}
/*
 * 后台绘制图像信息。jpg打印所有页
 * */
function printAllFilmBackgroundLocal() {
    console.log("后台绘制图像信息。jpg打印所有页");
    filmDataLocal.length = 0;//清空本地打印对象

    //遍历需要打印的页
    $('.printPage').each(function (k, val) {
        if ($(this).attr('id') === "page0") {//第0页不用处理
        }
        else {
            clearSelecImgBoxCss();//移除选中样式
            clearSelecImgViewportCss();
            showPageId($(this).attr('id'));
            //返回给后台的数据对象，用于绘制图像信息
            var film = {
                img: "",
                data: []
            };
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            var filmData = {//胶片参数
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {},
                imgData: []
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');
            $('#canvas4PrintOut').show();
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width;
            filmPageOut.height = filmData.paperSize.height;
            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);
            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {
                    //返回给后台的每张小图的相应信息
                    var data = {
                        position: {
                            xstart: 0,
                            ystart: 0,
                            xend: 1,
                            yend: 1,
                            W: 1,
                            H: 1
                        },
                        info: {
                            lb: [],
                            lt: [],
                            rb: [],
                            rt: []
                        }
                    };
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    //var seNo = getseNo(imageId);//根据imageid找seno
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }
                    data.info = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);  //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();
                    var imgHeitht = $(this).height();
                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置对应的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    xend = xstrat + scaleWidth * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    yend = ystart + scaleHeight * filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;//图像的实际宽度
                    var actulH = scaleHeight * filmPageOut.height;//图像的实际高度

                    data.position.xstart = xstrat;  //保存对应参数到返回后台的数据对象中
                    data.position.ystart = ystart;
                    data.position.xend = xend;
                    data.position.yend = yend;
                    data.position.xend = xstrat + actulW;
                    data.position.yend = ystart + actulH;
                    data.position.W = actulW;
                    data.position.H = actulH;
                    film.data.push(data);//将每张图像的信息push到返回后台的数据对象中

                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制
                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);// 同步图像的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');
                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//画到最终输出画布上
                    cornerstone.disable(element);
                    $('#equalRationDraw').empty();
                }
            });
            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");//整张胶片的img
            film.img = image.src.substring(23, image.src.length);//返回给后台的图像数据
            var str = JSON.stringify(film);
            $.ajax({
                async: false,
                type: 'post',
                data: {
                    data: str
                },
                url: 'http://' + urlInit + '/GetDicomPrinterPic',
                success: function (data) {
                    var imageOut = new Image();
                    imageOut.src = "data:image/jpeg;base64," + data;
                    filmDataLocal.push(imageOut.src);//将后台返回的数据push到本地打印的数据对象
                },
                error: function () {
                    pop_up({title: "提示", message: "后台返回数据失败", yesName: "确定", noName: "取消"});
                }
            });
            $('#canvas4PrintOut').hide();
        }
    });
    showPrintPage(printStruct.printpage.pageIndex);//回到操作的那一页
}

/*
 * 前端绘制图像信息。jpg打印当前页
 * */
function getCurFilmDataWebLocal() {
    console.log("前端绘制图像信息。jpg打印当前页");
    filmDataLocal.length = 0;//清空本地打印对象
    var baseFontsize = $('#tagFontsize').val();//用户设置字号
    var curPageId = "page" + printStruct.printpage.pageIndex;
    $('.printPage').each(function (k, val) {
        if ($(this).attr('id') === curPageId) {
            console.log("打印第几页：" + $(this).attr('id'));
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            //胶片设置信息
            var filmData = {
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {},
                imgData: []
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');
            $('#canvas4PrintOut').show();//show
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;
            filmPageOut.height = filmData.paperSize.height * 2;
            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);
            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                if ($(this).attr('imgIn') == "true") { //当前viewport中有图像
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return;
                    }
                     var infoData = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取标识字符串  //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();//图片在页面中的高度，宽度
                    var imgHeitht = $(this).height();

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置所在的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    // xend=xstrat+scaleWidth*filmPageOut.width;
                    // yend=ystart+scaleHeight*filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;//图像的实际宽度
                    var actulH = scaleHeight * filmPageOut.height;//图像的实际高度

                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制
                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);//同步输出图像与页面中的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');//为目标canvas添加id
                    //绘制四角信息
                    var fontSize = calcFontsizeAsSet(actulW, actulH, baseFontsize);
                    drawInfoOnFilm(infoData, 'xxx', fontSize);//在canvas中绘制图像信息
                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//将单个图像画到最终输出画布上
                    cornerstone.disable(element);//取消该元素的使能
                    $('#equalRationDraw').empty();//清空
                }
            });
            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");//输出一页的图像
            filmDataLocal.push(image.src);//将图像数据push到本地打印的数据对象
            $('#canvas4PrintOut').hide();
        }
    });
}
/*
 * 前端绘制图像信息。jpg打印所有页
 * */
function getAllFilmDataWebLocal() {
    console.log("前端绘制图像信息。jpg打印所有页");
    filmDataLocal.length = 0;//清空本地打印对象
    //遍历需要打印的页
    var baseFontsize = $('#tagFontsize').val();//用户设置字号
    $('.printPage').each(function (k, val) {
        if (k>0) {//第0页不用处理
            clearSelecImgBoxCss();//移除选中样式
            clearSelecImgViewportCss();
            showPageId($(this).attr('id'));//将操作页置前显示
            var pageTop = $(this).offset().top - $(window).scrollTop();//胶片页的位置信息
            var pageLeft = $(this).offset().left - $(window).scrollLeft();
            var pageWidth = $(this).width();
            var pageHeight = $(this).height();
            //胶片设置信息
            var filmData = {
                paperType: $(this).attr('papertype'),
                paperDirect: $(this).attr('paperdirect'),//1 纵向  0 横向
                row: 0,
                col: 0,
                paperSize: {}
            };
            filmData.paperSize = getprinPaperPixel(filmData);//获取所选纸的实际大小
            filmData.row = $(this).attr('row'); //当前打印页的行列分布
            filmData.col = $(this).attr('col');
            $('#canvas4PrintOut').show();//show
            var filmPageOut = $('#canvas4PrintOut')[0];//最终输出胶片页的canvas
            filmPageOut.width = filmData.paperSize.width * 2;
            filmPageOut.height = filmData.paperSize.height * 2;
            var filmPageContext = filmPageOut.getContext('2d');
            filmPageContext.fillStyle = "#000000";//胶片底色  黑色
            filmPageContext.fillRect(0, 0, filmPageOut.width, filmPageOut.height);
            //遍历当前胶片页上的图像
            $(this).find('.printViewport').each(function (imgNo, viewport) {
                //当前viewport中有图像
                if ($(this).attr('imgIn') == "true") {
                    var imageId = $(this).attr('imageId');
                    var elementId = $(this).attr('id');
                    var seNo = $(this).attr('seNo');
                    var wwwlObj = getwwwlofViewport(elementId);
                    if (wwwlObj == null || wwwlObj == "" || wwwlObj == undefined) {
                        console.log("获取到错误的WWWL信息");
                        return false;
                    }
                    var infoData = imgInfoAsSet(seNo, imageId, wwwlObj.ww, wwwlObj.wl);   //获取标识字符串  //按照四角信息设置来输出信息
                    var imgTop = $(this).offset().top - $(window).scrollTop();//图片的位置信息
                    var imgLeft = $(this).offset().left - $(window).scrollLeft();
                    var imgWidth = $(this).width();//图片在页面中的高度，宽度
                    var imgHeitht = $(this).height();

                    //在页面中，图像在胶片页中的相应位置比例
                    var xstrat = 0, xend = 0;//单个图像在胶片上的位置x起点与终点
                    var ystart = 0, yend = 0;//单个图像在胶片上的位置y起点与终点
                    var scaleTop = (imgTop - pageTop) / pageHeight;//起点所在位置对应的比例位置
                    var scaleLeft = (imgLeft - pageLeft) / pageWidth;
                    var scaleWidth = imgWidth / pageWidth;//只是一个宽度比例参数
                    var scaleHeight = imgHeitht / pageHeight;
                    xstrat = scaleLeft * filmPageOut.width;
                    xend = xstrat + scaleWidth * filmPageOut.width;
                    ystart = scaleTop * filmPageOut.height;
                    yend = ystart + scaleHeight * filmPageOut.height;
                    var actulW = scaleWidth * filmPageOut.width;//图像的实际宽度
                    var actulH = scaleHeight * filmPageOut.height;//图像的实际高度
                    $('#equalRationDraw').width(actulW);  //等比例canvas绘图
                    $('#equalRationDraw').height(actulH);
                    $('#equalRationDraw').show();
                    fillImageKeep(elementId, "equalRationDraw", imageId, seNo);//保持操作后的图像状态进行绘制
                    var element = $("#equalRationDraw").get(0);
                    enableAllMeasureTools(element, elementId);//同步输出图像与页面中的操作状态
                    $('#equalRationDraw').children(0).attr('id', 'xxx');//为目标canvas添加id
                    // var fontSize = calcFontsize(actulW, actulH);//根据图像的实际高宽选择文字的字号
                    var fontSize = calcFontsizeAsSet(actulW, actulH, baseFontsize);
                    // console.log(actulW, actulH, baseFontsize);
                    drawInfoOnFilm(infoData, 'xxx', fontSize);//在目标canvas中绘制图像信息
                    var imgEqualTemp = $('#xxx')[0];
                    $('#equalRationDraw').hide();
                    filmPageContext.drawImage(imgEqualTemp, xstrat, ystart, actulW, actulH);//将单个图像画到最终输出画布上
                    cornerstone.disable(element);//取消该元素的使能
                    $('#equalRationDraw').empty();//清空
                }
            });
            var image = new Image();
            image.src = filmPageOut.toDataURL("image/jpeg");//输出一页的图像
            filmDataLocal.push(image.src);//将图像数据push到本地打印的数据对象
            $('#canvas4PrintOut').hide();
        }
    });
    showPrintPage(printStruct.printpage.pageIndex);//回到操作的那一页
}

/*
 * 移除指定id元素
 * */
var removePrintArea = function (id) {
    $("iframe#" + id).remove();
};
/*
 * 调用本地打印机打印生成的图像
 * data 图像数据
 * type 图像信息的生成方式 前端、后台
 * */
function printLocal(data, type) {
    var dataCount = data.length;
    if (dataCount < 1) {//图像对象长度小于1，即没有图像页需要打印
        //错误提示
        if (type == "web") {
            pop_up({title: "提示", message: "图像创建出错", yesName: "确定", noName: "取消"});
        }
        else {
            pop_up({title: "提示", message: "后台返回数据失败", yesName: "确定", noName: "取消"});
        }
        return false;
    }
    else {
        var idPrefix = "printArea";
        removePrintArea(idPrefix);//移除之前创建的临时元素
        var iframeId = idPrefix;
        var iframeStyle = 'position:absolute;width:100%;height:100%;left:-10000px;top:-10000px;';
        iframe = document.createElement('IFRAME');
        $(iframe).attr({
            style: iframeStyle,
            id: iframeId

        });
        document.body.appendChild(iframe);
        var _type_direc="_"+$("#page1").attr('papertype')+"_"+$("#page1").attr('paperdirect');
       var showState=$('.setTxtBox').attr('showState');
        var header=$('#printHeader').text();
        var addr=$('#printAddr').text();
        var tele=$('#printTele').text();
        // paperSizeDic[_type_direc];
        var doc = iframe.contentWindow.document;
         doc.write('<link type="text/css" rel="stylesheet" href="ipacsdv/css/printfilm.css?v=1.1" >');
        if(showState=="true"){
            //循环将图像添加到打印元素中
            for (var i = 0,len=data.length; i < len; i++) {
                doc.write('<div class="film '+_type_direc+'" >' +
                    '<div class="header"  ><div class="box"><img class="logo" src="ipacsdv/css/img/hoslogo/hoslogo.jpg"> <span class="name">'+header+'</span></div></div>' +
                    '<img class="filmImg"  src=' + data[i] + '  >' +
                    '<div class="footer" >' +
                    '<span class="txt"  style="float: left;" >'+addr+'</span>' +
                    '<span class="txt"  style="float: left;" >'+tele+'</span>' +
                    '</div>' +
                    '</div>');
            }
        }
        else{
            //循环将图像添加到打印元素中
            for (var i = 0,len=data.length; i < len; i++) {
                doc.write('<div class="film '+_type_direc+'" >' +
                    '<div class="header"  ></div>' +
                    '<img class="filmImg"  src=' + data[i] + '  >' +
                    '<div class="footer" >' +
                    '</div>' +
                    '</div>');
            }
        }
        doc.close();
        //获取打印对象并打印
        var frameWindow = iframe.contentWindow;
        frameWindow.close();
        frameWindow.focus();
        setTimeout(function () {
            frameWindow.print();//调用打印接口
        }, 800);
    }
}
/*
 * 打印jpg图像
 * printObj 打印对象；
 * type 图像信息的生成方式  前端、后台
 * */
function jpegPrint(printObj, type) {
    //前端生成图像信息
    if (type == "web") {
        switch (printObj) {
            case "cur"://打印的为当前页图像
                getCurFilmDataWebLocal();
                printLocal(filmDataLocal, type);
                break;
            case "all"://打印的为所有页图像
                getAllFilmDataWebLocal();
                printLocal(filmDataLocal, type);
                break;
            default:
                break;
        }
    }
    //后台生成图像信息
    else if (type == "background") {
        switch (printObj) {
            case "cur"://打印的为当前页图像
                printCurFilmBackgroundLocal();
                printLocal(filmDataLocal, type);
                break;
            case "all"://打印的为所有页图像
                printAllFilmBackgroundLocal();
                printLocal(filmDataLocal, type);
                break;
            default:
                break;
        }
    }
}
/*
 * 添加本地打印机 localPrinter
 * */
function addLocalPrinter() {
    var printBoxSelect = $('.printBoxSelect');
    var localPrinter = "localPrinter";
    var option = $('<option  data-id="' + localPrinter + '" data-name="' + localPrinter + '" data-ip="' + localPrinter + '" data-AET="' + localPrinter + '" data-AETLocal="' + localPrinter + '" data-Port="' + localPrinter + '" data-Position="' + localPrinter + '" data-Type="' + localPrinter + '" data-Priority="' + localPrinter + '"    data-magnifyType="' + localPrinter + ' "   data-Color="' + localPrinter + '"></option>').append(localPrinter);
    printBoxSelect.append(option);
}

  
/**
 * Created by SongJing on 2017/4/5.
 * 胶片打印页面定位线
 */
printStruct.enableReferenceLines = function (element, Synchronizer) {
    cornerstoneTools.referenceLines.tool.enable(element, Synchronizer);
};
printStruct.disableReferenceLines = function (element, Synchronizer) {
    cornerstoneTools.referenceLines.tool.disable(element, Synchronizer);
};
/*
 * 标记定位线
 * */
function markReferLine() {
    var printSynchronizer = new cornerstoneTools.Synchronizer("CornerstoneNewImage", cornerstoneTools.updateImageSynchronizer);

    $('.printViewport').each(function () {


        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            printSynchronizer.add(element);//这里改写过，
        }

    });


    $('.imgViewportSelected').each(function () {


        if ($(this).attr('imgIn') == "true") {
            $(this).attr('referline', true);
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            cornerstone.enable(element);
            cornerstoneTools.mouseInput.enable(element);
            cornerstoneTools.mouseWheelInput.enable(element);
            printStruct.enableReferenceLines(element, printSynchronizer);
            //cornerstoneTools.referenceLines.tool.enable(element);
        }

    });
}
/*
 * 清除定位线
 * */
function cancleMarkReferLine() {

    var printSynchronizer = new cornerstoneTools.Synchronizer("CornerstoneNewImage", cornerstoneTools.updateImageSynchronizer);

    $('.printViewport').each(function () {


        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            var element = $("#" + elementId).get(0);
            printSynchronizer.add(element);//这里改写过，
        }

    });

    $('.imgViewportSelected').each(function () {


        if ($(this).attr('imgIn') == "true") {
            var elementId = $(this).attr('id');
            $(this).attr('referline', false);
            var element = $("#" + elementId).get(0);
            printStruct.disableReferenceLines(element, printSynchronizer);
            //cornerstoneTools.referenceLines.tool.enable(element);
        }

    });
}
/**
 * Created by SongJing on 2017/4/5.
 * 设置Cookie相关操作
 */

/*
 * 获取cookie内容
 * */
function getCookie(name) {
    var strCookie = document.cookie;
    var arrCookie = strCookie.split("; ");
    for (var i = 0; i < arrCookie.length; i++) {
        var arr = arrCookie[i].split("=");
        if (arr[0] == name) {
            addCookie(name, arr[1], 24 * 30);//获取到cookie，再保存一次
            return arr[1];
        }
    }
    return "";
}
/*
 * 添加cookie
 * */
function addCookie(name, value, expiresHours) {
    var cookieString = name + "=" + escape(value);
    if (expiresHours > 0) {
        var date = new Date();
        date.setTime(date.getTime + expiresHours * 3600 * 1000);
        cookieString = cookieString + "; expires=" + date.toDateString();
    }
    document.cookie = cookieString;

}
/*
 * 删除cookie
 * */
function deleteCookie(name) {
    var date = new Date();
    date.setTime(date.getTime() - 10000);
    document.cookie = name + "=v; expires=" + date.toDateString();
}
/**
 * Created by SongJing on 2017/4/24.
 * 胶片打印 胶片信息字体设置
 */
/*
* //初始化字体设置 400*400
* 设置的字体为400*400的图像大小
* 胶片打印时的字号按比例计算获取
* */
function fontSetInit(canvW,canvH,fontSize) {
    console.log("字体设置");
    // var divW=$("#tagsPreView").width();
      var divH=$("#tagsPreView").height();
    var margin=(divH-canvH)/2;
    $("#tagViewport").css('margin-top', margin);
    $("#tagViewport").css('margin-bottom', margin);
    $("#tagViewport").width(canvW);
    $("#tagViewport").height(canvH);
    // var fontSize=12;

    var preViewID = "tagViewport";
    $("#" + preViewID).hide();
    var doubleViewportID="dobuleViewport";
    $("#" + doubleViewportID).width(canvW*2);
    $("#" + doubleViewportID).height(canvH*2);
    $("#" + doubleViewportID).show();

    var imageId;
    imageId = dvStruct.seriesArr[0].dicomArr[0].imageId;
    if (imageId != undefined && imageId != null) {
        var element = $("#" + doubleViewportID).get(0);
        //增加两个属性
        $("#" + doubleViewportID).attr('imageId', imageId);
        $("#" + doubleViewportID).attr('seNo', 0);
        cornerstone.disable(element);//清除上一次使用时留下的信息
        cornerstone.enable(element);
        cornerstoneTools.mouseInput.enable(element);
        cornerstone.loadImage(imageId).then(function (image) {
            cornerstone.displayImage(element, image);
            cornerstoneTools.orientationMarkers.enable(element);   //方位标签

        });
        $("#" + doubleViewportID).children('canvas').attr('id', 'doubleViewCanv');
        var doubleViewCanvId = 'doubleViewCanv';//doubleViewCanv
        // var fontSize=calcFontsize(canvW,canvH);
        var infoData=imgInfoAsSet(0,imageId, 400,40);   //获取标识字符串  //按照四角信息设置来输出信息
        drawInfoOnFilm(infoData, doubleViewCanvId, fontSize);
    }
    var doubleCanv = $('#doubleViewCanv')[0];

    $("#" + preViewID).show();

    var preViewCanv = $('#preViewCanv')[0];
    preViewCanv.width=canvW;
    preViewCanv.height=canvH;
    var preViewContext = preViewCanv.getContext('2d');
    preViewContext.fillStyle = "#000000";//胶片底色  黑色
    preViewContext.fillRect(0, 0, preViewCanv.width, preViewCanv.height);
    preViewContext.drawImage(doubleCanv, 0, 0, canvW, canvH);
    $("#" + doubleViewportID).hide();
}
/**
 * Created by SongJing on 2017/5/11.
 * 影像页面的播放操作
 */
//主页面的播放功能
$(function () {
    /*
     * 转到指定图像索引
     * 索引位置为该序列所在比例位置
     * */
    function goToShowIndexY(scale) {

        var win = dvStruct.whereIsMouse;
        dvStruct.fun.elementPaging(win);
        dvStruct.fun.synPagingCheck(win);

        if (_.isObject(win)) {
            for (var i = 0,len=win.col * win.row; i < len; i++) {
                var wrapper = win.wrappers[i];
                var stack = wrapper.stack;
                var len = stack.imageIds.length;
                var imgIndex = parseInt(len * scale);
                // console.log("图像索引："+imgIndex);
                if (len > 0) {
                    if (imgIndex <= 0) {
                        stack.currentImageIdIndex = 0;
                    }
                    else if (imgIndex >= len) {
                        stack.currentImageIdIndex = len - 1;
                    } else {
                        stack.currentImageIdIndex = imgIndex;
                    }
                    var imageId = stack.imageIds[stack.currentImageIdIndex];
                    cornerstone.loadImage(imageId).then(function (image) {
                        cornerstone.displayImage(wrapper.element, image);
                    });
                }
            }
        }

    }

    var playspeed = 1;
    /*
     * 转到第一张
     * */
    $(document).on('click', '.playFirst', function (e) {
        var winNo = parseInt($('.seriesWindow.checked').attr('no'));
        dvStruct.fun.stopCurrent(winNo);
        goToShowIndexY(0);
        dvStruct.fun.play();
    });
    /*
     * 转到最后一张
     * */
    $(document).on('click', '.playLast', function (e) {
        var winNo = parseInt($('.seriesWindow.checked').attr('no'));
        dvStruct.fun.stopCurrent(winNo);
        goToShowIndexY(1);
        dvStruct.fun.play();
    });
    /*
     * 播放加速
     * */
    $(document).on('click', '.playFast', function (e) {
        playspeed += 2;
        if (playspeed > 100)playspeed = 100;
        dvStruct.playSpeed = parseInt(playspeed);
        var winNo = parseInt($('.seriesWindow.checked').attr('no'));
        dvStruct.fun.stopCurrent(winNo);
        dvStruct.fun.play();
    });
    /*
     * 播放减速
     * */
    $(document).on('click', '.playSlow', function (e) {
        playspeed -= 2;
        if (playspeed < 1)playspeed = 1;
        dvStruct.playSpeed = parseInt(playspeed);
        var winNo = parseInt($('.seriesWindow.checked').attr('no'));
        dvStruct.fun.stopCurrent(winNo);
        dvStruct.fun.play();
    });
    /*
     * 开始播放
     * */
    $(document).on('click', '.playStart', function (e) {
        dvStruct.fun.play();
        $('.seriesWindow.checked').find('.playStop').show();
        $('.seriesWindow.checked').find('.playStart').hide();
        $('.js-play').hide();
        $('.js-stop').show();
    });
    /*
     * 暂停播放
     * */
    $(document).on('click', '.playStop', function (e) {
        var winNo = parseInt($('.seriesWindow.checked').attr('no'));
        dvStruct.fun.stopCurrent(winNo);
        $('.seriesWindow.checked').find('.playStop').hide();
        $('.seriesWindow.checked').find('.playStart').show();
        $('.js-play').show();
        $('.js-stop').hide();
    });
});
/**
 * Created by SongJing on 2017/5/22.
 * 鼠标左健按下拖动翻页功能
 */
 
/*
* 关闭鼠标翻页功能
* */
function  disablePaging() {
$('.seriesWindow').each(function (index,val) {
   var win=_.find(dvStruct.viewer.winArr,function(o){
        return o.no==index;
    });
    dvStruct.fun.synPagingCheck(win);
    if(_.isObject(win)) {
        for (var i = 0,len=win.col * win.row; i <len ; i++) {
            var wrapper = win.wrappers[i];
            var stack = wrapper.stack;
            var element=wrapper.element;
            var imageId = stack.imageIds[stack.currentImageIdIndex];
            if(imageId!=undefined){
                cornerstone.loadImage(imageId).then(function(image) {
                    // display this image
                    cornerstone.displayImage(element, image);
                    // set the stack as tool state
                    cornerstoneTools.removeToolState(element, 'stack', stack);
                    cornerstoneTools.stackScroll.deactivate(element, 1);
                });
            }

        }
    }

});




}
/**
 * Created by SongJing on 2017/8/14.
 */
var config = {
    'markers': ['L5', 'L4', 'L3', 'L2', 'L1', // Lumbar spine
        'T12', 'T11', 'T10', 'T9', 'T8', 'T7', // Thoracic spine
        'T6', 'T5', 'T4', 'T3', 'T2', 'T1',
        'C7', 'C6', 'C5', 'C4', 'C3', 'C2', 'C1' // Cervical spine
    ],
    'current': 'A',
    font:"30px Arial",
    fontSize:30
};

/*
 * 关闭方向标识
 * */
function closeMarkTool() {
    $(".printViewport").each(function () {
        var elementId = $(this).attr('id');
        var element = $("#" + elementId).get(0);
        if ($("#" + elementId).attr('imgIn') == "true") {
            cornerstoneTools.textMarker.deactivate(element, 1);
            // cornerstoneTools.textMarkerTouch.deactivate(element);
            var imageId = $("#" + elementId).attr('imageId');
            // setEleInfo(imageId,elementId);//绘制信息
            // fillImgInfoOnScreen(elementId);
        }
    });
}


/*
 * 计算打印标识字体大小
 * */
function  calcTextFont(paperW,paperH,pageW,pageH,imgW,imgH) {
    // var scaleW=imgW/pageW;
    var scaleH=imgH/pageH;
    // var width=paperW*scaleW;
    var height=paperH*scaleH;
    config.fontSize=height*0.1;
    config.font=config.fontSize+"px Arial";
    // console.log(config);
}
function selectedLength( selecStr,tip) {
    var length =$(selecStr).length;
    if(tip){
        if(length<1){
            pop_up({
                title: "提示",
                message: "请先选中有效单元格",
                yesName: "确定",
                noName: "取消"
            });
        }
    }
    return  length;
}
function  changeMarkerText() {
    //先闭所有的，再打开选中的
    closeMarkTool();
    $(".imgViewportSelected").each(function () {
        /*  var pageW,pageH,imgW,imgH;
         imgW=$(this).width();
         imgH=$(this).height();
         pageW=$(this).parents('.printPage').width();
         pageH=$(this).parents('.printPage').height();
         var papertype=$(this).parents('.printPage').attr('papertype');
         var paperdirect=$(this).parents('.printPage').attr('paperdirect');
         var paper=getPaperWH(papertype,paperdirect);
         calcTextFont(paper.width,paper.height,pageW,pageH,imgW,imgH);*/
        var elementId = $(this).attr('id');
        var element = $("#" + elementId).get(0);
        if ($("#" + elementId).attr('imgIn') == "true") {
            var toolStateManager = cornerstoneTools.getElementToolStateManager(element);
            toolStateManager.clear(element);
            cornerstone.updateImage(element);
            // cornerstoneTools.textMarker.enable(element);
            // cornerstoneTools.clearToolState(element, "textMarker");
            // cornerstoneTools.removeToolState(element, "textMarker");
            cornerstoneTools.textMarker.setConfiguration(config);
            cornerstoneTools.textMarker.activate(element, 1);
            // cornerstoneTools.textMarkerTouch.activate(element);
            var imageId = $("#" + elementId).attr('imageId');
            // setEleInfo(imageId,elementId);//绘制信息
            fillImgInfoOnScreen(elementId);
        }
    });
}

/**
 * Created by SongJing on 2017/11/7.
 * 肺结节AI诊断
 */

/*
 * 上传dicomUrl
 * */
function uploadLungAI(paraObj) {

    var passwordmd5 = md5(paraObj.password);//对密码进行md5加密
    //=======================begin 核心代码======================
    //先获得用于api调用授权的token
    var tokenserver = paraObj.serverUrl + "/api/Login/GetToken?username=" + paraObj.username + "&password=" + passwordmd5 + "&vendorCode=" + paraObj.vendorCode;

    $.ajax({
        url: tokenserver,
        dataType: 'json',
        method: 'GET',
        success: function (data) {
            pop_up({title: "提示", message: "图像上传分析中，处理完毕后自动弹出分析结果", yesName: "确定", noName: "取消"});

            if (data.code == 0) {
                var token = data.data;//token
                //uploader post参数
                var postParam = {
                    dicomPathList: paraObj.dicomPathList,
                    hosId: paraObj.hosId,
                    vendorCode: paraObj.vendorCode,
                    bucket: paraObj.bucket,//oss bucket name,需要已经创建了，并在服务端设置了访问账号
                    cloudSync: paraObj.cloudSync,//是否云同步
                    extension: paraObj.extension,//文件扩展名，如果是压缩包，则传递rar或zip
                    aiEngine: "",//ai引擎名称
                    requestId: ""//请求id，可选
                };
                //开始调用dicom导入api
                var apiurl = paraObj.serverUrl + "/api/FileUpload/ImportDicomByUrl";//api地址
                $.ajax({
                    type: "POST",
                    url: apiurl,
                    data: postParam,//post body
                    datatype: "json",
                    headers: {//headers
                        token: token//token
                    },
                    success: function (data) {
                        // console.log('lungAI-success request:');
                        // console.log(data.message);
                        if(data.data!=null||data.data!=undefined){
                            loadViewer(paraObj,data.data);//调取页面
                        }

                    },
                    complete: function (XMLHttpRequest, textStatus) {
                    },
                    error: function (data) {
                        pop_up({title: "提示", message: data.message, yesName: "确定", noName: "取消"});
                        // console.log('lungAI-error:');
                        // console.log(data);
                    }
                });
            }
            else {
                pop_up({title: "提示", message: data.message, yesName: "确定", noName: "取消"});
                // console.log('lungAI-else:');
                // console.log(data);

            }
        },
        error: function (xhr) {
            pop_up({title: "提示", message: 'lungAI-获取token失败1:' + JSON.stringify(xhr), yesName: "确定", noName: "取消"});
            // console.log('lungAI-获取token失败1:' + JSON.stringify(xhr));
        }
    }).done(function (data) {
    }).fail(function () {
        pop_up({title: "提示", message: 'lungAI-获取token失败1:' + JSON.stringify(xhr), yesName: "确定", noName: "取消"});
        // console.log('lungAI-获取token失败2');
    });
}

/*
 * 调取AI诊断页面
 * */
function loadViewer(paraObj,data) {
    console.log(paraObj,data);
    //==============以下为核心代码===================
    var expiresDate = new Date();//计算过期时间
    expiresDate.setMinutes(expiresDate.getMinutes() + 120);//120分钟后过期
    var expires = Date.parse(expiresDate) / 1000; //生成时间戳（秒为单位）

    //Url签名，其中userCode在用户生产环境需要修改为配置的字符串
    var signParam = data[0].studyDBId ;//用于签名的参数
    if (signParam == null || signParam == "") {//如果没有传递dataid
        if (data[0].studyInstanceUID != null && data[0].studyInstanceUID != "")//如果传递了studykey
        {
            signParam = data[0].studyInstanceUID;
        }
        else {
            signParam = data[0].patientId;
        }
    }
    var signature = md5( paraObj.vendorCode + expires + signParam + paraObj.userCode +  paraObj.targetApp);
    data[0].studyDBId = Base64.encode(data[0].studyDBId);//需要把参数修改为base64编码
    data[0].studyInstanceUID = Base64.encode(data[0].studyInstanceUID);//可选参数，如果dataid不为空
    data[0].patientId = Base64.encode(data[0].patientId);//可选参数，如果dataid不为空
    paraObj.hosId = Base64.encode(paraObj.hosId);//可选参数，如果dataid不为空

    var param = "?dataid=" + data[0].studyDBId + "&studyKey=" + data[0].studyInstanceUID + "&patId=" + data[0].patientId + "&hosId=" + paraObj.hosId +
        "&vendorCode=" +  paraObj.vendorCode + "&expires=" + expires + "&signature=" + signature + "&targetApp=" +  paraObj.targetApp + "&aiEngine=" +  paraObj.aiEngine;
    var linkviewurl =  paraObj.ViewerUrl + "/Viewer/Index";
    linkviewurl = linkviewurl + param;
    console.log(linkviewurl);
    window.open(linkviewurl, "Viewer");

}

/**
 * Created by SongJing on 2017/9/11.
 */


$(function () {

    bindImgjoin();//绑定拼接
    $(window).resize(function () {
        // imgResize();
    });
    //键盘操作微调操作添加到快捷调窗文件

    /*
     * 打开拼接
     * */
    $('#imgjoin').on('click', function () {
        joinStruct.openWay = false;
        $("#printMain").find('.txt').hide();
        $('.joinMainBox').show();
        $('.joinDiv').show();
        $('.joinHelpBox').show();
        $('.joinCutToolBox').show();
        $('.joinTitleBox').show();
        // $(".joinPreviewBox").hide();
        hideTool("joinPageS", 2);
    });

    /*
     * 关闭拼接
     * */
    $('.join-close').on('click', function () {
        console.log(joinStruct.openWay);
        $('.join-back').click();
        $('.joinDiv').hide();
        $(".joinBox").empty();
        $("#printMain").find('.txt').show();
        $('.joinMainBox').hide();
        $('.joinHelpBox').hide();
        if (joinStruct.openWay) {
            $('#closePrintMain').click();
        }
        $('.joinCutToolBox').hide();
        $('.joinTitleBox').hide();
    });

    /*
     *  单幅图像点击操作
     *  */
    $(document).on("click", '.joinImg', function () {
        var z_index = parseInt($(this).css('z-index'));
        if (z_index < 0 || z_index == NaN) {
            z_index = 1;
        }
        else {
            z_index = getMaxZindex() + 1;
        }
        $(this).css('z-index', z_index);
    });

    /*
     * 对图像进行裁剪
     * */
    $(document).on("click", '.join_adjust', function () {
        setTitle("裁剪页面");
        joinStruct.cutImgEnable = true;
        joinStruct.cutBoxEnable = false;
        $('.cutActive').removeClass("curActive");
        $(this).parents('.joinImg').addClass('cutActive');
        // $('.cutActive ').draggable("disable");
        var cropW = $('.cutActive').width();
        var cropH = $('.cutActive').height();
        $(".cutBox").width(cropW);
        $(".cutBox").height(cropH);

        $(".cutBox").attr("patientID", $('.cutActive').attr("patientID"));
        $(".cutBox").attr("studyTime", $('.cutActive').attr("studyTime"));
        $(".cutBox").attr("modality", $('.cutActive').attr("modality"));

        $(".cutBox").attr("name", $('.cutActive').attr("name"));
        $(".cutBox").attr("studyDate", $('.cutActive').attr("studyDate"));
        $(".cutBox").attr("sex", $('.cutActive').attr("sex"));
        $(".cutBox").attr("age", $('.cutActive').attr("age"));
        $(".cutBox").attr("birthDate", $('.cutActive').attr("birthDate"));
        $(".cutBox").attr("hosName", $('.cutActive').attr("hosName"));
        $(".cutBox").attr("describe", $('.cutActive').attr("describe"));

        $(".cutBox").attr("W", $('.cutActive').attr("W"));
        $(".cutBox").attr("H", $('.cutActive').attr("H"));
        $(".cutBox").attr("spacingX", $('.cutActive').attr("spacingX"));
        $(".cutBox").attr("spacingY", $('.cutActive').attr("spacingY"));
        $(".cutBox").attr("actualW", $('.cutActive').attr("actualW"));
        $(".cutBox").attr("actualH", $('.cutActive').attr("actualH"));


        var canvas = $(".cutBox>canvas")[0];
        canvas.width = cropW;
        canvas.height = cropH;
        var contxt = canvas.getContext('2d');
        contxt.fillStyle = "#000000";//胶片底色
        contxt.fillRect(0, 0, cropW, cropH);

        if (createCutImgCanv(contxt)) {
            $('.joinBox').hide();
            $('.joinCutBox').show();
            $('.cut_destory').click();
            $('.cut_reset').click();
            hideTool("cropPageS", 0);
        }

    });

    /*
     * 删除图像
     * */
    $(document).on("click", '.join_delete', function () {
        $(this).parents('.joinImg').remove();
    });

    /*
     * 双击图像操作
     * */
    $(document).on("dblclick", '.joinImg', function () {
        if ($(this).hasClass('joinImgSelec')) {
            $(this).removeClass('joinImgSelec');
            $(this).find('.active').remove();
        }
        else {
            // var activeHtml = '<input class="active" type="checkbox" checked="checked" disabled="disabled" >';
            var activeHtml = '<div class="active"><img src="ipacsdv/css/img/print/join_ok.png"></div>';
            // var activeHtml='<div class="active"></div>';
            $(this).append(activeHtml);
            $(this).addClass('joinImgSelec');
        }
    });


    /*
     * 对拼接结果进行裁剪
     * */
    $('.join-cutBox').on('click', function () {
        joinStruct.cutBoxEnable = true;
        joinStruct.cutImgEnable = false;
        var imgLength = $('.joinBox').find('.joinImg').length;
        if (joinStruct.cutBoxEnable && imgLength > 1) {

            var spacingComp = true;
            var spacing;
            $('.joinImg').each(function (k,val) {
                var spacingTemp = {
                    spaceingX: parseFloat($(this).attr('spaceingX')),
                    spaceingY: parseFloat($(this).attr('spaceingY'))
                };
                if (k > 0) {
                    if (Math.abs(spacingTemp.spaceingX -spacing.spaceingX)>0.000005 || Math.abs(spacingTemp.spaceingY - spacing.spaceingY)>0.00005) {
                        spacingComp = false;
                        return false;
                    }
                }
                else {
                    spacing = spacingTemp;
                }
            });
            if(!spacingComp){
                alert("拼接图像的像素间距参数不同，无法匹配！");
                return false;
            }

            setTitle("裁剪页面");
            if (createCutBoxCanv()) {
                $('.joinBox').hide();
                $('.joinCutBox').show();
            }
            $('.cut_destory').click();
            $('.cut_reset').click();
            hideTool("cropPageS", 2);
            return;
        }
        else {
            alert("少于2张图像，拼接无效！");
        }
    });

    /*
     * 重置
     * */
    $(".join-reset").on('click', function () {
        $('.img-container>canvas').cropper("clear");
        $('.cropper-container').remove();
        $('.img-container').each(function () {
            $(this).removeClass('img-container');
        });
        $('.cropper-hidden').each(function () {
            $(this).removeClass('cropper-hidden');
        });
        $('.joinBox').show();
        $('.joinCutBox').hide();
        $('.cutActive ').draggable("enable");
    });

    /*
     *    确定裁剪
     *    */
    $('.join-cutSure').on('click', function () {

        var sizeOrg = [$(".cutBox").width(), $(".cutBox").height()];
        var actualSize = [parseFloat($(".cutBox").attr('actualW')), parseFloat($(".cutBox").attr('actualH'))];

        var position = {
            xstart: $('.cropper-crop-box').position().left,
            ystart: $('.cropper-crop-box').position().top,
            width: $('.cropper-crop-box').width(),
            height: $('.cropper-crop-box').height()
        };
        var sizeScale = [position.width * 1.0 / sizeOrg[0], position.height * 1.0 / sizeOrg[1]];

        var newActualSize = [sizeScale[0] * actualSize[0], sizeScale[1] * actualSize[1]];
        var newSpacing = [1.0 * newActualSize[0] / position.width, 1.0 * newActualSize[1] / position.height];
        // console.log(sizeOrg,actualSize,sizeScale,newActualSize,newSpacing);

        if (joinStruct.cutBoxEnable) {
            //思路：如果是对拼接图像进行裁剪则不改变像素间距
            newSpacing = [1.0 * actualSize[0] / sizeOrg[0], 1.0 * actualSize[1] / sizeOrg[1]];
        }

        //保持原joinImg的像素间距，只是对他进行裁剪操作
        newSpacing = [parseFloat($(".cutBox").attr('spacingX')), parseFloat($(".cutBox").attr('spacingY'))];
        newActualSize = [$(".cutBox").width() * newSpacing[0], $(".cutBox").height() * newSpacing[1]];


        var patientID = $(".cutBox").attr('patientID');
        var studyTime = $(".cutBox").attr('studyTime');
        var modality = $(".cutBox").attr('modality');

        var name = $(".cutBox").attr('name');
        var studyDate = $(".cutBox").attr('studyDate');
        var sex = $(".cutBox").attr('sex');
        var age = $(".cutBox").attr('age');
        var birthDate = $(".cutBox").attr('birthDate');
        var hosName = $(".cutBox").attr('hosName');
        var describe = $(".cutBox").attr('describe');
        // console.log(name,studyDate,sex,age,birthDate,hosName,describe);

        var contxt = $(".cutBox>canvas")[0].getContext('2d');
        var imgData = contxt.getImageData(position.xstart, position.ystart, position.width, position.height);

        // contxt.putImageData(imgData,0,0);//验证了截取的图像是正确的

        var cropImgTemp = {
            patientID: patientID,
            studyTime: studyTime,
            modality: modality,

            name: name,
            studyDate: studyDate,
            sex: sex,
            age: age,
            birthDate: birthDate,
            imageId: "",
            hosName: hosName,
            describe: describe,
            imageData: [],
            maxPixelValue: 0,
            minPixelValue: 0,
            slope: 1,
            intercept: 0,
            columnPixelSpacing: newSpacing[0],
            rowPixelSpacing: newSpacing[1],
            windowWidth: 255,
            windowCenter: 128,
            columns: 0,
            rows: 0,
            width: 0,
            height: 0
        };
        for (var k = 0,len=imgData.width * imgData.height; k < len; k++) {
            cropImgTemp.imageData[k] = imgData.data[4 * k];
        }
        var minMax = cornerstoneWADOImageLoader.getMinMax(cropImgTemp.imageData);
        cropImgTemp.maxPixelValue = minMax.max;
        cropImgTemp.minPixelValue = minMax.min;
        cropImgTemp.slope = 1.0;
        cropImgTemp.intercept = 0;
        // cropImgTemp.columnPixelSpacing = 0.6;
        // cropImgTemp.rowPixelSpacing = 0.6;
        // cropImgTemp.columnPixelSpacing = newSpacing[1];
        // cropImgTemp.rowPixelSpacing = newSpacing[0];
        cropImgTemp.windowWidth = 255;
        cropImgTemp.windowCenter = 128;
        cropImgTemp.columns = imgData.width;
        cropImgTemp.rows = imgData.height;
        cropImgTemp.width = imgData.width;
        cropImgTemp.height = imgData.height;
        cropImgTemp.imageId = "loadCropImg://" + cropImgArr.length;
        var eleSize = [cropImgTemp.width, cropImgTemp.height];

        cropImgArr.push(cropImgTemp);
        if (cropImgArr.length > 0) {
            var imageId = cropImgArr[cropImgArr.length - 1].imageId;
            var imgW = cropImgArr[cropImgArr.length - 1].width;
            var imgH = cropImgArr[cropImgArr.length - 1].height;
            if (joinStruct.cutBoxEnable) {
                setTitle("预览页面");
                $(".joinBox").hide();
                $(".joinCutBox").hide();
                $(".joinPreviewBox").show();
                var boxH = $('.joinPreviewBox').height();
                if (eleSize[1] < boxH) {
                    var marginTop = (boxH - eleSize[1]) / 2;
                    $(".joinPreview").css("margin-top", marginTop + 'px');
                }
                else {
                    $(".joinPreview").css("margin-top", '0px');
                }
                // var eleSize1 = calcSize($(".joinPreviewBox"), 1, imgW, imgH);
                $(".joinPreview").width(eleSize[0]);
                $(".joinPreview").height(eleSize[1]);
                $('.joinPreview').attr("imageId", imageId);
                drawEle($('.joinPreview'), imageId);//绘制到预览页面
                joinStruct.cutBoxEnable = false;
                hideTool("previewPageS", 11);
            }
            else if (joinStruct.cutImgEnable) {
                setTitle("拼接页面");
                $(".joinBox").show();
                if ($(".joinBox").show()) {
                    var top = $(".cutActive").css('top');
                    var left = $(".cutActive").css('left');
                    // var eleSize2 = calcSize($(".cutActive"), 1, imgW, imgH);
                    var html = $('<div class="joinImg draggable ui-widget-content "  patientID="' + patientID + '" studyTime="' + studyTime + '" modality="' + modality + '" ' +
                        'name="' + name + '" studyDate="' + studyDate + '" sex="' + sex + '" age="' + age + '" birthDate="' + birthDate + '" hosName="' + hosName + '" describe="' + describe + '" ' +
                        ' actualW="' + newActualSize[0] + '"  actualH="' + newActualSize[1] + '"' +
                        'spacingX="' + newSpacing[0] + '"   spacingY="' + newSpacing[1] + '" ' +
                        'imageId="' + imageId + '"  W="' + imgW + '" H="' + imgH + '" style="top: ' + top + ';left: ' + left + '; width:' + eleSize[0] + 'px; height:' + eleSize[1] + 'px; "></div>');
                    $('.joinBox').append(html);
                    html.draggable({
                        containment: ".joinBox",//移动范围
                        stack: html,//重叠时的z-index
                        scroll: false,
                        start: function () {
                            html.css('opacity', '0.5');
                        },
                        drag: function () {
                        },
                        stop: function () {
                            html.css('opacity', '1');
                        }
                    });
                    $(".cutActive").remove();

                    drawEle(html, imageId);//绘制到预览页面
                    //大小可拖动改变
                   /* html.resizable({
                        handles: "se",
                        aspectRatio: imgW / imgH
                    });
                    html.resize(function () {
                        var element = $(this).get(0);
                        cornerstone.resize(element, true);//图像显示大小同步更新
                    });*/

                    var adjustHtml = $('<div class="adjustDiv"><div class="btn join_delete " title="删除"><img src="ipacsdv/css/img/print/join_delete.png"></div><div class="btn join_adjust" title="裁剪"><img src="ipacsdv/css/img/print/join_cut.png"></div></div>');
                    html.append(adjustHtml);
                    html.hover(function () {
                        $(adjustHtml).find('.btn').show();
                    }, function () {
                        $(adjustHtml).find('.btn').hide();
                    });
                }
                $(".joinCutBox").hide();
                joinStruct.cutImgEnable = false;
                hideTool("joinPageS", 0);
            }
        }
        $('.join-save').show();

    });

    /*
     * 取消对拼接结果的截图
     * */
    $('.join-undo').on('click', function () {
        setTitle("裁剪页面");
        joinStruct.cutBoxEnable = true;
        $(".joinCutBox").show();
        $(".joinPreviewBox").hide();
        hideTool("cropPageS", 2);
    });

    /*
     * 返回拼接页面
     * */
    $('.join-back').on('click', function () {
        $(".joinCutBox").hide();
        $(".joinPreviewBox").hide();
        $(".joinBox").show();
        // $('.cutActive ').draggable("enable");
        hideTool("joinPageS", 0);
        setTitle("拼接页面");
    });

    /*
     * 发送到打印页面
     * */
    $('.join-sendToPrint1').on('click', function () {
        sendToPrint("join",true,true,true);
       /* var imgLength = $('.joinBox').find('.joinImg').length;
        if (imgLength < 2) {
            alert("少于2张图像，拼接无效！");
            return;
        }

        $('.joinOutPutBox').empty();
        var imageId = "loadJoinImg://" + joinOutputObj.length;
        if (createJoinCanv()) {
            addToLeftBox(imageId);//添加到右侧缩略图
            addToPrintPage(imageId);
        }
        console.log(joinOutputObj);
        joinStruct.openWay = false;
        $('.join-close').click();//清空拼接内容
        $('.joinHelpBox').hide();*/
    });

    /*
     * 将对拼接结果的截图发送到打印碳
     * */
    $('.join-sendToPrint2').on('click', function () {
        sendToPrint("crop",true,true,true);
       /* var imageId = "loadJoinImg://" + (joinOutputObj.length);
        joinOutputObj.push(cropImgArr[cropImgArr.length - 1]);
        joinOutputObj[joinOutputObj.length - 1].imageId = imageId;
        $('.joinOutPutBox').empty();
        if (joinOutputObj.length > 0) {
            console.log(joinOutputObj);
            addToLeftBox(imageId);//添加到右侧缩略图
            addToPrintPage(imageId);
            $('.join-close').click();//清空拼接内容
            $('.joinPreviewBox').hide();
            $(".joinCutBox").hide();
            $(".joinBox").show();
            joinStruct.openWay = false;
            $('.join-close').click();//清空拼接内容
            $('.joinHelpBox').hide();
        }*/
    });


    /*
     * 保存后台
     * */
    $(".join-save2").on('click', function () {
        if(sendToPrint("crop",true,false,false)){
            $(".joinPreview").find('canvas').attr("id", "saveTest");
            var saveCanv = $('#saveTest')[0];//最终输出胶片页的canvas
            // var saveCanvOut = saveCanv.getContext('2d');
            var image = new Image();
            image.src = saveCanv.toDataURL("image/jpeg");
            var imgdata = image.src.substring(23, image.src.length);
            // var imgdataStr = JSON.stringify(imgdata);
            var platCode = GetPlatCode();
            //保存到本地测试
           /* var platCode ="platCode";
            var triggerDownload = $("<a>").attr("href", image.src ).attr("download", "printPage2.jpg").appendTo("body");
            triggerDownload[0].click();
            triggerDownload.remove();*/


            $.ajax({
                type: 'post',
                data: {
                    platCode: platCode,
                    IID: IID,
                    seriesID: IID,
                    imageID: IID + "." + ran(5),
                    hosName: cropImgArr[cropImgArr.length - 1].hosName,
                    patientName: cropImgArr[cropImgArr.length - 1].name,
                    patientID: cropImgArr[cropImgArr.length - 1].patientID,
                    patientBirthDate: cropImgArr[cropImgArr.length - 1].birthDate,
                    patientSex: cropImgArr[cropImgArr.length - 1].sex,
                    studyDate: cropImgArr[cropImgArr.length - 1].studyDate,
                    studyTime: cropImgArr[cropImgArr.length - 1].studyTime,
                    // studyID:cropImgArr[cropImgArr.length-1].studyID,
                    modality: cropImgArr[cropImgArr.length - 1].modality,
                    instanceNumber: joinOutputObj.length,
                    pixelSpacing: cropImgArr[cropImgArr.length - 1].rowPixelSpacing + "\\" + cropImgArr[cropImgArr.length - 1].columnPixelSpacing,
                    windowCenter: cropImgArr[cropImgArr.length - 1].windowCenter,
                    windowWidth: cropImgArr[cropImgArr.length - 1].windowWidth,
                    base64Data: imgdata
                },
                url: 'http://' + urlInit + '/uploadJoinImageOfBase64',
                success: function (data) {
                    console.log("保存成功");
                },
                error: function () {
                    pop_up({title: "提示", message: "保存失败", yesName: "确定", noName: "取消"});
                }
            });
        }
    });

    $(".join-save1").on('click', function () {
        if(            sendToPrint("join",true,false,false)        ){
            var saveCanv = $('#saveTest1')[0];//最终输出胶片页的canvas
            // var saveCanvOut = saveCanv.getContext('2d');
            var image = new Image();
            image.src = saveCanv.toDataURL("image/jpeg");
            var imgdata = image.src.substring(23, image.src.length);
            // var imgdataStr = JSON.stringify(imgdata);
            // console.log(joinOutputObj[joinOutputObj.length - 1]);
              var platCode = GetPlatCode();
            //保存到本地测试

            /* var platCode ="platCode";
             var triggerDownload = $("<a>").attr("href",  image.src).attr("download", "printPage1.jpg").appendTo("body");
            triggerDownload[0].click();
            triggerDownload.remove();
            console.log(image);*/

            $.ajax({
                type: 'post',
                data: {
                    platCode: platCode,
                    IID: IID,
                    seriesID: IID,
                    imageID: IID + "." + ran(5),
                    hosName: joinOutputObj[joinOutputObj.length - 1].hosName,
                    patientName: joinOutputObj[joinOutputObj.length - 1].name,
                    patientID: joinOutputObj[joinOutputObj.length - 1].patientID,
                    patientBirthDate: joinOutputObj[joinOutputObj.length - 1].birthDate,
                    patientSex: joinOutputObj[joinOutputObj.length - 1].sex,
                    studyDate: joinOutputObj[joinOutputObj.length - 1].studyDate,
                    studyTime: joinOutputObj[joinOutputObj.length - 1].studyTime,
                    // studyID:cropImgArr[cropImgArr.length-1].studyID,
                    modality: joinOutputObj[joinOutputObj.length - 1].modality,
                    instanceNumber: joinOutputObj.length,
                    pixelSpacing: joinOutputObj[joinOutputObj.length - 1].rowPixelSpacing + "\\" + joinOutputObj[joinOutputObj.length - 1].columnPixelSpacing,
                    windowCenter: joinOutputObj[joinOutputObj.length - 1].windowCenter,
                    windowWidth: joinOutputObj[joinOutputObj.length - 1].windowWidth,
                    base64Data: imgdata
                },

                url: 'http://' + urlInit + '/uploadJoinImageOfBase64',
                success: function (data) {
                    console.log("保存成功");
                },
                error: function () {
                    pop_up({title: "提示", message: "保存失败", yesName: "确定", noName: "取消"});
                }
            });
        }
    });

});

 





/**
 * Created by SongJing on 2017/9/11.
 */


/*
 * 判断该图像是否存在
 * */
function isImgExist(imageId) {
    var imgLength = $('.joinBox').find('[imageId="' + imageId + '"]').length;
    if (imgLength == 0) {
        return true;
    }
    else {
        return false;
    }
}

/*
 * 获取图像堆叠的最大z-index
 * */
function getMaxZindex() {
    var min = 0, max = 0;
    $('.joinBox').find('.joinImg').each(function () {
        var zIndex = $(this).css('z-index');
        if (zIndex > max) {
            max = zIndex;
        }
        if (zIndex < min) {
            min = zIndex;
        }

    });
    return parseInt(max);
}


/*
 * 图像resize
 * */
function imgResize() {

    $('.joinImg').each(function () {
        var imgW = parseInt($(this).attr('W'));
        var imgH = parseInt($(this).attr('H'));
        var size = joinImgSize(imgW, imgH);
        $(this).width(size[0]);
        $(this).height(size[1]);
        var element = $(this).get(0);
        cornerstone.resize(element, true);//图像显示大小同步更新
    })
}


/*
 * 在canvas中绘制出图像拼接的最终结果
 * */
function createJoinCanv() {
    //是否正常拼接图像判定
    if ($('.joinImg').length < 2) {
        return false;
    }
    var joinObjTemp = {

        patientID: "",
        studyTime: "",
        modality: "",
        instanceNumber: 1,


        name: "",
        studyDate: "",
        sex: "",
        age: "",
        birthDate: "",
        imageId: "",
        hosName: "",
        describe: "",
        imageData: [],
        maxPixelValue: 0,
        minPixelValue: 0,
        slope: 0,
        intercept: 0,
        columnPixelSpacing: 0,
        rowPixelSpacing: 0,
        windowWidth: 0,
        windowCenter: 0,
        columns: 0,
        rows: 0,
        width: 0,
        height: 0
    };
    var W = $('.joinBox').width();
    var H = $('.joinBox').height();

    var min_xstart = $('.joinImg').width(), min_ystart = $('.joinImg').height(), max_xend = 0, max_yend = 0;
    joinObj.length = 0;

    var solpe = 0, intercept = 0, pixelSpacing = 0, ww = 0, wc = 0;
    $('.joinImg').each(function () {
        //子图对象
        var imgObj = {
            imageId: $(this).attr('imageId'),
            zIndex: $(this).css('z-index'),
            imageSrc: null,
            imgRows: 0,
            imgCols: 0,
            xspacing: 0,
            yspacing: 0,
            location: {
                xstart: $(this).position().left,
                ystart: $(this).position().top,
                xend: 0,
                yend: 0,
                W: $(this).width(),
                H: $(this).height()
            }
        };
        imgObj.location.xend = $(this).width() + imgObj.location.xstart;
        imgObj.location.yend = $(this).height() + imgObj.location.ystart;

        console.log($(this).position().left, $(this).position().top, "______________", $(this).width(), $(this).height());
        if (max_xend < imgObj.location.xend) {
            max_xend = imgObj.location.xend
        }
        if (max_yend < imgObj.location.yend) {
            max_yend = imgObj.location.yend
        }
        if (min_xstart > imgObj.location.xstart) {
            min_xstart = imgObj.location.xstart
        }
        if (min_ystart > imgObj.location.ystart) {
            min_ystart = imgObj.location.ystart
        }

        $(this).addClass("labelTemp");
        imgObj.imageSrc = $(".labelTemp>canvas")[0];
        $(this).removeClass("labelTemp");


        if (imgObj.imageId.indexOf("load") < 0) {
            console.log("origin image");
            var imgInfo = printStruct.findOriInfoOnlyByOriId(imgObj.imageId);
            // console.log(imgInfo);
            solpe = parseFloat(imgInfo.ImageInfo.RescaleSlope.val);
            intercept = parseFloat(imgInfo.ImageInfo.RescaleIntercept.val);
            pixelSpacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);

            var elementTemp = $(this).get(0);
            var viewport = deepCopy1(cornerstone.getViewport(elementTemp));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);


            /*  joinObjTemp.name = imgInfo.PatientInfo.PatientName.val;
             joinObjTemp.age = imgInfo.PatientInfo.PatientsAge.val;
             joinObjTemp.sex = imgInfo.PatientInfo.PatientSex.val;
             joinObjTemp.birthDate = imgInfo.PatientInfo.PatientBirthDate.val;
             joinObjTemp.studyDate = imgInfo.StudyInfo.StudyDate.val;
             if (imgInfo.SeriesInfo.SeriesDescription.val) {
             joinObjTemp.describe = imgInfo.SeriesInfo.SeriesDescription.val;
             }
             if (imgInfo.EquipmentInfo.InstitutionName.val) {
             joinObjTemp.hosName = imgInfo.EquipmentInfo.InstitutionName.val;
             }*/


            imgObj.imgRows = parseInt(imgInfo.ImageInfo.Rows.val);
            imgObj.imgCols = parseInt(imgInfo.ImageInfo.Columns.val);
            imgObj.xspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
            imgObj.yspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
        }
        else {
            console.log("self create image");
            // console.log(imgInfo);
            solpe = 1.0;
            intercept = 0;
            pixelSpacing = 0.6;


            ww = 255;
            wc = 128;


            /*   joinObjTemp.name = "==";
             joinObjTemp.age = "==";
             joinObjTemp.sex = "==";
             joinObjTemp.birthDate = "==";
             joinObjTemp.studyDate = "==";
             joinObjTemp.describe = "==";
             joinObjTemp.hosName = "==";*/

            imgObj.imgRows = parseInt($(this).height());
            imgObj.imgCols = parseInt($(this).width());
            imgObj.xspacing = 0.6;
            imgObj.yspacing = 0.6;
        }

        joinObjTemp.patientID = $(this).attr("patientID");
        joinObjTemp.studyTime = $(this).attr("studyTime");
        joinObjTemp.modality = $(this).attr("modality");

        joinObjTemp.name = $(this).attr("name");
        joinObjTemp.age = $(this).attr("age");
        joinObjTemp.sex = $(this).attr("sex");
        joinObjTemp.birthDate = $(this).attr("birthDate");
        joinObjTemp.studyDate = $(this).attr("studyDate");
        joinObjTemp.describe = $(this).attr("describe");
        joinObjTemp.hosName = $(this).attr("hosName");

        imgObj.xspacing = parseFloat($(this).attr("spacingX"));
        imgObj.yspacing = parseFloat($(this).attr("spacingY"));

        joinObj.push(imgObj);


        //将所有参加拼接的单个子图等比例绘制
        /*   var imgDiv = $('<div class="imgOrgin"  indexVal="' + imgObj.zIndex + '" style="width:' + imgObj.imgCols + 'px; height:' + imgObj.imgRows + 'px;margin-top: 20px;"></div>');
         $('.joinOutPutBox').append(imgDiv);
         var element = imgDiv.get(0);
         cornerstone.disable(element);//清除上一次使用时留下的信息
         cornerstone.enable(element);
         cornerstone.loadImage(imgObj.imageId).then(function (image) {
         cornerstone.displayImage(element, image);
         });*/

    });


    joinObj.sort(compare('zIndex'));//根据图像的堆叠次序排序
    // joinObj.reverse();
// console.log(joinObj);
    // console.log(min_xstart, min_ystart, "_________________________________", max_xend, max_yend);

    var joinShow_W = max_xend - min_xstart;
    var joinShow_H = max_yend - min_ystart;
    // console.log(joinShow_W,"=========================",joinShow_H);

    // var joinOut_W = parseInt(joinShow_W * joinObj[0].imgCols / W);//拼接后的图像宽
    // var joinOut_H = parseInt(joinShow_H * joinObj[0].imgRows / H);//拼接后的图像高

    // var joinOut_W = W;//拼接后的图像宽
    // var joinOut_H = H;//拼接后的图像高
    // console.log(joinOut_W, "===44444444444444444=========",joinOut_H);


    //绘制拼接结果
    var joinCanvOut = $('#joinOutputCanv')[0];
    joinCanvOut.width = W;
    joinCanvOut.height = H;
    console.log("canvOut_W_H：", W, H);
    var joinContext = joinCanvOut.getContext('2d');
    joinContext.fillStyle = "#000000";//胶片底色  黑色
    joinContext.fillRect(0, 0, W, H);


    //本地测试
    // var joinResult=$('#joinResultCanv')[0];
    // joinResult.width =joinShow_W;
    // joinResult.height =joinShow_H;
    // var joinResultContext = joinResult.getContext('2d');


    //    将其绘制到canvas中生成新的img，与原数据同类型
    for (var i = 0,len=joinObj.length; i < len; i++) {
        var zIndex = joinObj[i].zIndex;
        var x, y, _W, _H; //图像在拼接结果图中的实际起点与高宽
        x = joinObj[i].location.xstart;
        y = joinObj[i].location.ystart;
        _W = joinObj[i].location.W;
        _H = joinObj[i].location.H;

        //原图像
        // var imgCanv = $('div[indexval="' + zIndex + '"]').children();
        // imgCanv.attr('id', "joinTempId");
        // var imgOrgin = $("#joinTempId")[0];
        // joinContext.drawImage(imgOrgin, x, y, _W, _H);
        // console.log("drawLocation:", x, y, _W, _H);
        // imgCanv.removeAttr('id');
        joinContext.drawImage(joinObj[i].imageSrc, x, y, _W, _H);
    }//在canvas中绘制出图像拼接的最终结果


    var originImageData = joinContext.getImageData(min_xstart, min_ystart, joinShow_W, joinShow_H);//获取有效区域的图像数据


    

    var saveCanv = $('#saveTest1')[0];//最终输出胶片页的canvas
    saveCanv.width=originImageData.width ;
    saveCanv.height=originImageData.height;
    var saveContxt=saveCanv.getContext('2d');
    saveContxt.putImageData(originImageData,0,0);

    // 将拼接结果下载到本地
    // joinResultContext.drawImage(joinCanvOut,min_xstart, min_ystart,joinShow_W,joinShow_H,0,0,joinShow_W,joinShow_H);
    // var page2jpgURL = joinResult.toDataURL("image/jpeg");
    // var triggerDownload = $("<a>").attr("href", page2jpgURL).attr("download", "printPage.jpg").appendTo("body");
    // triggerDownload[0].click();
    // triggerDownload.remove();
    // originImageData=joinResultContext.getImageData(0, 0,joinShow_W,joinShow_H);

    //取出图像数据
    for (var k = 0,len=originImageData.width * originImageData.height; k < len; k++) {
        joinObjTemp.imageData[k] = originImageData.data[4 * k];
    }

    var minMax = cornerstoneWADOImageLoader.getMinMax(joinObjTemp.imageData);
    joinObjTemp.maxPixelValue = minMax.max;
    joinObjTemp.minPixelValue = minMax.min;
    joinObjTemp.slope = solpe;
    joinObjTemp.intercept = intercept;
    joinObjTemp.columnPixelSpacing = pixelSpacing;
    joinObjTemp.rowPixelSpacing = pixelSpacing;
    joinObjTemp.windowWidth = 255;
    joinObjTemp.windowCenter = 128;
    joinObjTemp.columns = originImageData.width;
    joinObjTemp.rows = originImageData.height;
    joinObjTemp.width = originImageData.width;
    joinObjTemp.height = originImageData.height;
    joinObjTemp.imageId = "loadJoinImg://" + joinOutputObj.length;
    joinOutputObj.push(joinObjTemp);
    // joinOutputIndex++;//拼图索引号加1
    return true;
}

/*
 * 图像数据绘制到剪切工作区域
 * */
function createCutBoxCanv() {
    joinObj.length = 0;//清空数据
    var joinObjTemp = {
        patientID: "",
        studyTime: "",
        modality: "",
        instanceNumber: 1,

        name: "",
        studyDate: "",
        sex: "",
        age: "",
        birthDate: "",
        imageId: "",
        hosName: "",
        describe: "",
        imageData: [],
        maxPixelValue: 0,
        minPixelValue: 0,
        slope: 0,
        intercept: 0,
        columnPixelSpacing: 0,
        rowPixelSpacing: 0,
        windowWidth: 0,
        windowCenter: 0,
        columns: 0,
        rows: 0,
        width: 0,
        height: 0
    };
    var W = $('.joinBox').width();
    var H = $('.joinBox').height();

    var min_xstart = $('.joinImg').width(), min_ystart = $('.joinImg').height(), max_xend = 0, max_yend = 0;
    joinObj.length = 0;

    var solpe = 0, intercept = 0, pixelSpacing = 0, ww = 0, wc = 0;
    $('.joinImg').each(function () {
        //子图对象
        var imgObj = {
            imageId: $(this).attr('imageId'),
            zIndex: $(this).css('z-index'),
            imgRows: 0,
            imgCols: 0,
            imageSrc: null,
            xspacing: 0,
            yspacing: 0,
            location: {
                xstart: $(this).position().left,
                ystart: $(this).position().top,
                xend: 0,
                yend: 0,
                W: $(this).width(),
                H: $(this).height()
            }
        };
        imgObj.location.xend = $(this).width() + imgObj.location.xstart;
        imgObj.location.yend = $(this).height() + imgObj.location.ystart;

        // console.log($(this).position().left,$(this).position().top,"______________",$(this).width(),$(this).height());
        if (max_xend < imgObj.location.xend) {
            max_xend = imgObj.location.xend
        }
        if (max_yend < imgObj.location.yend) {
            max_yend = imgObj.location.yend
        }
        if (min_xstart > imgObj.location.xstart) {
            min_xstart = imgObj.location.xstart
        }
        if (min_ystart > imgObj.location.ystart) {
            min_ystart = imgObj.location.ystart
        }
        $(this).addClass("labelTemp");
        imgObj.imageSrc = $(".labelTemp>canvas")[0];
        $(this).removeClass("labelTemp");
        if (imgObj.imageId.indexOf("load") < 0) {
            console.log("origin image");
            var imgInfo = printStruct.findOriInfoOnlyByOriId(imgObj.imageId);
            // console.log(imgInfo);
            solpe = parseFloat(imgInfo.ImageInfo.RescaleSlope.val);
            intercept = parseFloat(imgInfo.ImageInfo.RescaleIntercept.val);
            pixelSpacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);

            var elementTemp = $(this).get(0);
            var viewport = deepCopy1(cornerstone.getViewport(elementTemp));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);


            // joinObjTemp.name = imgInfo.PatientInfo.PatientName.val;
            // joinObjTemp.age = imgInfo.PatientInfo.PatientsAge.val;
            // joinObjTemp.sex = imgInfo.PatientInfo.PatientSex.val;
            // joinObjTemp.birthDate = imgInfo.PatientInfo.PatientBirthDate.val;
            // joinObjTemp.studyDate = imgInfo.StudyInfo.StudyDate.val;
            // if (imgInfo.SeriesInfo.SeriesDescription.val) {
            //     joinObjTemp.describe = imgInfo.SeriesInfo.SeriesDescription.val;
            // }
            // if (imgInfo.EquipmentInfo.InstitutionName.val) {
            //     joinObjTemp.hosName = imgInfo.EquipmentInfo.InstitutionName.val;
            // }


            imgObj.imgRows = parseInt(imgInfo.ImageInfo.Rows.val);
            imgObj.imgCols = parseInt(imgInfo.ImageInfo.Columns.val);
            imgObj.xspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
            imgObj.yspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
        }
        else {
            console.log("self create image");
            // console.log(imgInfo);
            solpe = 1.0;
            intercept = 0;
            pixelSpacing = 0.6;
            ww = 255;
            wc = 128;
            /* joinObjTemp.name = "==";
             joinObjTemp.age = "==";
             joinObjTemp.sex = "==";
             joinObjTemp.birthDate = "==";
             joinObjTemp.studyDate = "==";
             joinObjTemp.describe = "==";
             joinObjTemp.hosName = "==";*/
            imgObj.imgRows = parseInt($(this).height());
            imgObj.imgCols = parseInt($(this).width());
            imgObj.xspacing = 0.6;
            imgObj.yspacing = 0.6;
        }
        // 重写信息 begin
        joinObjTemp.patientID = $(this).attr("patientID");
        joinObjTemp.studyTime = $(this).attr("studyTime");
        joinObjTemp.modality = $(this).attr("modality");

        joinObjTemp.name = $(this).attr("name");
        joinObjTemp.age = $(this).attr("age");
        joinObjTemp.sex = $(this).attr("sex");
        joinObjTemp.birthDate = $(this).attr("birthDate");
        joinObjTemp.studyDate = $(this).attr("studyDate");
        joinObjTemp.describe = $(this).attr("describe");
        joinObjTemp.hosName = $(this).attr("hosName");

        imgObj.xspacing = parseFloat($(this).attr("spacingX"));
        imgObj.yspacing = parseFloat($(this).attr("spacingY"));
        //重写信息 end
        joinObj.push(imgObj);
    });


    joinObj.sort(compare('zIndex'));//根据图像的堆叠次序排序
    var joinShow_W = max_xend - min_xstart;
    var joinShow_H = max_yend - min_ystart;
    var actualW = [joinShow_W * parseFloat($('.joinImg').attr("spacingX")), joinShow_H * parseFloat($('.joinImg').attr("spacingY"))];

    $(".cutBox").width(joinShow_W);
    $(".cutBox").height(joinShow_H);
    $(".cutBox").attr("patientID", joinObjTemp.patientID);
    $(".cutBox").attr("studyTime", joinObjTemp.studyTime);
    $(".cutBox").attr("modality", joinObjTemp.modality);

    $(".cutBox").attr("name", joinObjTemp.name);
    $(".cutBox").attr("age", joinObjTemp.age);
    $(".cutBox").attr("sex", joinObjTemp.sex);
    $(".cutBox").attr("birthDate", joinObjTemp.birthDate);
    $(".cutBox").attr("studyDate", joinObjTemp.studyDate);
    $(".cutBox").attr("describe", joinObjTemp.describe);
    $(".cutBox").attr("hosName", joinObjTemp.hosName);

    $(".cutBox").attr("spacingX", $('.joinImg').attr("spacingX"));
    $(".cutBox").attr("spacingY", $('.joinImg').attr("spacingY"));

    $(".cutBox").attr("W", joinShow_W);
    $(".cutBox").attr("H", joinShow_H);
    // $(".cutBox").attr("spacingX",$('.cutActive').attr("spacingX"));
    // $(".cutBox").attr("spacingY",$('.cutActive').attr("spacingY"));
    $(".cutBox").attr("actualW", actualW[0]);
    $(".cutBox").attr("actualH", actualW[1]);

    var canvas = $(".cutBox>canvas")[0];
    canvas.width = joinShow_W;
    canvas.height = joinShow_H;
    var contxt = canvas.getContext('2d');


    //绘制拼接结果
    var joinCanvOut = $('#joinOutputCanv')[0];
    joinCanvOut.width = W;
    joinCanvOut.height = H;
    console.log("canvOut_W_H：", W, H);
    var joinContext = joinCanvOut.getContext('2d');
    joinContext.fillStyle = "#000000";//胶片底色  黑色
    joinContext.fillRect(0, 0, W, H);

    //    将其绘制到canvas中生成新的img，与原数据同类型
    for (var i = 0,len=joinObj.length; i < len; i++) {
        var zIndex = joinObj[i].zIndex;
        var x, y, _W, _H; //图像在拼接结果图中的实际起点与高宽
        x = joinObj[i].location.xstart;
        y = joinObj[i].location.ystart;
        _W = joinObj[i].location.W;
        _H = joinObj[i].location.H;
        joinContext.drawImage(joinObj[i].imageSrc, joinObj[i].location.xstart, joinObj[i].location.ystart, joinObj[i].location.W, joinObj[i].location.H);
    }//在canvas中绘制出图像拼接的最终结果


    var originImageData = joinContext.getImageData(min_xstart, min_ystart, joinShow_W, joinShow_H);//获取有效区域的图像数据
    contxt.putImageData(originImageData, 0, 0);//将图像放入裁剪盒子


    joinObj.length = 0;//清空数据
    return true;
}


function createCutImgCanv(contxt) {
    joinObj.length = 0;//清空数据
    var W = 0, H = 0;
    var joinObjTemp = {
        patientID: "",
        studyTime: "",
        modality: "",
        instanceNumber: 1,

        name: "",
        studyDate: "",
        sex: "",
        age: "",
        birthDate: "",
        imageId: "",
        hosName: "",
        describe: "",
        imageData: [],
        maxPixelValue: 0,
        minPixelValue: 0,
        slope: 0,
        intercept: 0,
        columnPixelSpacing: 0,
        rowPixelSpacing: 0,
        windowWidth: 0,
        windowCenter: 0,
        columns: 0,
        rows: 0,
        width: 0,
        height: 0
    };
    var solpe = 0, intercept = 0, pixelSpacing = 0, ww = 0, wc = 0;
    $('.cutActive').each(function () {
        W = $(this).width();
        H = $(this).height();
        //子图对象
        var imgObj = {
            imageId: $(this).attr('imageId'),
            zIndex: $(this).css('z-index'),
            imgRows: 0,
            imgCols: 0,
            xspacing: 0,
            yspacing: 0,
            imageSrc: null,
            location: {
                xstart: $(this).position().left,
                ystart: $(this).position().top,
                xend: 0,
                yend: 0,
                W: $(this).width(),
                H: $(this).height()
            }
        };
        imgObj.location.xend = $(this).width() + imgObj.location.xstart;
        imgObj.location.yend = $(this).height() + imgObj.location.ystart;
        $(this).addClass("labelTemp");
        imgObj.imageSrc = $(".labelTemp>canvas")[0];
        $(this).removeClass("labelTemp");

        if (imgObj.imageId.indexOf("load") < 0) {
            console.log("origin image");
            var imgInfo = printStruct.findOriInfoOnlyByOriId(imgObj.imageId);
            // console.log(imgInfo);
            solpe = parseFloat(imgInfo.ImageInfo.RescaleSlope.val);
            intercept = parseFloat(imgInfo.ImageInfo.RescaleIntercept.val);
            pixelSpacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);

            var elementTemp = $(this).get(0);
            var viewport = deepCopy1(cornerstone.getViewport(elementTemp));
            ww = Math.round(viewport.voi.windowWidth);
            wc = Math.round(viewport.voi.windowCenter);


            /*   joinObjTemp.name = imgInfo.PatientInfo.PatientName.val;
             joinObjTemp.age = imgInfo.PatientInfo.PatientsAge.val;
             joinObjTemp.sex = imgInfo.PatientInfo.PatientSex.val;
             joinObjTemp.birthDate = imgInfo.PatientInfo.PatientBirthDate.val;
             joinObjTemp.studyDate = imgInfo.StudyInfo.StudyDate.val;
             if (imgInfo.SeriesInfo.SeriesDescription.val) {
             joinObjTemp.describe = imgInfo.SeriesInfo.SeriesDescription.val;
             }
             if (imgInfo.EquipmentInfo.InstitutionName.val) {
             joinObjTemp.hosName = imgInfo.EquipmentInfo.InstitutionName.val;
             }*/


            imgObj.imgRows = parseInt(imgInfo.ImageInfo.Rows.val);
            imgObj.imgCols = parseInt(imgInfo.ImageInfo.Columns.val);
            imgObj.xspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
            imgObj.yspacing = parseFloat(imgInfo.ImageInfo.PixelSpacing.val);
        }
        else {
            console.log("self create image");
            // console.log(imgInfo);
            solpe = 1.0;
            intercept = 0;
            pixelSpacing = 0.6;


            ww = 255;
            wc = 128;

            /*
             joinObjTemp.name = "==";
             joinObjTemp.age = "==";
             joinObjTemp.sex = "==";
             joinObjTemp.birthDate = "==";
             joinObjTemp.studyDate = "==";
             joinObjTemp.describe = "==";
             joinObjTemp.hosName = "==";*/

            imgObj.imgRows = parseInt($(this).height());
            imgObj.imgCols = parseInt($(this).width());
            imgObj.xspacing = 0.6;
            imgObj.yspacing = 0.6;
        }
        // 重写信息 begin
        joinObjTemp.patientID = $(this).attr("patientID");
        joinObjTemp.studyTime = $(this).attr("studyTime");
        joinObjTemp.modality = $(this).attr("modality");

        joinObjTemp.name = $(this).attr("name");
        joinObjTemp.age = $(this).attr("age");
        joinObjTemp.sex = $(this).attr("sex");
        joinObjTemp.birthDate = $(this).attr("birthDate");
        joinObjTemp.studyDate = $(this).attr("studyDate");
        joinObjTemp.describe = $(this).attr("describe");
        joinObjTemp.hosName = $(this).attr("hosName");

        imgObj.xspacing = parseFloat($(this).attr("spacingX"));
        imgObj.yspacing = parseFloat($(this).attr("spacingY"));
        //重写信息 end

        joinObj.push(imgObj);
    });
    joinObj.sort(compare('zIndex'));//根据图像的堆叠次序排序
    //绘制到截图工作区域
    for (var i = 0,len=joinObj.length; i < len; i++) {
        contxt.drawImage(joinObj[i].imageSrc, 0, 0, W, H);
    }
    joinObj.length = 0;//清空数据
    return true;
}

/*
 * 获取截图数据
 * */
function getCutResult(select, canvas, position) {
    var contxt = canvas.getContext('2d');
    var ImageData = contxt.getImageData(position.xstart, position.ystart, position.width, position.height);//获取有效区域的图像数据
    canvas.width = ImageData.width;
    canvas.height = ImageData.height;
    contxt.putImageData(ImageData, 0, 0);
    select.width(ImageData.width);
    select.height(ImageData.height);
    select.find('canvas').width(ImageData.width);
    select.find('canvas').height(ImageData.height);
    return;
}

/*
 * 计算图像在拼接盒子中显示的size
 * */
function joinImgSize(imgW, imgH) {
    var _scale = 0.5 * 0.8;
    var printW = Math.ceil($('.joinBox').width());//-200
    var printH = Math.ceil($('.joinBox').height() * _scale);
    var scale = Math.min(printW / imgW, printW / imgH, printH / imgH, printH / imgW);
    printW = imgW * scale;
    printH = imgH * scale;//imgW
    return [Math.ceil(printW), Math.ceil(printH)];
}
function calcSize(selec, _scale, imgW, imgH) {
    var printW = Math.ceil(selec.width());
    var printH = Math.ceil(selec.height() * _scale);
    var scale = Math.min(printW / imgW, printW / imgH, printH / imgH, printH / imgW);
    printW = imgW * scale;
    printH = imgH * scale;
    return [Math.ceil(printW), Math.ceil(printH)];
}

/*
 * 参与拼接的字图位置微调
 * */
function positionAdjust(direct) {
    if (direct == "blank")return;
    var max = $('.joinBox').width();
    $('.joinImgSelec').each(function () {
        var left = $(this).css('left');
        var top = $(this).css('top');
        var imgW = $(this).width();
        switch (direct) {
            case "up":
                $(this).css('top', customCalc(top, "1px", "subCalc", "px", max - imgW, 0));
                // customCalc(top,"1px", "subCalc", "px");
                break;
            case "left":
                $(this).css('left', customCalc(left, "1px", "subCalc", "px", max - imgW, 0));
                // customCalc(left,"1px", "subCalc", "px");
                break;
            case "down":
                $(this).css('top', customCalc(top, "1px", "addCalc", "px", max - imgW, 0));
                // customCalc(top,"1px", "addCalc", "px");
                break;
            case "right":
                $(this).css('left', customCalc(left, "1px", "addCalc", "px", max - imgW, 0));
                // customCalc(left,"1px", "addCalc", "px");
                break;
        }


    });
}

function hideTool(mode, imgCount) {
    console.log(mode, imgCount);
 
    $('.cutBtn').hide();

    if (mode == "joinPageS") {
        $('.joinPageS').show();
    }
    else if (mode == "cropPageS") {
        $('.cropPageS').show();
        if (imgCount < 1) {
        $('.join-undo').hide();
        }
    }
    else if (mode == "previewPageS") {
            $('.previewPageS').show();
    }
}

function hidePrintBtn(mode) {
    if (mode == 2) {
        $(".join-sendToPrint1").hide();
        $(".join-sendToPrint2").show();
    }
    else if (mode == 1) {
        $(".join-sendToPrint2").hide();
        $(".join-sendToPrint1").show();
    }
    else if (mode == 0) {
        $(".join-sendToPrint2").hide();
        $(".join-sendToPrint1").hide();
    }

}

function setTitle(titleTxt) {
    $('.describTxt').text(titleTxt);
}
function  sendToPrint(mode,addLeft,addPrintPage,close) {
    var imgLength = $('.joinBox').find('.joinImg').length;
    if (imgLength < 2) {
        alert("少于2张图像，拼接无效！");
        return false;
    }

    var imageId = "loadJoinImg://" + joinOutputObj.length;
    $('.joinOutPutBox').empty();
    if(mode=="join"){
    // $('.joinOutPutBox').empty();
    // var imageId = "loadJoinImg://" + joinOutputObj.length;
    if (createJoinCanv()) {
        if(addLeft){
            addToLeftBox(imageId);//添加到右侧缩略图
        }
       if(addPrintPage){
           addToPrintPage(imageId);
       }

    }

    // console.log(joinOutputObj);
    // joinStruct.openWay = false;
    // $('.join-close').click();//清空拼接内容
    // $('.joinHelpBox').hide();
}
    if(mode=="crop"){
        // var imageId = "loadJoinImg://" + (joinOutputObj.length);
        joinOutputObj.push(cropImgArr[cropImgArr.length - 1]);
        joinOutputObj[joinOutputObj.length - 1].imageId = imageId;
        // $('.joinOutPutBox').empty();
        if (joinOutputObj.length > 0) {
            // console.log(joinOutputObj);
            if(addLeft){
                addToLeftBox(imageId);//添加到右侧缩略图
            }
            if(addPrintPage){
                addToPrintPage(imageId);
            }
            if(close){
                $('.join-close').click();//清空拼接内容
                $('.joinPreviewBox').hide();
                $(".joinCutBox").hide();
                $(".joinBox").show();
            }

            // joinStruct.openWay = false;
            // $('.join-close').click();//清空拼接内容
            // $('.joinHelpBox').hide();
        }
    }


    if(close){
        joinStruct.openWay = false;
        $('.join-close').click();//清空拼接内容
        $('.joinHelpBox').hide();
    }

    return true;
}

 



/**
 * Created by SongJing on 2017/9/11.
 */
// 根据时间生成m位随机数，最大13位随机数，并且不能保证首位不为0
function ran(m) {
    m = m > 13 ? 13 : m;
    var num = new Date().getTime();
    return num.toString().substring(13 - m);
}

//获取鼠标点击区域中的相对位置坐标
function getXAndY(event) {
    //鼠标点击的绝对位置
    Ev = event || window.event;
    var mousePos = mouseCoords(event);
    var x = mousePos.x;
    var y = mousePos.y;
    //alert("鼠标点击的绝对位置坐标："+x+","+y);
    //获取div在body中的绝对位置
    var x1 = $(".joinBox").offset().left;
    var y1 = $(".joinBox").offset().top;
    //alert("div在body中的绝对位置坐标："+x1+","+y1);
    //鼠标点击位置相对于div的坐标
    var x2 = x - x1;
    var y2 = y - y1;
    return {
        x: x2,
        y: y2
    };
}
//获取鼠标点击区域在Html绝对位置坐标
function mouseCoords(event) {
    if (event.pageX || event.pageY) {
        return {
            x: event.pageX,
            y: event.pageY
        };
    }
    return {
        x: event.clientX + document.body.scrollLeft - document.body.clientLeft,
        y: event.clientY + document.body.scrollTop - document.body.clientTop
    };
}

/*
* 属性值比较
* */
function compare(property){
    return function(a,b){
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    }
}

/*
* 获取当前日期
* */
function currentDate(){
    var mydate = new Date();
    var str = "" + mydate.getFullYear() + "/";
    str += (mydate.getMonth()+1) + "/";
    str += mydate.getDate() ;
    return str;
}

/*自定义计算类型*/
function customCalc(para1,para2, type, Suffix,max,min) {
    var result = 0;
    var length = Suffix.length;
    switch (type) {
        case  "addCalc":
                result = parseInt(para1.substring(0, para1.length - length))+parseInt(para2.substring(0, para2.length - length));
            break;
        case  "subCalc":
            result = parseInt(para1.substring(0, para1.length - length))-parseInt(para2.substring(0, para2.length - length));
            break;
        case "plus":
                result = parseInt(para1.substring(0, para1.length - length))*parseInt(para2.substring(0, para2.length - length));
            break;
    }
    if(result>max){
        result=max;
    }
    if(result<min){
        result=min;
    }
    return result;
}


/**
 * Created by SongJing on 2017/9/11.
 */


/*
 * 待处理工作：
 * 1 是否拼图的逻辑判断
 * 2 容错处理
 *
 *
 * 备注需求：
 * 1 拼接图像不可参与二次拼接
 * 2 大于等于2张图参与拼接才算是拼图
 * 3 关闭打印页面，拼接图像清空
 *
 *
 * */
var joinOutputIndex = 0;//拼接图像的图像索引编号
var joinOutputObj = [];//拼接图像的图像数据与图像信息
var joinObj = [];//参与拼接的对象,即一张拼接图像的子图集合

//对子图的截图集合 begin
var cropImgArr=[];
function loadCropImg(imageId) {
    var index = parseInt(imageId.substring(14));//根据图像ID得到图像索引编号
    var pixelData = cropImgArr[index].imageData;
    function getPixelData() {
        return pixelData;
    }

    var image = {
        imageId: imageId,
        minPixelValue: cropImgArr[index].minPixelValue,
        maxPixelValue: cropImgArr[index].maxPixelValue,
        slope: cropImgArr[index].slope,
        intercept: cropImgArr[index].intercept,
        // slope: 1.0,
        // intercept: 0,
        windowCenter: cropImgArr[index].windowCenter,
        windowWidth: cropImgArr[index].windowWidth,
        // windowCenter: 128,
        // windowWidth: 255,
        render: cornerstone.renderGrayscaleImage,
        getPixelData: getPixelData,
        rows: cropImgArr[index].height,
        columns: cropImgArr[index].width,
        height: cropImgArr[index].height,
        width: cropImgArr[index].width,
        color: false,
        columnPixelSpacing: cropImgArr[index].columnPixelSpacing,
        rowPixelSpacing: cropImgArr[index].rowPixelSpacing,
        // columnPixelSpacing: 1,
        // rowPixelSpacing: 1,
        invert: false,
        sizeInBytes: cropImgArr[index].columns * cropImgArr[index].rows * 2
    };
    var deferred = $.Deferred();
    deferred.resolve(image);
    return deferred;
}
cornerstone.registerImageLoader('loadCropImg', loadCropImg);
//对子图的截图集合 end

function loadJoinImg(imageId) {
    var index = parseInt(imageId.substring(14));//根据图像ID得到图像索引编号
    var pixelData = joinOutputObj[index].imageData;
    function getPixelData() {
        return pixelData;
    }
    var image = {
        imageId: imageId,
        minPixelValue: joinOutputObj[index].minPixelValue,
        maxPixelValue: joinOutputObj[index].maxPixelValue,
        // slope: joinOutputObj[index].slope,
        // intercept: joinOutputObj[index].intercept,
        slope: 1,
        intercept: 1,
        windowCenter: joinOutputObj[index].windowCenter,
        windowWidth: joinOutputObj[index].windowWidth,
        render: cornerstone.renderGrayscaleImage,
        getPixelData: getPixelData,
        rows: joinOutputObj[index].height,
        columns: joinOutputObj[index].width,
        height: joinOutputObj[index].height,
        width: joinOutputObj[index].width,
        color: false,
        columnPixelSpacing: joinOutputObj[index].columnPixelSpacing,
        rowPixelSpacing: joinOutputObj[index].rowPixelSpacing,
        invert: false,
        sizeInBytes: joinOutputObj[index].columns * joinOutputObj[index].rows * 2
    };
    var deferred = $.Deferred();
    deferred.resolve(image);
    return deferred;
}
cornerstone.registerImageLoader('loadJoinImg', loadJoinImg);


var joinCutObj = [];
/*
 * 加载截图对象
 * */
function loadTempImg(imageId) {
    var index = parseInt(imageId.substring(14));//根据图像ID得到图像索引编号
    var pixelData = joinCutObj[index].imageData;

    function getPixelData() {
        return pixelData;
    }

    var image = {
        imageId: imageId,
        minPixelValue: joinCutObj[index].minPixelValue,
        maxPixelValue: joinCutObj[index].maxPixelValue,
        slope: joinCutObj[index].slope,
        intercept: joinCutObj[index].intercept,
        // slope:1,
        // intercept:-1024,
        windowCenter: joinCutObj[index].windowCenter,
        windowWidth: joinCutObj[index].windowWidth,
        render: cornerstone.renderGrayscaleImage,
        getPixelData: getPixelData,
        rows: joinCutObj[index].height,
        columns: joinCutObj[index].width,
        height: joinCutObj[index].height,
        width: joinCutObj[index].width,
        color: false,
        columnPixelSpacing: joinCutObj[index].columnPixelSpacing,
        rowPixelSpacing: joinCutObj[index].rowPixelSpacing,
        invert: false,
        sizeInBytes: joinCutObj[index].columns * joinCutObj[index].rows * 2
    };
    var deferred = $.Deferred();
    deferred.resolve(image);
    return deferred;
}
cornerstone.registerImageLoader('loadTempImg', loadTempImg);


/*
 * 添加到打印页面左侧缩略图
 * */
function addToLeftBox(imageId) {
    var index = parseInt(imageId.substring(14));//根据图像ID得到图像索引编号
    //所有拼接图像默认属于一个序列
    if (!($("#joinSeries").length > 0 )) {
        var leftImgBox = $('#printLeftImgBox');//最外层
        var boxId = "joinSeriesBox";
        var seriesBoxId = "joinSeries";
        var patientName = "拼接图像";
        var seriesBoxhtml = "<ul class='orderUl'>" +
            "<li class='orderLi'>" +
            // " <span class='info' style='font-size: 10px'>" + name + "</span>" +
            // "<span class='info'  style='font-size: 10px'>" + datestr + "</span>" +
            " <div id='joinImgCount' class='orderTitle font12' title='图像数：" + (index + 1) + "'>" +

            " <div class='left'>" +
            " <span class='info' style='font-size: 10px; color: #00a379;'>" + patientName + "</span>" +
            "<span id='" + boxId + "' style='font-size: 10px; line-height: 15px;color: #00a379;'>" + currentDate() + "</span>" +
            "<span id='" + boxId + "img'> </span>" +
            "</div>" +
            "<div class='right'>" +
            "<i class='fa fa-caret-down icon' style='display: none; line-height: 30px' aria-hidden='true'></i>" +
            "<i class='fa fa-caret-right icon' aria-hidden='true'></i>" +
            " </div>" +

            " </div>" +

            " <ul id='" + seriesBoxId + "' class='imgUl ui-widget-header'>" +
            " </ul>" +
            " </li>" +
            "</ul>";
        leftImgBox.append(seriesBoxhtml);
    }

    $('#joinImgCount').attr('title', "图像数：" + (index + 1));
    var imgParent = $("#joinSeries");
    var elementId = "join_" + index;
    var seriNo = "join_1";//添加 一个seNo
    var imghtml = $(" <li id='" + elementId + "' imageId='" + imageId + "' seriNo='" + seriNo + "' class='imgLi'></li>");
    imgParent.append(imghtml);

    //填充图像
    var element = $("#" + elementId).get(0);
    cornerstone.enable(element);
    cornerstone.loadImage(imageId).then(function (image) {
        cornerstone.displayImage(element, image);
    });

    //填充图像end
}

/*
 * 添加到胶片打印布局中
 * */
function addToPrintPage(imageId) {
    var viewportfillInID = $("div[imgIn=false]").attr('id');
    if (viewportfillInID) {
        fillImage(viewportfillInID, imageId, " ");
        fillInfoOnLay(viewportfillInID);//添加图像信息
        $("#" + viewportfillInID).parent().find('.viewportBoxNo').hide();
    }
}

/*
 * drawimg
 * */
function drawEle(selec, imageId) {
    //填充图像
    var element = selec.get(0);
    cornerstone.enable(element);
    cornerstone.loadImage(imageId).then(function (image) {
        cornerstone.displayImage(element, image);
    });
    selec.find('canvas').each(function (k) {
        if (k > 0) {
            $(this).remove();
        }
    });
}




/**
 * Created by SongJing on 2017/9/11.
 */


 
function bindImgjoin() {
    $(document).on('mousedown', '.joinDiv', function () {
        joinStruct._dragFlag = true;
    });
    $(document).on('mouseup', '.joinDiv', function () {
       // console.log(1);
        joinStruct._dragFlag = false;
    });
    $(document).on('mouseenter', '.joinBox', function () {
        // console.log(2);
        joinStruct._dragIn = true;
    });
    $(document).on('mouseleave', '.joinBox', function () {
        // console.log(3);
        joinStruct._dragIn = false;
    });
    $( ".joinBox.joinImg " ).draggable({ stack: ".joinBox.joinImg" });
}


/**
 * Created by SongJing on 2018/1/2.
 */
/*function  drawRuler(wrapperID,pixelSpacing,scale) {

 }*/

/*
 * 计算图像的绘制比例
 * */
function imgDrawSize(wrapperW, wrapperH, imgW, imgH) {
    var scale = Math.min(wrapperW / imgW, wrapperW / imgH, wrapperH / imgH, wrapperH / imgW);
    return [Math.ceil(imgW * scale), Math.ceil(imgH * scale)];
}

function drawRuler(select, rulerInfo, scale) {
    select.find('.RulerBoxV').show();
    select.find('.RulerBoxH').show();
    var pixelSpacingX = rulerInfo.pixelSpacingX;
    var pixelSpacingY = rulerInfo.pixelSpacingY;
    var imgW = rulerInfo.imgW;
    var imgH = rulerInfo.imgH;

    var actualW = imgW * pixelSpacingX;
    var actualH = imgH * pixelSpacingY;

    var wrapperW = select.width();
    var wrapperH = select.height();
    var imgSize = imgDrawSize(wrapperW, wrapperH, imgW, imgH);


    var RulerW = scale*100.0 * imgSize[0] / actualW;
    var RulerH = scale*100.0 * imgSize[1] / actualH;

    /*   RulerW=RulerW-RulerW%10;
     RulerH=RulerH-RulerH%10;*/



    var top = (wrapperH - RulerH) / 2;
    var left = (wrapperW - RulerW) / 2;

    select.find('.masterLineV').height(RulerH);
    select.find('.dividingLineV').height(RulerH);
    select.find('.masterLineV').css('margin-top', top + 'px');
    select.find('.dividingLineV').css('margin-top', top + 'px');
    // console.log("drawRuler=======================================", rulerInfo,scale, RulerH);
    select.find('.masterLineH').width(RulerW);
    select.find('.dividingLineH').width(RulerW);
    select.find('.masterLineH').css('margin-left', left + 'px');
    select.find('.dividingLineH').css('margin-left', left + 'px');


   /* var gapV = RulerH / 10;
    var gapH = RulerW / 10;
    console.log("RulerH-RulerW-gapV==gapH", RulerH, RulerW, gapV, gapH);
    select.find('.cmLineH').each(function (i) {
        $(this).css('left', gapH * (i + 1) + 'px')
    });
    select.find('.cmLineV').css('margin-top', gapV + 'px');*/


}





/**
 * Created by SongJing on 2017/5/4.
 */
//调用CS服务 全部写到这个文件中

//3d发送数据状态
function sendState() {
    $('.js-VR').hide();
}
//3d就绪状态
function alreadyState() {
    $('.seriesWindow').each(function () {

        if ($(this).attr('vr') == 'true') {
            $(this).find('.js-VR').show();
        }
    });

}

//利用延时自动关闭提示框 参数单位为秒
function tipsClose(seconds) {
    setTimeout(function () {
        $('.wmf-confirm').empty();
        $('.wmf-confirm').hide();
        $('.overlay_pop').hide();
    }, 1000 * seconds);
}

/*
 //调用VR服务
 //数据打包完成后再发送
 */
callServiceVR = {

    serviceType: "VR",

    socketState: 0,//socket的连接状态
    socketConnect: function (port, seriesIndex,seriesLength, dataLength) {
        var serviceType="VR";
        var CDes = process3D.series[0].infoSet.StudyInfo.StudyDescription.val;
        var CPName = process3D.series[0].infoSet.PatientInfo.PatientName.val;
        var CSex = process3D.series[0].infoSet.PatientInfo.PatientSex.val;
        var CHos = process3D.series[0].infoSet.EquipmentInfo.InstitutionName.val;
        var CAge = process3D.series[0].infoSet.PatientInfo.PatientsAge.val;
        var imgInfo = "#CPName:" + CPName + "#CAge:" + CAge + "#CSex:" + CSex + "#CHos:" + CHos + "#CDes:" + CDes;//汉化信息



        var socketState = 0;
        try {
            // var port=$("#dataPort").val();
            socketVR = new WebSocket('ws://localhost:' + port);
            socketVR.onopen = function () {
                var state = "handle";
                var para = "#seriesLength:" + seriesLength + "#dataSize:" + dataSize_VR + "#dataLength:" + dataLength + "#dataIndex:" + 0;//seriesLength*dataSize*dataPackageLength*dataPackageIndex
                var handMsg = "serviceType:" + serviceType + "#state:" + state + para + imgInfo;
                socketVR.send(handMsg);//发送参数
                console.log(handMsg);

            };
            socketVR.onmessage = function (evt) {
                var message = evt.data;
                if (message == "over")//数据接收完毕
                {
                    console.log("over back");
                    pop_up({
                        title: "VR提示", message: "数据接收完毕!（3秒后自动关闭该窗口）",
                        yesName: "确定",
                        noName: "取消"
                    });
                    alreadyState();//VR功能就绪状态
                    tipsClose(2);
                }
                if (message == "buildok")
                {
                //    完成重建
                }
                if (message == "wait")//正在处理数据，暂时不接收新的数据
                {
                    console.log("wait");
                    pop_up({
                        title: "3D提示", message: "当前正在处理其他数据，请稍后使用该功能",
                        yesName: "确定",
                        noName: "取消"
                    });
                    alreadyState();//VR功能就绪状态
                    tipsClose(2);
                }
                if(message=="handle")//握手成功
                {
                    //发送数据
                    process3D.sendData(socketVR);
                }
                if(message=="close"){//程序socket关闭时返回的消息
                    console.log('close');
                    alreadyState();//VR功能就绪状态
                }

            };
            socketVR.onclose = function () {
                alreadyState();//VR功能就绪状态
                console.log("socketVR.onclose");

            };
            socketVR.error = function () {
                console.log("socketVR.error");
                alreadyState();//VR功能就绪状态
                socketConnectionTipsVR(socketVR.readyState );
            }
        }
        catch (e) {
            alreadyState();//VR功能就绪状态
            socketState = 3;
            console.log(e);
        }

        if (socketVR) {
            socketState = 2;
        }
        setTimeout(function () {
            //服务启动状态检查
            if (socketVR.readyState !== 1) {
                socketConnectionTipsVR(socketState);
                alreadyState();//VR功能就绪状态
            }


        }, 3000);
    }

};


/*
* 重建的相关参数
* */
process3D={
    order: 1,////1倒序 0 顺序
    serviceType: "VR",//调用服务类型
    series: undefined,
    paraVR: {
        seriesLength: 0,//序列的图像总数
        dataSize: dataSize_VR,//每个图像包中的图像数
        dataLength: 0,//图像包数
        dataIndex: 0//图像包索引
    },
    getDataOrder: function () {

        //判断数据的组织顺序
        var arrLength = process3D.series.length;
        var position1 = process3D.series[0].infoSet.ImageInfo.ImagePositionPatient.val;
        var strs1 = position1.split("\\");//定义一数组  字符分割
        var position2 = process3D.series[arrLength - 1].infoSet.ImageInfo.ImagePositionPatient.val;
        var strs2 = position2.split("\\"); //定义一数组
        var order = 0;//下载文件按生成模型的顺序
        if (parseFloat(strs1[2]) < parseFloat(strs2[2])) {
            order = 1;//倒序
        }
        return order;
    },
    sendData:function (socket) {
        if (socket.readyState !== 1) {
            socketConnectionTipsVR(socketVR.readyState);
            alreadyState();
            return;
        }
        var dataOrder = process3D.getDataOrder();//数据组织顺序
        if (dataOrder == 1) {
            process3D.series.reverse();
        }
        var dataPackage = [];

        var dataLength = process3D.paraVR.dataLength;
        var seriesLength = process3D.series.length;
        var zip = new JSZip();
        var folder = zip.folder("dicomsVR");

        $.each(process3D.series, function (index, value) {
            var data = value.dataSet;
            var fileName = "series" + "_" + index + ".dcm";//文件名
            folder.file(fileName, data.byteArray);
            //完成一个数据包的打包
            if ((index + 1) % dataSize_VR == 0) {
                dataPackage.push(zip);
                zip = new JSZip();
                folder = zip.folder("dicomsVR");
            }
            // 出现不能整除的情况，并且数据全部打包完成
            else if ((index + 1) % dataSize_VR != 0 && index == seriesLength - 1) {
                dataPackage.push(zip);
                zip = new JSZip();
                folder = zip.folder("dicomsVR");
            }
        });

        $.each(dataPackage, function (dataIndex, data) {
            data.generateAsync({type: "blob"}).then(function (blob) {
                var state = "data";
                // var para=0+"*"+0+"*"+0+"*"+dataIndex;//seriesLength*dataSize*dataPackageLength*dataPackageIndex
                var para = "#seriesLength:" + 0 + "#dataSize:" + 0 + "#dataLength:" + dataLength + "#dataIndex:" + (dataIndex+1);//seriesLength*dataSize*dataPackageLength*dataPackageIndex
                var orderMsg = "serviceType:" + process3D.serviceType + "#state:" + state + para;

                socket.send(orderMsg);//发送参数
                console.log(orderMsg);
                socket.send(blob);//发送数据
            });
        });

        var state = "over";
        var orderMsg = "serviceType:" + process3D.serviceType + "#state:" + state ;
        socket.send(orderMsg);//发送参数
        console.log("数据发送完毕");

    }
};


